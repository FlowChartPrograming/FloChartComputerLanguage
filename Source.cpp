


#include <c:\Users\Owner\source\repos\FlowChartComputerLanguage\FlowChartComputerLanguage.h>
//
#include <io.h>
#include <string>
#include <windows.system.h> 

/////#define MyByte cs_byte;
#define sbyte cs_byte
#define ToolStripDropDownButton int


namespace FlowChartComputerLanguage
{
    using namespace std;
    /////using namespace system;
    /////using system;

    ////using System.Collections.Generic;
    ////using System.Diagnostics;
    ////using System.Globalization;
    ////using System.IO;
    ////using System.Linq;
    ////using System.Reflection;
    ////using System.Runtime.CompilerServices;
    ////using System.Security;
    ////using System.Text;
    ////using System.Threading.Tasks;
    ////using System.Runtime.InteropServices;
    ////using System.ComponentModel;


    class MyUniverse
    {    
    int sysgen;
    };

    // Imports System Text

    class MsgBoxResult {
        int OK(void) { return 1; }
        int Cancel(void) { return 2; }
        int YES(void) { return 4; }
        int NO(void) { return 8; }
        int Maybe(void) { return 16; }
        int TryAgain(void) { return 32; }
        int MayBeNot(void) { return 64; }
    };


    class FlowChartMethods
    {
        ////using namespace std;
        ////using namespace system;

        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

        // **************************************************
        // Programing routines to follow
        // ********************************************************


        string MakePathName(string A)
        {
            return FlowChartComputerLanguage::myUniverse.SysGen.Constants.RMStart + NameOfPointOnly(A) + ".PathName" + MyUniverse.SysGen.Constants.RMEnd;
        }


        string MyLeft(string MyString, long Number)
        {
            ////            return Strings.Left(MyString, Number);
            return mystring + number;
        }



        void ShowSorts(string MyTable, long Total) // Displays the number of sorts made
        {
            long Count;

            Count = MyUniverse.MyCheatSheet.BugsCounted;
            MyUniverse.MyCheatSheet.BugsCounted = 0;
            if (Total > 0 & Count > 0)
                DisplayMyStatus(MyTable + " Still working . . . swapped " + Total + " Total issues's detected " + Count);
            else if (Total > 0)
                DisplayMyStatus(MyTable + " Still working . . . swapped " + Total);
        }



        // mine()

        MsgBoxResult MyMsgCtr(int MessageNumber, string SubName, string String1, string String2, string String3, string String4, string String5, string String6, string String7, string String8, string String9)
        {
            string X, J;
            int Temp;
            MsgBoxResult RtnMsgBox;

            // If MessageNumber = 1249 Then Return MsgBoxResult.Abort

            MyMsgCtr = MsgBoxResult.Ignore;
            if (IsBitSet(MessageNumber))
            {
                // X = " No Warning Message!"
                // Temp = OptionScreen.ComboBoxDebug.Items.Count
                Temp = FindMessageNumber(MessageNumber);
                if (Temp < 1 | Temp > OptionScreen.ComboBoxDebug.Items.Count)
                    // aI N F O 2 (1)
                    return constantMyErrorCode;

                X = OptionScreen.ComboBoxDebug.Items.Item(Temp).ToString;
                if (PopValue(ref X) == MessageNumber)
                {

                    J = Pop(ref X, MyUniverse.SysGen.Constants.ConstantDelimeters);
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "routine" + MyUniverse.SysGen.Constants.RMEnd, SubName);
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "tracer" + MyUniverse.SysGen.Constants.RMEnd, MessageNumber);
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string1" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String1));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string2" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String2));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string3" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String3));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string4" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String4));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string5" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String5));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string6" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String6));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string7" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String7));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string8" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String8));
                    X = MyReplace(X, MyUniverse.SysGen.Constants.RMStart + "string9" + MyUniverse.SysGen.Constants.RMEnd, PrintAbleNull(String9));
                    X = MessageNumber + FD + J + FD + SubName + "() " + Constants.vbCrLf + X; // Put it back
                    switch (Strings.LCase(Strings.Trim(J)))
                    {
                    case "error":
                    {
                        AInfo1(772, "Msg No = " + ShortHighLight(MessageNumber.ToString()), "/Msg = " + ShortHighLight(X), " Severity Level =" + ShortHighLight(J));
                        RtnMsgBox = Interaction.MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?");
                        break;
                    }

                    case "warning":
                    {
                        AInfo1(773, "Msg No = " + ShortHighLight(MessageNumber.ToString()), "/Msg = " + ShortHighLight(X), " Severity Level =" + ShortHighLight(J));
                        RtnMsgBox = Interaction.MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?");
                        break;
                    }

                    case "information":
                    {
                        RtnMsgBox = Interaction.MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?");
                        break;
                    }

                    case "status":
                    {
                        DisplayMyStatus(MessageNumber + " Unknown Error Message TypeOf " + X);
                        break;
                    }

                    case "display" // Dont Use For right now
                        :
                    {
                        RtnMsgBox = Interaction.MsgBox(X, MsgBoxStyle.YesNo, "Continue displaying this message ?");
                        break;
                    }

                    default:
                    {
                        RtnMsgBox = Interaction.MsgBox(X, MsgBoxStyle.OkCancel, "Unknown Type=" + J + Constants.vbCrLf + "unknown message number " + MessageNumber + Constants.vbCrLf + " Cancel will stop this message");
                        break;
                    }
                    }
                    switch (RtnMsgBox)
                    {
                    case MsgBoxResult.Abort:
                    {
                        break;
                    }

                    case MsgBoxResult.Cancel:
                    {
                        BitSet(MessageNumber, "off");
                        break;
                    }

                    case MsgBoxResult.Ignore:
                    {
                        break;
                    }

                    case MsgBoxResult.No:
                    {
                        BitSet(MessageNumber, "off");
                        break;
                    }

                    case MsgBoxResult.Ok:
                    {
                        break;
                    }

                    case MsgBoxResult.Retry:
                    {
                        break;
                    }

                    case MsgBoxResult.Yes:
                    {
                        break;
                    }
                    }
                    // aI N F O 2 (-2)
                    return RtnMsgBox;
                }
                // We should never get here
                // A I N F O 2 (28)
                return Interaction.MsgBox("MessageNumber  =" + MessageNumber + Constants.vbCrLf + " A = " + String1 + Constants.vbCrLf + " B = " + String2 + Constants.vbCrLf + " C = " + String3 + Constants.vbCrLf + " D = " + String4 + Constants.vbCrLf + " E = " + String5 + Constants.vbCrLf + " F = " + String6 + Constants.vbCrLf + " G = " + String7 + Constants.vbCrLf + " H = " + String8 + Constants.vbCrLf + " I = " + String9, MsgBoxStyle.AbortRetryIgnore, "No Error Message for " + MessageNumber + Constants.vbCrLf + X);
            }
            else
            {
                // Done dump raw data if message turned of (and option turned on)
                if (MyOptionTest(26) == false)
                    System.Diagnostics.Debug.Write(Constants.vbCrLf + DateTime.Now() + HighLight(String1) + HighLight(String2) + HighLight(String4) + HighLight(String5) + HighLight(String6) + HighLight(String7) + HighLight(String8) + HighLight(String9) + Constants.vbCrLf + "--------------------->msg: " + Constants.vbCrLf + HighLight(MessageNumber.ToString()) + HighLight(SubName));
                Dump3(28, DateTime.Now() + HighLight(String1) + HighLight(String2) + HighLight(String4) + HighLight(String5) + HighLight(String6) + HighLight(String7) + HighLight(String8) + HighLight(String9) + Constants.vbCrLf + "--------------------->msg: " + Constants.vbCrLf + HighLight(MessageNumber.ToString()) + HighLight(SubName));
                // A I N F O 2 (29)n
                return MsgBoxResult.Ignore;
            }
            Abug(477, "Should never get to the end of msgctr()", "", "");
            return constantMyErrorCode;
        }



        void MyGetBrush_static(string ColorName)
        {
            GetMyBrush = Brushes.Black;
            if (MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis == false)
            {
                GetMyBrush = Brushes.White;
                return;
            }

            if (ColorName == "AliceBlue")
                GetMyBrush = Brushes.AliceBlue;
            if (ColorName == "AntiqueWhite")
                GetMyBrush = Brushes.AntiqueWhite;
            if (ColorName == "Aqua")
                GetMyBrush = Brushes.Aqua;
            if (ColorName == "Aquamarine")
                GetMyBrush = Brushes.Aquamarine;
            if (ColorName == "Azure")
                GetMyBrush = Brushes.Azure;
            if (ColorName == "Beige")
                GetMyBrush = Brushes.Beige;
            if (ColorName == "Bisque")
                GetMyBrush = Brushes.Bisque;
            if (ColorName == "Black")
                GetMyBrush = Brushes.Black;
            if (ColorName == "BlanchedAlmond")
                GetMyBrush = Brushes.BlanchedAlmond;
            if (ColorName == "Blue")
                GetMyBrush = Brushes.Blue;
            if (ColorName == "BlueViolet")
                GetMyBrush = Brushes.BlueViolet;
            if (Colorname == "Brown")
                GetMyBrush = Brushes.Brown;
            if (Colorname == "BurlyWood")
                GetMyBrush = Brushes.BurlyWood;
            if (Colorname == "CadetBlue")
                GetMyBrush = Brushes.CadetBlue;
            if (Colorname == "Chartreuse")
                GetMyBrush = Brushes.Chartreuse;
            if (Colorname == "Chocolate")
                GetMyBrush = Brushes.Chocolate;
            if (Colorname == "Coral")
                GetMyBrush = Brushes.Coral;
            if (Colorname == "CornflowerBlue")
                GetMyBrush = Brushes.CornflowerBlue;
            if (Colorname == "Cornsilk")
                GetMyBrush = Brushes.Cornsilk;
            if (ColorName == "Crimson")
                GetMyBrush = Brushes.Crimson;
            if (ColorName == "Cyan")
                GetMyBrush = Brushes.Cyan;
            if (ColorName == "DarkBlue")
                GetMyBrush = Brushes.DarkBlue;
            if (ColorName == "DarkCyan")
                GetMyBrush = Brushes.DarkCyan;
            if (ColorName == "DarkGoldenrod")
                GetMyBrush = Brushes.DarkGoldenrod;
            if (ColorName == "DarkGray")
                GetMyBrush = Brushes.DarkGray;
            if (ColorName == "DarkGreen")
                GetMyBrush = Brushes.DarkGreen;
            if (ColorName == "DarkKhaki")
                GetMyBrush = Brushes.DarkKhaki;
            if (ColorName == "DarkMagenta")
                GetMyBrush = Brushes.DarkMagenta;
            if (ColorName == "DarkOliveGreen")
                GetMyBrush = Brushes.DarkOliveGreen;
            if (ColorName == "DarkOrange")
                GetMyBrush = Brushes.DarkOrange;
            if (ColorName == "DarkOrchid")
                GetMyBrush = Brushes.DarkOrchid;
            if (ColorName == "DarkRed")
                GetMyBrush = Brushes.DarkRed;
            if (ColorName == "DarkSalmon")
                GetMyBrush = Brushes.DarkSalmon;
            if (ColorName == "DarkSeaGreen")
                GetMyBrush = Brushes.DarkSeaGreen;
            if (ColorName == "DarkSlateBlue")
                GetMyBrush = Brushes.DarkSlateBlue;
            if (ColorName == "DarkSlateGray")
                GetMyBrush = Brushes.DarkSlateGray;
            if (ColorName == "DarkTurquoise")
                GetMyBrush = Brushes.DarkTurquoise;
            if (ColorName == "DarkViolet")
                GetMyBrush = Brushes.DarkViolet;
            if (ColorName == "DeepPink")
                GetMyBrush = Brushes.DeepPink;
            if (ColorName == "DeepSkyBlue")
                GetMyBrush = Brushes.DeepSkyBlue;
            if (ColorName == "DimGray")
                GetMyBrush = Brushes.DimGray;
            if (ColorName == "DodgerBlue")
                GetMyBrush = Brushes.DodgerBlue;
            if (ColorName == "Firebrick")
                GetMyBrush = Brushes.Firebrick;
            if (ColorName == "FloralWhite")
                GetMyBrush = Brushes.FloralWhite;
            if (ColorName == "ForestGreen")
                GetMyBrush = Brushes.ForestGreen;
            if (ColorName == "Fuchsia")
                GetMyBrush = Brushes.Fuchsia;
            if (ColorName == "Gainsboro")
                GetMyBrush = Brushes.Gainsboro;
            if (ColorName == "GhostWhite")
                GetMyBrush = Brushes.GhostWhite;
            if (ColorName == "Gold")
                GetMyBrush = Brushes.Gold;
            if (ColorName == "Goldenrod")
                GetMyBrush = Brushes.Goldenrod;
            if (ColorName == "Gray")
                GetMyBrush = Brushes.Gray;
            if (ColorName == "Green")
                GetMyBrush = Brushes.Green;
            if (ColorName == "GreenYellow")
                GetMyBrush = Brushes.GreenYellow;
            if (ColorName == "Honeydew")
                GetMyBrush = Brushes.Honeydew;
            if (ColorName == "HotPink")
                GetMyBrush = Brushes.HotPink;
            if (ColorName == "IndianRed")
                GetMyBrush = Brushes.IndianRed;
            if (ColorName == "Indigo")
                GetMyBrush = Brushes.Indigo;
            if (ColorName == "Ivory")
                GetMyBrush = Brushes.Ivory;
            if (ColorName == "Khaki")
                GetMyBrush = Brushes.Khaki;
            if (ColorName == "Lavender")
                GetMyBrush = Brushes.Lavender;
            if (ColorName == "LavenderBlush")
                GetMyBrush = Brushes.LavenderBlush;
            if (ColorName == "LawnGreen")
                GetMyBrush = Brushes.LawnGreen;
            if (ColorName == "LemonChiffon")
                GetMyBrush = Brushes.LemonChiffon;
            if (ColorName == "LightBlue")
                GetMyBrush = Brushes.LightBlue;
            if (ColorName == "LightCoral")
                GetMyBrush = Brushes.LightCoral;
            if (ColorName == "LightCyan")
                GetMyBrush = Brushes.LightCyan;
            if (ColorName == "LightGoldenrodYellow")
                GetMyBrush = Brushes.LightGoldenrodYellow;
            if (ColorName == "LightGray")
                GetMyBrush = Brushes.LightGray;
            if (ColorName == "LightGreen")
                GetMyBrush = Brushes.LightGreen;
            if (ColorName == "LightPink")
                GetMyBrush = Brushes.LightPink;
            if (ColorName == "LightSalmon")
                GetMyBrush = Brushes.LightSalmon;
            if (ColorName == "LightSeaGreen")
                GetMyBrush = Brushes.LightSeaGreen;
            if (ColorName == "LightSkyBlue")
                GetMyBrush = Brushes.LightSkyBlue;
            if (ColorName == "LightSlateGray")
                GetMyBrush = Brushes.LightSlateGray;
            if (ColorName == "LightSteelBlue")
                GetMyBrush = Brushes.LightSteelBlue;
            if (ColorName == "LightYellow")
                GetMyBrush = Brushes.LightYellow;
            if (ColorName == "Lime")
                GetMyBrush = Brushes.Lime;
            if (ColorName == "LimeGreen")
                GetMyBrush = Brushes.LimeGreen;
            if (ColorName == "Linen")
                GetMyBrush = Brushes.Linen;
            if (ColorName == "Magenta")
                GetMyBrush = Brushes.Magenta;
            if (ColorName == "Maroon")
                GetMyBrush = Brushes.Maroon;
            if (ColorName == "MediumAquamarine")
                GetMyBrush = Brushes.MediumAquamarine;
            if (ColorName == "MediumBlue")
                GetMyBrush = Brushes.MediumBlue;
            if (ColorName == "MediumOrchid")
                GetMyBrush = Brushes.MediumOrchid;
            if (ColorName == "MediumPurple")
                GetMyBrush = Brushes.MediumPurple;
            if (ColorName == "MediumSeaGreen")
                GetMyBrush = Brushes.MediumSeaGreen;
            if (ColorName == "MediumSlateBlue")
                GetMyBrush = Brushes.MediumSlateBlue;
            if (ColorName == "MediumSpringGreen")
                GetMyBrush = Brushes.MediumSpringGreen;
            if (ColorName == "MediumTurquoise")
                GetMyBrush = Brushes.MediumTurquoise;
            if (ColorName == "MediumVioletRed")
                GetMyBrush = Brushes.MediumVioletRed;
            if (ColorName == "MidnightBlue")
                GetMyBrush = Brushes.MidnightBlue;
            if (ColorName == "MintCream")
                GetMyBrush = Brushes.MintCream;
            if (ColorName == "MistyRose")
                GetMyBrush = Brushes.MistyRose;
            if (ColorName == "Moccasin")
                GetMyBrush = Brushes.Moccasin;
            if (ColorName == "NavajoWhite")
                GetMyBrush = Brushes.NavajoWhite;
            if (ColorName == "Navy")
                GetMyBrush = Brushes.Navy;
            if (ColorName == "OldLace")
                GetMyBrush = Brushes.OldLace;
            if (ColorName == "Olive")
                GetMyBrush = Brushes.Olive;
            if (ColorName == "OliveDrab")
                GetMyBrush = Brushes.OliveDrab;
            if (ColorName == "Orange")
                GetMyBrush = Brushes.Orange;
            if (ColorName == "OrangeRed")
                GetMyBrush = Brushes.OrangeRed;
            if (ColorName == "Orchid")
                GetMyBrush = Brushes.Orchid;
            if (ColorName == "PaleGoldenrod")
                GetMyBrush = Brushes.PaleGoldenrod;
            if (ColorName == "PaleGreen")
                GetMyBrush = Brushes.PaleGreen;
            if (ColorName == "PaleTurquoise")
                GetMyBrush = Brushes.PaleTurquoise;
            if (ColorName == "PaleVioletRed")
                GetMyBrush = Brushes.PaleVioletRed;
            if (ColorName == "PapayaWhip")
                GetMyBrush = Brushes.PapayaWhip;
            if (ColorName == "PeachPuff")
                GetMyBrush = Brushes.PeachPuff;
            if (ColorName == "Peru")
                GetMyBrush = Brushes.Peru;
            if (ColorName == "Pink")
                GetMyBrush = Brushes.Pink;
            if (ColorName == "Plum")
                GetMyBrush = Brushes.Plum;
            if (ColorName == "PowderBlue")
                GetMyBrush = Brushes.PowderBlue;
            if (ColorName == "Purple")
                GetMyBrush = Brushes.Purple;
            if (ColorName == "Red")
                GetMyBrush = Brushes.Red;
            if (ColorName == "RosyBrown")
                GetMyBrush = Brushes.RosyBrown;
            if (ColorName == "RoyalBlue")
                GetMyBrush = Brushes.RoyalBlue;
            if (ColorName == "SaddleBrown")
                GetMyBrush = Brushes.SaddleBrown;
            if (ColorName == "Salmon")
                GetMyBrush = Brushes.Salmon;
            if (ColorName == "SandyBrown")
                GetMyBrush = Brushes.SandyBrown;
            if (ColorName == "SeaGreen")
                GetMyBrush = Brushes.SeaGreen;
            if (ColorName == "SeaShell")
                GetMyBrush = Brushes.SeaShell;
            if (ColorName == "Sienna")
                GetMyBrush = Brushes.Sienna;
            if (ColorName == "Silver")
                GetMyBrush = Brushes.Silver;
            if (ColorName == "SkyBlue")
                GetMyBrush = Brushes.SkyBlue;
            if (ColorName == "SlateBlue")
                GetMyBrush = Brushes.SlateBlue;
            if (ColorName == "SlateGray")
                GetMyBrush = Brushes.SlateGray;
            if (ColorName == "Snow")
                GetMyBrush = Brushes.Snow;
            if (ColorName == "SpringGreen")
                GetMyBrush = Brushes.SpringGreen;
            if (ColorName == "SteelBlue")
                GetMyBrush = Brushes.SteelBlue;
            if (ColorName == "Tan")
                GetMyBrush = Brushes.Tan;
            if (ColorName == "Teal")
                GetMyBrush = Brushes.Teal;
            if (ColorName == "Thistle")
                GetMyBrush = Brushes.Thistle;
            if (ColorName == "Tomato")
                GetMyBrush = Brushes.Tomato;
            if (ColorName == "Transparent")
                GetMyBrush = Brushes.Transparent;
            if (ColorName == "Turquoise")
                GetMyBrush = Brushes.Turquoise;
            if (ColorName == "Violet")
                GetMyBrush = Brushes.Violet;
            if (ColorName == "Wheat")
                GetMyBrush = Brushes.Wheat;
            if (ColorName == "White")
                GetMyBrush = Brushes.White;
            if (ColorName == "WhiteSmoke")
                GetMyBrush = Brushes.WhiteSmoke;
            if (ColorName == "Yellow")
                GetMyBrush = Brushes.Yellow;
            if (ColorName == "YellowGreen")
                GetMyBrush = Brushes.YellowGreen;
        }




        // Routine  This returns a pen color by name (cause I can't make my own from RGB() to work, cause I lazy right now)
        void MyGetPen_Static(string PassedColor, string PassedDataType)        // Converts from Red/Green/Blue/Alpha to Color structure into global GetMyPen
        {
            // GetMyPen is a global that is changed and passed back.
            long IndexColor;
            string ColorORDataTypeName;
            if (Strings.Len(PassedColor) == 0 & Strings.Len(PassedDataType) == 0)
            {
                GetMyPen = Pens.Black;
                return;
            }

            GetMyPen = Pens.Black;
            ColorORDataTypeName = FindColorFromDataType(Strings.Trim(PassedDataType));
            if (Strings.Len(ColorORDataTypeName) == 0)
                ColorORDataTypeName = Strings.Trim(PassedColor);
            else
                // This is if it was a data type name passed
                ColorORDataTypeName = Strings.Trim(ColorORDataTypeName);
            if (Strings.Len(ColorORDataTypeName) == 0)
            {
                Abug(478, "Invalid data/color ", PassedColor, PassedDataType);
                ColorORDataTypeName = "Black";
            }



            if (MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis == false)
            {
                GetMyPen = Pens.White;
                return;
            }

            switch (Strings.UCase(Strings.Left(ColorORDataTypeName, 1)))
            {
            case "A":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("AliceBlue"):
                {
                    GetMyPen = Pens.AliceBlue;
                    break;
                }

                case object _ when Strings.UCase("AntiqueWhite"):
                {
                    GetMyPen = Pens.AntiqueWhite;
                    break;
                }

                case object _ when Strings.UCase("Aqua"):
                {
                    GetMyPen = Pens.Aqua;
                    break;
                }

                case object _ when Strings.UCase("Aquamarine"):
                {
                    GetMyPen = Pens.Aquamarine;
                    break;
                }

                case object _ when Strings.UCase("Azure"):
                {
                    GetMyPen = Pens.Azure;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "B":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Beige"):
                {
                    GetMyPen = Pens.Beige;
                    break;
                }

                case object _ when Strings.UCase("Bisque"):
                {
                    GetMyPen = Pens.Bisque;
                    break;
                }

                case object _ when Strings.UCase("Black"):
                {
                    GetMyPen = Pens.Black;
                    break;
                }

                case object _ when Strings.UCase("BlanchedAlmond"):
                {
                    GetMyPen = Pens.BlanchedAlmond;
                    break;
                }

                case object _ when Strings.UCase("Blue"):
                {
                    GetMyPen = Pens.Blue;
                    break;
                }

                case object _ when Strings.UCase("BlueViolet"):
                {
                    GetMyPen = Pens.BlueViolet;
                    break;
                }

                case object _ when Strings.UCase("Brown"):
                {
                    GetMyPen = Pens.Brown;
                    break;
                }

                case object _ when Strings.UCase("BurlyWood"):
                {
                    GetMyPen = Pens.BurlyWood;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "C":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("CadetBlue"):
                {
                    GetMyPen = Pens.CadetBlue;
                    break;
                }

                case object _ when Strings.UCase("Chartreuse"):
                {
                    GetMyPen = Pens.Chartreuse;
                    break;
                }

                case object _ when Strings.UCase("Chocolate"):
                {
                    GetMyPen = Pens.Chocolate;
                    break;
                }

                case object _ when Strings.UCase("Coral"):
                {
                    GetMyPen = Pens.Coral;
                    break;
                }

                case object _ when Strings.UCase("CornflowerBlue"):
                {
                    GetMyPen = Pens.CornflowerBlue;
                    break;
                }

                case object _ when Strings.UCase("Cornsilk"):
                {
                    GetMyPen = Pens.Cornsilk;
                    break;
                }

                case object _ when Strings.UCase("Crimson"):
                {
                    GetMyPen = Pens.Crimson;
                    break;
                }

                case object _ when Strings.UCase("Cyan"):
                {
                    GetMyPen = Pens.Cyan;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "D":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("DarkBlue"):
                {
                    GetMyPen = Pens.DarkBlue;
                    break;
                }

                case object _ when Strings.UCase("DarkCyan"):
                {
                    GetMyPen = Pens.DarkCyan;
                    break;
                }

                case object _ when Strings.UCase("DarkGoldenrod"):
                {
                    GetMyPen = Pens.DarkGoldenrod;
                    break;
                }

                case object _ when Strings.UCase("DarkGray"):
                {
                    GetMyPen = Pens.DarkGray;
                    break;
                }

                case object _ when Strings.UCase("DarkGreen"):
                {
                    GetMyPen = Pens.DarkGreen;
                    break;
                }

                case object _ when Strings.UCase("DarkKhaki"):
                {
                    GetMyPen = Pens.DarkKhaki;
                    break;
                }

                case object _ when Strings.UCase("DarkMagenta"):
                {
                    GetMyPen = Pens.DarkMagenta;
                    break;
                }

                case object _ when Strings.UCase("DarkOliveGreen"):
                {
                    GetMyPen = Pens.DarkOliveGreen;
                    break;
                }

                case object _ when Strings.UCase("DarkOrange"):
                {
                    GetMyPen = Pens.DarkOrange;
                    break;
                }

                case object _ when Strings.UCase("DarkOrchid"):
                {
                    GetMyPen = Pens.DarkOrchid;
                    break;
                }

                case object _ when Strings.UCase("DarkRed"):
                {
                    GetMyPen = Pens.DarkRed;
                    break;
                }

                case object _ when Strings.UCase("DarkSalmon"):
                {
                    GetMyPen = Pens.DarkSalmon;
                    break;
                }

                case object _ when Strings.UCase("DarkSeaGreen"):
                {
                    GetMyPen = Pens.DarkSeaGreen;
                    break;
                }

                case object _ when Strings.UCase("DarkSlateBlue"):
                {
                    GetMyPen = Pens.DarkSlateBlue;
                    break;
                }

                case object _ when Strings.UCase("DarkSlateGray"):
                {
                    GetMyPen = Pens.DarkSlateGray;
                    break;
                }

                case object _ when Strings.UCase("DarkTurquoise"):
                {
                    GetMyPen = Pens.DarkTurquoise;
                    break;
                }

                case object _ when Strings.UCase("DarkViolet"):
                {
                    GetMyPen = Pens.DarkViolet;
                    break;
                }

                case object _ when Strings.UCase("DeepPink"):
                {
                    GetMyPen = Pens.DeepPink;
                    break;
                }

                case object _ when Strings.UCase("DeepSkyBlue"):
                {
                    GetMyPen = Pens.DeepSkyBlue;
                    break;
                }

                case object _ when Strings.UCase("DimGray"):
                {
                    GetMyPen = Pens.DimGray;
                    break;
                }

                case object _ when Strings.UCase("DodgerBlue"):
                {
                    GetMyPen = Pens.DodgerBlue;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "F":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Firebrick"):
                {
                    GetMyPen = Pens.Firebrick;
                    break;
                }

                case object _ when Strings.UCase("FloralWhite"):
                {
                    GetMyPen = Pens.FloralWhite;
                    break;
                }

                case object _ when Strings.UCase("ForestGreen"):
                {
                    GetMyPen = Pens.ForestGreen;
                    break;
                }

                case object _ when Strings.UCase("Fuchsia"):
                {
                    GetMyPen = Pens.Fuchsia;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "G":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Gainsboro"):
                {
                    GetMyPen = Pens.Gainsboro;
                    break;
                }

                case object _ when Strings.UCase("GhostWhite"):
                {
                    GetMyPen = Pens.GhostWhite;
                    break;
                }

                case object _ when Strings.UCase("Gold"):
                {
                    GetMyPen = Pens.Gold;
                    break;
                }

                case object _ when Strings.UCase("Goldenrod"):
                {
                    GetMyPen = Pens.Goldenrod;
                    break;
                }

                case object _ when Strings.UCase("Gray"):
                {
                    GetMyPen = Pens.Gray;
                    break;
                }

                case object _ when Strings.UCase("Green"):
                {
                    GetMyPen = Pens.Green;
                    break;
                }

                case object _ when Strings.UCase("GreenYellow"):
                {
                    GetMyPen = Pens.GreenYellow;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "H":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Honeydew"):
                {
                    GetMyPen = Pens.Honeydew;
                    break;
                }

                case object _ when Strings.UCase("HotPink"):
                {
                    GetMyPen = Pens.HotPink;
                    break;
                }
                }

                break;
            }

            case "I":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("IndianRed"):
                {
                    GetMyPen = Pens.IndianRed;
                    break;
                }

                case object _ when Strings.UCase("Indigo"):
                {
                    GetMyPen = Pens.Indigo;
                    break;
                }

                case object _ when Strings.UCase("Ivory"):
                {
                    GetMyPen = Pens.Ivory;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "K":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Khaki"):
                {
                    GetMyPen = Pens.Khaki;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "L":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Lavender"):
                {
                    GetMyPen = Pens.Lavender;
                    break;
                }

                case object _ when Strings.UCase("LavenderBlush"):
                {
                    GetMyPen = Pens.LavenderBlush;
                    break;
                }

                case object _ when Strings.UCase("LawnGreen"):
                {
                    GetMyPen = Pens.LawnGreen;
                    break;
                }

                case object _ when Strings.UCase("LemonChiffon"):
                {
                    GetMyPen = Pens.LemonChiffon;
                    break;
                }

                case object _ when Strings.UCase("LightBlue"):
                {
                    GetMyPen = Pens.LightBlue;
                    break;
                }

                case object _ when Strings.UCase("LightCoral"):
                {
                    GetMyPen = Pens.LightCoral;
                    break;
                }

                case object _ when Strings.UCase("LightCyan"):
                {
                    GetMyPen = Pens.LightCyan;
                    break;
                }

                case object _ when Strings.UCase("LightGoldenrodYellow"):
                {
                    GetMyPen = Pens.LightGoldenrodYellow;
                    break;
                }

                case object _ when Strings.UCase("LightGray"):
                {
                    GetMyPen = Pens.LightGray;
                    break;
                }

                case object _ when Strings.UCase("LightGreen"):
                {
                    GetMyPen = Pens.LightGreen;
                    break;
                }

                case object _ when Strings.UCase("LightPink"):
                {
                    GetMyPen = Pens.LightPink;
                    break;
                }

                case object _ when Strings.UCase("LightSalmon"):
                {
                    GetMyPen = Pens.LightSalmon;
                    break;
                }

                case object _ when Strings.UCase("LightSeaGreen"):
                {
                    GetMyPen = Pens.LightSeaGreen;
                    break;
                }

                case object _ when Strings.UCase("LightSkyBlue"):
                {
                    GetMyPen = Pens.LightSkyBlue;
                    break;
                }

                case object _ when Strings.UCase("LightSlateGray"):
                {
                    GetMyPen = Pens.LightSlateGray;
                    break;
                }

                case object _ when Strings.UCase("LightSteelBlue"):
                {
                    GetMyPen = Pens.LightSteelBlue;
                    break;
                }

                case object _ when Strings.UCase("LightYellow"):
                {
                    GetMyPen = Pens.LightYellow;
                    break;
                }

                case object _ when Strings.UCase("Lime"):
                {
                    GetMyPen = Pens.Lime;
                    break;
                }

                case object _ when Strings.UCase("LimeGreen"):
                {
                    GetMyPen = Pens.LimeGreen;
                    break;
                }

                case object _ when Strings.UCase("Linen"):
                {
                    GetMyPen = Pens.Linen;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "M":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Magenta"):
                {
                    GetMyPen = Pens.Magenta;
                    break;
                }

                case object _ when Strings.UCase("Maroon"):
                {
                    GetMyPen = Pens.Maroon;
                    break;
                }

                case object _ when Strings.UCase("MediumAquamarine"):
                {
                    GetMyPen = Pens.MediumAquamarine;
                    break;
                }

                case object _ when Strings.UCase("MediumBlue"):
                {
                    GetMyPen = Pens.MediumBlue;
                    break;
                }

                case object _ when Strings.UCase("MediumOrchid"):
                {
                    GetMyPen = Pens.MediumOrchid;
                    break;
                }

                case object _ when Strings.UCase("MediumPurple"):
                {
                    GetMyPen = Pens.MediumPurple;
                    break;
                }

                case object _ when Strings.UCase("MediumSeaGreen"):
                {
                    GetMyPen = Pens.MediumSeaGreen;
                    break;
                }

                case object _ when Strings.UCase("MediumSlateBlue"):
                {
                    GetMyPen = Pens.MediumSlateBlue;
                    break;
                }

                case object _ when Strings.UCase("MediumSpringGreen"):
                {
                    GetMyPen = Pens.MediumSpringGreen;
                    break;
                }

                case object _ when Strings.UCase("MediumTurquoise"):
                {
                    GetMyPen = Pens.MediumTurquoise;
                    break;
                }

                case object _ when Strings.UCase("MediumVioletRed"):
                {
                    GetMyPen = Pens.MediumVioletRed;
                    break;
                }

                case object _ when Strings.UCase("MidnightBlue"):
                {
                    GetMyPen = Pens.MidnightBlue;
                    break;
                }

                case object _ when Strings.UCase("MintCream"):
                {
                    GetMyPen = Pens.MintCream;
                    break;
                }

                case object _ when Strings.UCase("MistyRose"):
                {
                    GetMyPen = Pens.MistyRose;
                    break;
                }

                case object _ when Strings.UCase("Moccasin"):
                {
                    GetMyPen = Pens.Moccasin;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "N":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("NavajoWhite"):
                {
                    GetMyPen = Pens.NavajoWhite;
                    break;
                }

                case object _ when Strings.UCase("Navy"):
                {
                    GetMyPen = Pens.Navy;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "O":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("OldLace"):
                {
                    GetMyPen = Pens.OldLace;
                    break;
                }

                case object _ when Strings.UCase("Olive"):
                {
                    GetMyPen = Pens.Olive;
                    break;
                }

                case object _ when Strings.UCase("OliveDrab"):
                {
                    GetMyPen = Pens.OliveDrab;
                    break;
                }

                case object _ when Strings.UCase("Orange"):
                {
                    GetMyPen = Pens.Orange;
                    break;
                }

                case object _ when Strings.UCase("OrangeRed"):
                {
                    GetMyPen = Pens.OrangeRed;
                    break;
                }

                case object _ when Strings.UCase("Orchid"):
                {
                    GetMyPen = Pens.Orchid;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "P":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("PaleGoldenrod"):
                {
                    GetMyPen = Pens.PaleGoldenrod;
                    break;
                }

                case object _ when Strings.UCase("PaleGreen"):
                {
                    GetMyPen = Pens.PaleGreen;
                    break;
                }

                case object _ when Strings.UCase("PaleTurquoise"):
                {
                    GetMyPen = Pens.PaleTurquoise;
                    break;
                }

                case object _ when Strings.UCase("PaleVioletRed"):
                {
                    GetMyPen = Pens.PaleVioletRed;
                    break;
                }

                case object _ when Strings.UCase("PapayaWhip"):
                {
                    GetMyPen = Pens.PapayaWhip;
                    break;
                }

                case object _ when Strings.UCase("PeachPuff"):
                {
                    GetMyPen = Pens.PeachPuff;
                    break;
                }

                case object _ when Strings.UCase("Peru"):
                {
                    GetMyPen = Pens.Peru;
                    break;
                }

                case object _ when Strings.UCase("Pink"):
                {
                    GetMyPen = Pens.Pink;
                    break;
                }

                case object _ when Strings.UCase("Plum"):
                {
                    GetMyPen = Pens.Plum;
                    break;
                }

                case object _ when Strings.UCase("PowderBlue"):
                {
                    GetMyPen = Pens.PowderBlue;
                    break;
                }

                case object _ when Strings.UCase("Purple"):
                {
                    GetMyPen = Pens.Purple;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "R":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Red"):
                {
                    GetMyPen = Pens.Red;
                    break;
                }

                case object _ when Strings.UCase("RosyBrown"):
                {
                    GetMyPen = Pens.RosyBrown;
                    break;
                }

                case object _ when Strings.UCase("RoyalBlue"):
                {
                    GetMyPen = Pens.RoyalBlue;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "S":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("SaddleBrown"):
                {
                    GetMyPen = Pens.SaddleBrown;
                    break;
                }

                case object _ when Strings.UCase("Salmon"):
                {
                    GetMyPen = Pens.Salmon;
                    break;
                }

                case object _ when Strings.UCase("SandyBrown"):
                {
                    GetMyPen = Pens.SandyBrown;
                    break;
                }

                case object _ when Strings.UCase("SeaGreen"):
                {
                    GetMyPen = Pens.SeaGreen;
                    break;
                }

                case object _ when Strings.UCase("SeaShell"):
                {
                    GetMyPen = Pens.SeaShell;
                    break;
                }

                case object _ when Strings.UCase("Sienna"):
                {
                    GetMyPen = Pens.Sienna;
                    break;
                }

                case object _ when Strings.UCase("Silver"):
                {
                    GetMyPen = Pens.Silver;
                    break;
                }

                case object _ when Strings.UCase("SkyBlue"):
                {
                    GetMyPen = Pens.SkyBlue;
                    break;
                }

                case object _ when Strings.UCase("SlateBlue"):
                {
                    GetMyPen = Pens.SlateBlue;
                    break;
                }

                case object _ when Strings.UCase("SlateGray"):
                {
                    GetMyPen = Pens.SlateGray;
                    break;
                }

                case object _ when Strings.UCase("Snow"):
                {
                    GetMyPen = Pens.Snow;
                    break;
                }

                case object _ when Strings.UCase("SpringGreen"):
                {
                    GetMyPen = Pens.SpringGreen;
                    break;
                }

                case object _ when Strings.UCase("SteelBlue"):
                {
                    GetMyPen = Pens.SteelBlue;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "T":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Tan"):
                {
                    GetMyPen = Pens.Tan;
                    break;
                }

                case object _ when Strings.UCase("Teal"):
                {
                    GetMyPen = Pens.Teal;
                    break;
                }

                case object _ when Strings.UCase("Thistle"):
                {
                    GetMyPen = Pens.Thistle;
                    break;
                }

                case object _ when Strings.UCase("Tomato"):
                {
                    GetMyPen = Pens.Tomato;
                    break;
                }

                case object _ when Strings.UCase("Transparent"):
                {
                    GetMyPen = Pens.Transparent;
                    break;
                }

                case object _ when Strings.UCase("Turquoise"):
                {
                    GetMyPen = Pens.Turquoise;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "V":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Violet"):
                {
                    GetMyPen = Pens.Violet;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "W":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Wheat"):
                {
                    GetMyPen = Pens.Wheat;
                    break;
                }

                case object _ when Strings.UCase("White"):
                {
                    GetMyPen = Pens.White;
                    break;
                }

                case object _ when Strings.UCase("WhiteSmoke"):
                {
                    GetMyPen = Pens.WhiteSmoke;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            case "Y":
            {
                switch (Strings.UCase(ColorORDataTypeName))
                {
                case object _ when Strings.UCase("Yellow"):
                {
                    GetMyPen = Pens.Yellow;
                    break;
                }

                case object _ when Strings.UCase("YellowGreen"):
                {
                    GetMyPen = Pens.YellowGreen;
                    break;
                }

                default:
                {
                    GetMyPen = Pens.Black;
                    break;
                }
                }

                break;
            }

            default:
            {
                // ?? Why am I looking it up in the color table? and then making it black
                // ohh because the RGB pen creation was to hard to do, cause Im lazy
                GetMyPen = Pens.Black;
                break;
            }
            }
            if (IsNothing(GetMyPen))
                // MyMsgCtr(1269, "GetMyPen", PassedColor & " : " & PassedDataType, ColorORDataTypeName, ColorORDataTypeName, "", "", "", "", "", "")
                GetMyPen = Pens.Red;


            // ainfo2(1)
            IndexColor = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, ColorORDataTypeName);
            MyCheckIndexs(0, 0, 0, IndexColor, 0);
            if (IndexColor > 0)
            {
                if (Color_TableStartCap(IndexColor) > 0)
                {
                }
                else
                    GetMyPen.StartCap = Drawing2D.LineCap.Flat;
                if (Color_TableEndCap(IndexColor) > 0)
                {
                }
                else
                    GetMyPen.EndCap = Drawing2D.LineCap.Flat;
                if (Color_TableStyle(IndexColor) != 0)
                {
                }
                else
                {
                }
            }
            else
            {
            }
        }


        string ConvertByte2String(char A)
        {
            return A.ToString();
        }

        long MySign(long A)       // Returns the sign value
        {
            MySign = 0;
            if (A > 0)
                return 1;
            if (A < 0)
                return -1;
        }


        // Routine  This returns an absolute value (ie: never negitive)
        long MyABS(long A)       // Returns the absolute value
        {
            if (A > 0)
                return A;
            return -A;
        }




        long long MyABS64(long long A)       // Returns the absolute value
        {
            if (A > 0)
                return A;
            return -A;
        }

        // routine to get the max value (dumb, should be a default function ! )
        long MyMax(long a, long b)
        {
            if (a > b)
                return a;
            return b;
        }


        // Routine This returns the minium of the two (long) values
        long MyMin(long a, long b)
        {
            if (a < b)
                return a;
            return b;
        }

        // **************************************************************************************************
        // Routine This returns the number forced to be between 
        // This routine returns  Min <= A <= Max
        int MyMinMax(long A, long MinimunValue, long MaximunValue)
        {
            if (A < MinimunValue)
                return MinimunValue;
            if (A > MaximunValue)
                return MaximunValue;
            return A;
        }

        // *******************************************************************
        void MakeItTheBiggestSymbolNumber(string SymbolName) // Finds the number part of a string
        {
            string A;
            long B;

            A = SymbolName;
            while (ThisIsAnAlpha(A))
                A = Strings.Mid(A, 2, Strings.Len(A));
            B = PopValue(ref A);
            if (ThisIsAnAlpha(A))
            {
                if (B > MyUniverse.SysGen.HighestSymbolNumber)
                    MyUniverse.SysGen.HighestSymbolNumber = B;
            }
        }


        // Routine This makes sure ALL MyArray bounds will never become to small.
        // Routine (continued) It also displays on OptionScreen. the size, and amount used.
        void MyMakeArraySizesBigger() // Checks that all of the arrays have room to add to
        {
            int MyNumber;
            long Named_Counter, FlowChart_Counter, Symbol_Counter, Color_Counter, DataType_Counter;

            // Named_Counter = TopOfFile("named")
            if (Named_TableCount > Information.UBound(Named_FileSymbolName))
                Named_Counter = Information.UBound(Named_FileSymbolName);
            else
                Named_Counter = Named_TableCount;
            if (Named_Counter + constantBufferSizeBeforeChangingSizeOfArray / (double)2 > Information.UBound(Named_FileSymbolName))
            {
                MyNumber = System.Convert.Tolong(MyMax(Named_Counter + constantBufferSizeBeforeChangingSizeOfArray, 16));
                var oldNamed_FileSymbolName_iSAM = Named_FileSymbolName_iSAM;
                Named_FileSymbolName_iSAM = new int[MyNumber + 1];
                if (oldNamed_FileSymbolName_iSAM != null)
                    Array.Copy(oldNamed_FileSymbolName_iSAM, Named_FileSymbolName_iSAM, Math.Min(MyNumber + 1, oldNamed_FileSymbolName_iSAM.Length));
                var oldNamed_FileSintax_Isam = Named_FileSintax_Isam;
                Named_FileSintax_Isam = new int[MyNumber + 1];
                if (oldNamed_FileSintax_Isam != null)
                    Array.Copy(oldNamed_FileSintax_Isam, Named_FileSintax_Isam, Math.Min(MyNumber + 1, oldNamed_FileSintax_Isam.Length));
                var oldNamed_FileSymbolName = Named_FileSymbolName;
                Named_FileSymbolName = new string[MyNumber + 1];
                if (oldNamed_FileSymbolName != null)
                    Array.Copy(oldNamed_FileSymbolName, Named_FileSymbolName, Math.Min(MyNumber + 1, oldNamed_FileSymbolName.Length));
                var oldNamed_Filemicrocodetext = Named_Filemicrocodetext;
                Named_Filemicrocodetext = new string[MyNumber + 1];
                if (oldNamed_Filemicrocodetext != null)
                    Array.Copy(oldNamed_Filemicrocodetext, Named_Filemicrocodetext, Math.Min(MyNumber + 1, oldNamed_Filemicrocodetext.Length));
                var oldNamed_FileSintax = Named_FileSintax;
                Named_FileSintax = new string[MyNumber + 1];
                if (oldNamed_FileSintax != null)
                    Array.Copy(oldNamed_FileSintax, Named_FileSintax, Math.Min(MyNumber + 1, oldNamed_FileSintax.Length));
                var oldNamed_FileOpCode = Named_FileOpCode;
                Named_FileOpCode = new string[MyNumber + 1];
                if (oldNamed_FileOpCode != null)
                    Array.Copy(oldNamed_FileOpCode, Named_FileOpCode, Math.Min(MyNumber + 1, oldNamed_FileOpCode.Length));
                var oldNamed_FileNotes = Named_FileNotes;
                Named_FileNotes = new string[MyNumber + 1];
                if (oldNamed_FileNotes != null)
                    Array.Copy(oldNamed_FileNotes, Named_FileNotes, Math.Min(MyNumber + 1, oldNamed_FileNotes.Length));
                var oldNamed_FileNameOfFile = Named_FileNameOfFile;
                Named_FileNameOfFile = new string[MyNumber + 1];
                if (oldNamed_FileNameOfFile != null)
                    Array.Copy(oldNamed_FileNameOfFile, Named_FileNameOfFile, Math.Min(MyNumber + 1, oldNamed_FileNameOfFile.Length));
                var oldNamed_FileStroke = Named_FileStroke;
                Named_FileStroke = new string[MyNumber + 1];
                if (oldNamed_FileStroke != null)
                    Array.Copy(oldNamed_FileStroke, Named_FileStroke, Math.Min(MyNumber + 1, oldNamed_FileStroke.Length));
                var oldNamed_FileSymbolIndexes = Named_FileSymbolIndexes;
                Named_FileSymbolIndexes = new int[MyNumber + 1];
                if (oldNamed_FileSymbolIndexes != null)
                    Array.Copy(oldNamed_FileSymbolIndexes, Named_FileSymbolIndexes, Math.Min(MyNumber + 1, oldNamed_FileSymbolIndexes.Length));
                var oldNamed_FileVersion = Named_FileVersion;
                Named_FileVersion = new string[MyNumber + 1];
                if (oldNamed_FileVersion != null)
                    Array.Copy(oldNamed_FileVersion, Named_FileVersion, Math.Min(MyNumber + 1, oldNamed_FileVersion.Length));
                var oldNamed_FileAuthor = Named_FileAuthor;
                Named_FileAuthor = new string[MyNumber + 1];
                if (oldNamed_FileAuthor != null)
                    Array.Copy(oldNamed_FileAuthor, Named_FileAuthor, Math.Min(MyNumber + 1, oldNamed_FileAuthor.Length));
                FileInputOutputScreen.PB_Size1.Width = System.Convert.Tolong((Math.Pow(MyNumber, 0.5)));
                FileInputOutputScreen.PB_Size1.Value = System.Convert.Tolong(100.0 * Named_Counter / Information.UBound(Named_FileSymbolName));
                FileInputOutputScreen.PB_LabelSizeNamed.Text = "Named" + " " + Named_Counter + "/" + Information.UBound(Named_FileSymbolName);
                MyDoEvents();
            }

            // Symbol_Counter = MyMinMax(Symbol_TableCount, 1, UBound(Symbol_FileCoded))
            if (Symbol_TableCount > Information.UBound(Symbol_FileCoded))
                Symbol_Counter = Information.UBound(Symbol_FileCoded);
            else
                Symbol_Counter = Symbol_TableCount;
            if (Symbol_Counter + constantBufferSizeBeforeChangingSizeOfArray / (double)2 > Information.UBound(Symbol_FileSymbolName))
            {
                MyNumber = System.Convert.Tolong(MyMax(Symbol_Counter + constantBufferSizeBeforeChangingSizeOfArray, 16));
                var oldSymbol_FileSymbolName = Symbol_FileSymbolName;
                Symbol_FileSymbolName = new string[MyNumber + 1];
                // sorted by symbolname
                if (oldSymbol_FileSymbolName != null)
                    Array.Copy(oldSymbol_FileSymbolName, Symbol_FileSymbolName, Math.Min(MyNumber + 1, oldSymbol_FileSymbolName.Length));
                var oldSymbol_FileCoded = Symbol_FileCoded;
                Symbol_FileCoded = new  __int8[MyNumber + 1];
                if (oldSymbol_FileCoded != null)
                    Array.Copy(oldSymbol_FileCoded, Symbol_FileCoded, Math.Min(MyNumber + 1, oldSymbol_FileCoded.Length));
                var oldSymbol_FileX1 = Symbol_FileX1;
                Symbol_FileX1 = new int[MyNumber + 1];
                if (oldSymbol_FileX1 != null)
                    Array.Copy(oldSymbol_FileX1, Symbol_FileX1, Math.Min(MyNumber + 1, oldSymbol_FileX1.Length));
                var oldSymbol_FileY1 = Symbol_FileY1;
                Symbol_FileY1 = new int[MyNumber + 1];
                if (oldSymbol_FileY1 != null)
                    Array.Copy(oldSymbol_FileY1, Symbol_FileY1, Math.Min(MyNumber + 1, oldSymbol_FileY1.Length));
                var oldSymbol_FileX2_io = Symbol_FileX2_io;
                Symbol_FileX2_io = new int[MyNumber + 1];
                if (oldSymbol_FileX2_io != null)
                    Array.Copy(oldSymbol_FileX2_io, Symbol_FileX2_io, Math.Min(MyNumber + 1, oldSymbol_FileX2_io.Length));
                var oldSymbol_FileY2_dt = Symbol_FileY2_dt;
                Symbol_FileY2_dt = new int[MyNumber + 1];
                if (oldSymbol_FileY2_dt != null)
                    Array.Copy(oldSymbol_FileY2_dt, Symbol_FileY2_dt, Math.Min(MyNumber + 1, oldSymbol_FileY2_dt.Length));
                var oldSymbol_File_NameOfPoint = Symbol_File_NameOfPoint;
                Symbol_File_NameOfPoint = new string[MyNumber + 1];
                if (oldSymbol_File_NameOfPoint != null)
                    Array.Copy(oldSymbol_File_NameOfPoint, Symbol_File_NameOfPoint, Math.Min(MyNumber + 1, oldSymbol_File_NameOfPoint.Length));
                FileInputOutputScreen.PB_Size2.Width = System.Convert.Tolong(Math.Pow(MyNumber, 0.5));
                FileInputOutputScreen.PB_Size2.Value = System.Convert.Tolong(100.0 * Symbol_Counter / Information.UBound(Symbol_FileSymbolName));
                FileInputOutputScreen.PB_LabelSizeSymbol.Text = "Symbols" + " " + SymbolNumber_Counter + "/" + Information.UBound(Symbol_FileSymbolName);
                MyDoEvents();
            }

            // FlowChart_Counter = MyMinMax(FlowChart_TableCount, 1, UBound(FlowChart_FileCoded))
            // TopOfFile("FlowChart")
            if (FlowChart_TableCount > Information.UBound(FlowChart_FileCoded))
                FlowChart_Counter = Information.UBound(FlowChart_FileCoded);
            else
                FlowChart_Counter = FlowChart_TableCount;
            if (FlowChart_Counter + constantBufferSizeBeforeChangingSizeOfArray / (double)2 > Information.UBound(FlowChart_FileCoded))
            {
                MyNumber = System.Convert.Tolong(MyMax(FlowChart_Counter + constantBufferSizeBeforeChangingSizeOfArray, 16));
                var oldFlowChart_FileCoded = FlowChart_FileCoded;
                FlowChart_FileCoded = new  __int8[MyNumber + 1];
                if (oldFlowChart_FileCoded != null)
                    Array.Copy(oldFlowChart_FileCoded, FlowChart_FileCoded, Math.Min(MyNumber + 1, oldFlowChart_FileCoded.Length));
                var oldFlowChart_FilePathSymbolName = FlowChart_FilePathSymbolName;
                FlowChart_FilePathSymbolName = new string[MyNumber + 1];
                if (oldFlowChart_FilePathSymbolName != null)
                    Array.Copy(oldFlowChart_FilePathSymbolName, FlowChart_FilePathSymbolName, Math.Min(MyNumber + 1, oldFlowChart_FilePathSymbolName.Length));
                var oldFlowChart_FileX1 = FlowChart_FileX1;
                FlowChart_FileX1 = new int[MyNumber + 1];
                if (oldFlowChart_FileX1 != null)
                    Array.Copy(oldFlowChart_FileX1, FlowChart_FileX1, Math.Min(MyNumber + 1, oldFlowChart_FileX1.Length));
                var oldFlowChart_FileY1 = FlowChart_FileY1;
                FlowChart_FileY1 = new int[MyNumber + 1];
                if (oldFlowChart_FileY1 != null)
                    Array.Copy(oldFlowChart_FileY1, FlowChart_FileY1, Math.Min(MyNumber + 1, oldFlowChart_FileY1.Length));
                var oldFlowChart_File_X2_Rotation = FlowChart_File_X2_Rotation;
                FlowChart_File_X2_Rotation = new int[MyNumber + 1];
                if (oldFlowChart_File_X2_Rotation != null)
                    Array.Copy(oldFlowChart_File_X2_Rotation, FlowChart_File_X2_Rotation, Math.Min(MyNumber + 1, oldFlowChart_File_X2_Rotation.Length));
                var oldFlowChart_File_Y2_Option = FlowChart_File_Y2_Option;
                FlowChart_File_Y2_Option = new int[MyNumber + 1];
                if (oldFlowChart_File_Y2_Option != null)
                    Array.Copy(oldFlowChart_File_Y2_Option, FlowChart_File_Y2_Option, Math.Min(MyNumber + 1, oldFlowChart_File_Y2_Option.Length));
                var oldFlowChart_File_DataType = FlowChart_File_DataType;
                FlowChart_File_DataType = new string[MyNumber + 1];
                if (oldFlowChart_File_DataType != null)
                    Array.Copy(oldFlowChart_File_DataType, FlowChart_File_DataType, Math.Min(MyNumber + 1, oldFlowChart_File_DataType.Length));
                var oldFlowChart_iSAM_X1 = FlowChart_iSAM_X1;
                FlowChart_iSAM_X1 = new int[MyNumber + 1];
                // Removed                ReDim Preserve FlowChart_FileCompiledMacroCodeText(MyNumber)
                if (oldFlowChart_iSAM_X1 != null)
                    Array.Copy(oldFlowChart_iSAM_X1, FlowChart_iSAM_X1, Math.Min(MyNumber + 1, oldFlowChart_iSAM_X1.Length));
                var oldFlowChart_iSAM_Y1 = FlowChart_iSAM_Y1;
                FlowChart_iSAM_Y1 = new int[MyNumber + 1];
                if (oldFlowChart_iSAM_Y1 != null)
                    Array.Copy(oldFlowChart_iSAM_Y1, FlowChart_iSAM_Y1, Math.Min(MyNumber + 1, oldFlowChart_iSAM_Y1.Length));
                var oldFlowChart_iSAM_X2 = FlowChart_iSAM_X2;
                FlowChart_iSAM_X2 = new int[MyNumber + 1];
                if (oldFlowChart_iSAM_X2 != null)
                    Array.Copy(oldFlowChart_iSAM_X2, FlowChart_iSAM_X2, Math.Min(MyNumber + 1, oldFlowChart_iSAM_X2.Length));
                var oldFlowChart_iSAM_Y2 = FlowChart_iSAM_Y2;
                FlowChart_iSAM_Y2 = new int[MyNumber + 1];
                if (oldFlowChart_iSAM_Y2 != null)
                    Array.Copy(oldFlowChart_iSAM_Y2, FlowChart_iSAM_Y2, Math.Min(MyNumber + 1, oldFlowChart_iSAM_Y2.Length));
                var oldFlowChart_iSAM_Name = FlowChart_iSAM_Name;
                FlowChart_iSAM_Name = new int[MyNumber + 1];
                if (oldFlowChart_iSAM_Name != null)
                    Array.Copy(oldFlowChart_iSAM_Name, FlowChart_iSAM_Name, Math.Min(MyNumber + 1, oldFlowChart_iSAM_Name.Length));

                FileInputOutputScreen.PB_Size3.Width = System.Convert.Tolong(Math.Pow(MyNumber, 0.5));
                FileInputOutputScreen.PB_Size3.Value = System.Convert.Tolong(100.0 * FlowChart_Counter / Information.UBound(FlowChart_FileCoded));
                FileInputOutputScreen.PB_LabelSizeFlowChart.Text = "FlowChart" + " " + FlowChart_Counter + "/" + Information.UBound(FlowChart_FilePathSymbolName);
                MyDoEvents();
            }


            // TopOfFile("Color")
            // Color_Counter = MyMinMax(Color_TableCount, 1, UBound(Color_FileBlue))
            if (Color_TableCount > Information.UBound(Color_FileName))
                Color_Counter = Information.UBound(Color_FileName);
            else
                Color_Counter = Color_TableCount;
            if (Color_Counter + constantBufferSizeBeforeChangingSizeOfArray / (double)2 > Information.UBound(Color_FileName))
            {
                MyNumber = System.Convert.Tolong(MyMax(Color_Counter + constantBufferSizeBeforeChangingSizeOfArray, 16));
                var oldColor_FileName = Color_FileName;
                Color_FileName = new string[MyNumber + 1];
                if (oldColor_FileName != null)
                    Array.Copy(oldColor_FileName, Color_FileName, Math.Min(MyNumber + 1, oldColor_FileName.Length));
                var oldColor_FileAlpha = Color_FileAlpha;
                Color_FileAlpha = new  __int8[MyNumber + 1];
                if (oldColor_FileAlpha != null)
                    Array.Copy(oldColor_FileAlpha, Color_FileAlpha, Math.Min(MyNumber + 1, oldColor_FileAlpha.Length));
                var oldColor_FileRed = Color_FileRed;
                Color_FileRed = new  __int8[MyNumber + 1];
                if (oldColor_FileRed != null)
                    Array.Copy(oldColor_FileRed, Color_FileRed, Math.Min(MyNumber + 1, oldColor_FileRed.Length));
                var oldColor_FileGreen = Color_FileGreen;
                Color_FileGreen = new  __int8[MyNumber + 1];
                if (oldColor_FileGreen != null)
                    Array.Copy(oldColor_FileGreen, Color_FileGreen, Math.Min(MyNumber + 1, oldColor_FileGreen.Length));
                var oldColor_FileBlue = Color_FileBlue;
                Color_FileBlue = new  __int8[MyNumber + 1];
                if (oldColor_FileBlue != null)
                    Array.Copy(oldColor_FileBlue, Color_FileBlue, Math.Min(MyNumber + 1, oldColor_FileBlue.Length));
                var oldColor_FileStyle = Color_FileStyle;
                Color_FileStyle = new  __int8[MyNumber + 1];
                if (oldColor_FileStyle != null)
                    Array.Copy(oldColor_FileStyle, Color_FileStyle, Math.Min(MyNumber + 1, oldColor_FileStyle.Length)); // 1, dash , 2, dot, 3, dashdot, 4, dashdotdot
                var oldColor_FileStartCap = Color_FileStartCap;
                Color_FileStartCap = new  __int8[MyNumber + 1];
                if (oldColor_FileStartCap != null)
                    Array.Copy(oldColor_FileStartCap, Color_FileStartCap, Math.Min(MyNumber + 1, oldColor_FileStartCap.Length));
                var oldColor_FileEndCap = Color_FileEndCap;
                Color_FileEndCap = new  __int8[MyNumber + 1];
                if (oldColor_FileEndCap != null)
                    Array.Copy(oldColor_FileEndCap, Color_FileEndCap, Math.Min(MyNumber + 1, oldColor_FileEndCap.Length));
                var oldColor_Name_iSAM = Color_Name_iSAM;
                Color_Name_iSAM = new int[MyNumber + 1];
                if (oldColor_Name_iSAM != null)
                    Array.Copy(oldColor_Name_iSAM, Color_Name_iSAM, Math.Min(MyNumber + 1, oldColor_Name_iSAM.Length));
                FileInputOutputScreen.PB_Size4.Width = System.Convert.Tolong(Math.Pow(MyNumber, 0.5));
                FileInputOutputScreen.PB_Size4.Value = System.Convert.Tolong(100.0 * Color_Counter / Information.UBound(Color_FileName));
                FileInputOutputScreen.PB_LabelSizeColor.Text = "Colors" + " " + Color_Counter + "/" + Information.UBound(Color_FileName);
                mydoevents();
            }


            // TopOfFile("DataType")
            // DataType_Counter = MyMinMax(DataType_TableCount, 1, UBound(FlowChart_FileCoded))
            if (DataType_TableCount > Information.UBound(DataType_FileName))
                DataType_Counter = Information.UBound(DataType_FileName);
            else
                DataType_Counter = DataType_TableCount;
            if (DataType_Counter + constantBufferSizeBeforeChangingSizeOfArray / (double)2 > Information.UBound(DataType_FileName))
            {
                MyNumber = System.Convert.Tolong(MyMax(DataType_Counter + constantBufferSizeBeforeChangingSizeOfArray, 16));
                var oldDataType_Name_iSAM = DataType_Name_iSAM;
                DataType_Name_iSAM = new int[MyNumber + 1];
                if (oldDataType_Name_iSAM != null)
                    Array.Copy(oldDataType_Name_iSAM, DataType_Name_iSAM, Math.Min(MyNumber + 1, oldDataType_Name_iSAM.Length));
                var oldDataType_FileName = DataType_FileName;
                DataType_FileName = new string[MyNumber + 1];
                if (oldDataType_FileName != null)
                    Array.Copy(oldDataType_FileName, DataType_FileName, Math.Min(MyNumber + 1, oldDataType_FileName.Length));
                var oldDataType_FileColorIndex = DataType_FileColorIndex;
                DataType_FileColorIndex = new int[MyNumber + 1];
                if (oldDataType_FileColorIndex != null)
                    Array.Copy(oldDataType_FileColorIndex, DataType_FileColorIndex, Math.Min(MyNumber + 1, oldDataType_FileColorIndex.Length));
                var oldDataType_FileDescribtion = DataType_FileDescribtion;
                DataType_FileDescribtion = new string[MyNumber + 1];
                if (oldDataType_FileDescribtion != null)
                    Array.Copy(oldDataType_FileDescribtion, DataType_FileDescribtion, Math.Min(MyNumber + 1, oldDataType_FileDescribtion.Length));
                var oldDataType_FileNumberOfBytes = DataType_FileNumberOfBytes;
                DataType_FileNumberOfBytes = new int[MyNumber + 1];
                if (oldDataType_FileNumberOfBytes != null)
                    Array.Copy(oldDataType_FileNumberOfBytes, DataType_FileNumberOfBytes, Math.Min(MyNumber + 1, oldDataType_FileNumberOfBytes.Length));
                var oldDataType_FileWidth = DataType_FileWidth;
                DataType_FileWidth = new  __int8[MyNumber + 1];
                if (oldDataType_FileWidth != null)
                    Array.Copy(oldDataType_FileWidth, DataType_FileWidth, Math.Min(MyNumber + 1, oldDataType_FileWidth.Length));
                FileInputOutputScreen.PB_Size5.Width = System.Convert.Tolong(Math.Pow(MyNumber, 0.5));
                FileInputOutputScreen.PB_Size5.Value = System.Convert.Tolong(100.0 * DataType_Counter / Information.UBound(DataType_FileName));
                FileInputOutputScreen.PB_LabelSizeDataType.Text = "DataType" + " " + DataType_Counter + "/" + Information.UBound(DataType_FileName);

                mydoevents();
            }
        }


        // *****************************************************************
        // This makes sure that the file counters of where you are is inside the bounds of the arrays
        long FileCounter(string MyTable)
        {
            MyMakeArraySizesBigger();
            switch (MyTable)
            {
            case "color":
            {
                FileCounter = MyMinMax(Color_TableCount, 0, Information.UBound(Color_FileName));
                while (FileCounter > 0 & Strings.Len(Color_FileName[FileCounter]) == 0)
                    FileCounter -= 1;
                break;
            }

            case "FlowChart":
            {
                FileCounter = MyMinMax(FlowChart_TableCount, 0, Information.UBound(FlowChart_FileCoded));
                while (FileCounter > 0 & Strings.Len(FlowChart_FilePathSymbolName[FileCounter]) == 0)
                    FileCounter -= 1;
                break;
            }

            case "named":
            {
                FileCounter = MyMinMax(Named_TableCount, 0, Information.UBound(Named_FileSymbolName));
                while (FileCounter > 0 & Strings.Len(Named_FileSymbolName[FileCounter]) == 0)
                    FileCounter -= 1;
                break;
            }

            case "symbol":
            {
                FileCounter = MyMinMax(Symbol_TableCount, 0, Information.UBound(Symbol_FileSymbolName));
                while (FileCounter > 0 & Symbol_FileCoded[FileCounter] == 0)
                    FileCounter -= 1;
                break;
            }

            case "datatype":
            {
                FileCounter = MyMinMax(DataType_TableCount, 0, Information.UBound(DataType_FileName));
                while (FileCounter > 0 & Strings.Len(DataType_FileName[FileCounter]) == 0)
                    FileCounter -= 1;
                break;
            }

            default:
            {
                FileCounter = 0; // CInt((Color_TableCount + FlowChart_TableCount + Named_TableCount + Symbol_TableCount + DataType_TableCount) / 5)
                Abug(105, "This is a Wrong table name", MyTable, FileCounter);
                break;
            }
            }
        }


        void FileCounter2(string MyTable, long NewValue) // Keeps track of the highest pointer of the MyTable Arrays
        {
            switch (MyTable)
            {
            case "Color":
            {
                Color_TableCount = NewValue;
                break;
            }

            case "FlowChart":
            {
                FlowChart_TableCount = NewValue;
                break;
            }

            case "Named":
            {
                Named_TableCount = NewValue;
                break;
            }

            case "Symbol":
            {
                Symbol_TableCount = NewValue;
                break;
            }

            case "DataType":
            {
                DataType_TableCount = NewValue;
                // Abug(106, "FileCounter: ", MyTable, 0) 'hack
                FindingMyBugs(10); // hack Least amount of checking here 'hack
                break;
            }
            }
            MyMakeArraySizesBigger();
        }

        // ************************************************************************************
        // One of many routines that returns the top of the data in the array
        long NewTopOfFile(string MyTable)
        {
            NewTopOfFile = FileCounter(MyTable) + 1;
            FileCounter2(MyTable, NewTopOfFile);
        }

        // ****************************************************************
        // This is to keep track of the top of the USED arrays (as opposed to the size of the array)

        int TopOfFile(string MyTable)
        {
            TopOfFile = FileCounter(MyTable); // get the max size that it should be
        }

        void ShowThisScreen(int ScreenNumber, int status)
        {
            switch (status)
            {
            case HideScreen1:
            {
                F.Visible = false;
                F.SendToBack();
                break;
            }

            case ShowScreen1:
            {
                F.Visible = true;
                F.BringToFront();
                MyButtonsEnableRules(); // enable and disable the buttons on all forms
                break;
            }
            }
        }


        void ShowAllForms(int FormFlowChart, int FormSymbol, int FormOption, int FormFileIO, int FormStatus, int FormHelp)
        {
            string Temp;
            // -1 is no change (sent to the back)
            // 0 is make it invisible (not being used right now)
            // 1 is make it the front and visible
            Temp = MyUniverse.ProgramOptions.SelectedSymbolName;

            if (Temp == "")
            {
                Temp = "Start";
                // Need to select it in the drop down list  (OK, I forgot what I called that subroutine
                FlowChartScreen.ToolStripDropDownSelectSymbol.Text = "Start";
                SymbolScreen.ToolStripDropDownSelectSymbol.Text = "Start";
                MyUniverse.ProgramOptions.SelectedSymbolName = "Start";
            }
            // No because it overrides the select symbol with "start"  GetAllSymbolNames("Start") 'todo check that this is require HERE?
            GetAllSymbolNames(Temp);



            if (MyFlowChartNameSpace.F_C.ProgramAlive == false)
            {
                ShowThisScreen(FlowChartScreen, HideScreen1);
                ShowThisScreen(SymbolScreen, HideScreen1);
                ShowThisScreen(OptionScreen, HideScreen1);
                ShowThisScreen(FileInputOutputScreen, HideScreen1);
            }
            else
            {
                ShowThisScreen(FlowChartScreen, FormFlowChart);
                ShowThisScreen(SymbolScreen, FormSymbol);
                ShowThisScreen(OptionScreen, FormOption);
                ShowThisScreen(FileInputOutputScreen, FormFileIO);
                // MyButtonsEnableRules()
                MyDoEvents();
            }
            // "UpDateC_L_() 'This changes the language (if changed) 'hack this really is just a hack job and needs to be fixed.
            MyDoEvents();
        }


        MyPointStructure MyRotated(long IndexSymbol, long IndexFlowChart)
        {
            string RotationName;
            MyPointStructure InputXY;
            MyPointStructure OffsetXY;
            InputXY = default(MyPointStructure);
            OffsetXY = default(MyPointStructure);
            RotationName = FlowChart_Table_Rotation(IndexFlowChart);
            MyCheckIndexs(IndexFlowChart, IndexSymbol, 0, 0, 0);
            if (IndexSymbol == 0)
            {
                InputXY.Xx = 0;
                InputXY.Yy = 0;
                SetNameOfPoint(ref InputXY, "", "", "");
            }
            else
            {
                InputXY.Xx = Symbol_TableX1(IndexSymbol);
                InputXY.Yy = Symbol_TableY1(IndexSymbol);
                SetNameOfPoint(ref InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "");
            }
            OffsetXY.Xx = FlowChart_TableX1(IndexFlowChart);
            OffsetXY.Yy = FlowChart_TableY1(IndexFlowChart);
            switch (FlowChart_TableCode(IndexFlowChart))
            {
            case "/use":
            {
                SetNameOfPoint(ref OffsetXY, "", FlowChart_TableSymbol_Name(IndexFlowChart), "");
                break;
            }

            case "/path":
            {
                SetNameOfPoint(ref OffsetXY, "", "", FlowChart_TablePathNumber(IndexFlowChart));
                break;
            }

            case null:
            {
                break;
            }

            default:
            {
                SetNameOfPoint(ref OffsetXY, "?" + FlowChart_TableCode(IndexFlowChart), "??" + FlowChart_TableCode(IndexFlowChart), "???" + FlowChart_TableCode(IndexFlowChart));
                break;
            }
            }
            MyRotated = MyRotated_x(InputXY, OffsetXY, RotationName);
        }

        MyPointStructure MyRotated_1(long IndexSymbol, MyPointStructure OffsetXY, string RotationName)
        {
            MyPointStructure InputXY;
            InputXY = default(MyPointStructure);
            MyCheckIndexs(0, IndexSymbol, 0, 0, 0);
            InputXY.Xx = Symbol_TableX1(IndexSymbol);
            InputXY.Yy = Symbol_TableY1(IndexSymbol);
            SetNameOfPoint(ref InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "");
            MyRotated_1 = MyRotated_x(InputXY, OffsetXY, RotationName);
        }


        MyPointStructure MyRotated_1a(long IndexSymbol, string RotationName)
        {
            MyPointStructure InputXY;
            InputXY = default(MyPointStructure);
            MyCheckIndexs(0, IndexSymbol, 0, 0, 0);
            InputXY.Xx = Symbol_TableX1(IndexSymbol);
            InputXY.Yy = Symbol_TableY1(IndexSymbol);
            SetNameOfPoint(ref InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "");
            MyRotated_1a = MyRotated_x(InputXY, ZeroZero, RotationName);
        }




        MyPointStructure MyRotated_2(long IndexSymbol, long IndexFlowChart, string RotationName)
        {
            MyPointStructure InputXY;
            MyPointStructure OffsetXY;
            InputXY = default(MyPointStructure);
            OffsetXY = default(MyPointStructure);

            MyCheckIndexs(IndexFlowChart, IndexSymbol, 0, 0, 0);
            FindingMyBugs(10); // hack Least amount of checking here 'hack
            InputXY.Xx = Symbol_TableX2(IndexSymbol);
            InputXY.Yy = Symbol_TableY2(IndexSymbol);
            SetNameOfPoint(ref InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "");
            OffsetXY.Xx = FlowChart_TableX1(IndexFlowChart);
            OffsetXY.Yy = FlowChart_TableY1(IndexFlowChart);
            SetNameOfPoint(ref OffsetXY, "", FlowChart_TablePathName(IndexFlowChart), FlowChart_TablePathNumber(IndexFlowChart).ToString());
            MyRotated_2 = MyRotated_x(InputXY, OffsetXY, RotationName);
        }

        MyPointStructure MyRotated_2(long IndexSymbol, MyPointStructure OffsetXY, string RotationName)
        {
            MyPointStructure InputXY;
            InputXY = default(MyPointStructure);
            MyCheckIndexs(0, IndexSymbol, 0, 0, 0);
            FindingMyBugs(10); // hack Least amount of checking here
            InputXY.Xx = Symbol_TableX2(IndexSymbol);
            InputXY.Yy = Symbol_TableY2(IndexSymbol);
            SetNameOfPoint(ref InputXY, Symbol_Table_NameOfPoint(IndexSymbol), "", "");
            MyRotated_2 = MyRotated_x(InputXY, OffsetXY, RotationName);
        }


        long FlipFlop(long WhichOne, long Index)
        {
            if (WhichOne == MyMinMax(WhichOne, 1, 4))
            {
                if (Index == MyMinMax(Index, 0, 12))
                    return MyRotation[WhichOne, Index];
            }
            return MyRotation[WhichOne, 1];
        }
        void SaveRotation(long Index, string InputString)
        {
            MyRotation[1, Index] = PopValue(ref InputString);
            MyRotation[2, Index] = PopValue(ref InputString);
            MyRotation[3, Index] = PopValue(ref InputString);
            MyRotation[4, Index] = PopValue(ref InputString);
        }


        MyPointStructure MyRotated_x(MyPointStructure InputXY, MyPointStructure OffsetXY, string RotationName)
        {
            long R;
            MyRotated_x = default(MyPointStructure);
            R = MyEnumValue(RotationName, SymbolScreen.ToolStripDropDownRotation);
            if (R < 0 | R > 16)
            {
                MyMsgCtr(1273, "MyRotated_x", R.ToString(), RotationName, "", "", "", "", "", "", "");
                R = 1;
            }
            MyRotated_x.Xx = InputXY.Xx * FlipFlop(1, R) + InputXY.Yy * FlipFlop(2, R);
            MyRotated_x.Yy = InputXY.Xx * FlipFlop(3, R) + InputXY.Yy * FlipFlop(4, R);
            MyRotated_x.Xx += OffsetXY.Xx;
            MyRotated_x.Yy += OffsetXY.Yy;
            SetNameOfPoint(ref MyRotated_x, InputXY.named.PathName, InputXY.named.SymbolName, InputXY.named.PathName);
        }

        void AddNewSymbol(string SymbolName)
        {
            long IndexNamed, IndexSymbol;
            // First make sure that we are not changing the name to something already there
            IndexNamed = FindiSAM_IN_Table("Named", "Do Not add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);

            // todo need to add a message that you cant rename to something that already exist.
            if (IndexNamed > constantMyErrorCode)
                return; // Name already there so dont add it again

            // If we are then get all of the old information
            // Second Add it to the Named Table if not already there
            // IndexNamed =
            FindiSAM_IN_Table("Named", "add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            // third add it to the symbol table If not already therecoded
            IndexSymbol = System.Convert.Tolong(FindInSymbolList(ref SymbolName));
            if (IndexSymbol <= 0)
            {
                // add in the name record for this symbol
                NewTopOfFile("Symbol");
                MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), SymbolName, "/name", MyLine1(0, 0, 0, 0), "");
            }
            else
                AInfo(602, "new symbol name warning? ", HighLight(SymbolName), MyShowNamed(IndexSymbol));
            MyMakeArraySizesBigger();
            // 2020 07 17 removed because only the named needs to be sorted, aand is done on insert 'SortALLisam()
            // reget all symbol names (could replace this with only adding the symbol name added
            // GetAllSymbolNames(SymbolName)
            AddSymbolToDropDown(SymbolName);
        }

        void AddAtomsToKeywordOROperatorORFunctionList(string MyTable, string Key, string MyArray[])
        {
            long I;
            long PerCentageFull; // percentage as integer

            MyMakeArraySizesBigger();
            if (Information.IsNothing(Key) | Key == "")
            {
                Abug(107, "Keyward blank", Key, "");
                return;
            }
            I = FindInSortedLanguageList(MyTable, ref Strings.LCase(Strings.Trim(Key)), ref MyArray);
            if (I != constantMyErrorCode)
            {
                if (Strings.LCase(Strings.Trim(Key)) != Strings.LCase(MyArray[I]))
                {
                    if (Strings.Len(MyArray[I]) == 0)
                        // MyArray(I) = Key
                        goto FoundEndAtI;
                    else
                    {
                        for (I = 0; I <= Information.UBound(MyArray); I++)
                        {
                            if (MyArray[I] == Key)
                            {
                                Abug(108, MyTable + " is not added twice", Key, MyArray[I]);
                                return; // found where the binary search failed
                            }
                        }
                        I = Information.UBound(MyArray);
                        goto FoundEndAtI; // Never add a duplicate key
                    }
                }
                else
                {
                }
            }


            I = MyMinMax(Information.UBound(MyArray), 1, Information.UBound(MyArray)); // Find the top MAKE sure it's not less than one.
            while (MyArray[I] == null) // Find the top of the data
            {
                I -= 1;
                if (I < 2)
                {
                    I = 1; // in case it comes back as zero
                    break;
                }
            }


            if (Information.IsNothing(MyArray[I]))
            {
                if (I == 1)
                    I = 1;
                else
                    I += 1;
            }
            else
                while ((I < Information.UBound(MyArray)) & (!Information.IsNothing(MyArray[I])))
                {
                    if (I == Information.UBound(MyArray))
                    {
                        var oldMyArray = MyArray;
                        MyArray = new string[I + 1 + 1];
                        if (oldMyArray != null)
                            Array.Copy(oldMyArray, MyArray, Math.Min(I + 1 + 1, oldMyArray.Length));
                    }
                    I += 1;
                }

        FoundEndAtI:
            ;
            MyArray[I] = Key; // We should be at an empty one
            ShowSorts(MyTable, ReSortLanguagekeyWord(MyTable, ref MyArray, I));
            var oldMyArray = MyArray;
            MyArray = new string[Information.UBound(MyArray) + 1 + 1];
            if (oldMyArray != null)
                Array.Copy(oldMyArray, MyArray, Math.Min(Information.UBound(MyArray) + 1 + 1, oldMyArray.Length));

            MyDoEvents();

            switch (MyTable)
            {
            case "Function":
            {
                PerCentageFull = System.Convert.Tolong(100.0 * I / (100 + Information.UBound(Language_Function)));
                FileInputOutputScreen.ProgressBarFunctions.Value = PerCentageFull;
                DisplayStatusOnly(ref FileInputOutputScreen.LabelFunctions.Text, "function:" + I);
                break;
            }

            case "Operator":
            {
                PerCentageFull = System.Convert.Tolong(100.0 * I / (100 + Information.UBound(Language_Operator)));
                FileInputOutputScreen.ProgressBarOperators.Value = PerCentageFull;
                DisplayStatusOnly(ref FileInputOutputScreen.LabelOperators.Text, "Operator:" + I);
                break;
            }

            case "keyWord":
            {
                PerCentageFull = System.Convert.Tolong(100.0 * I / (100 + Information.UBound(Language_KeyWord)));
                FileInputOutputScreen.ProgressBarKeyWords.Value = PerCentageFull;
                DisplayStatusOnly(ref FileInputOutputScreen.LabelKeyWords.Text, "keyWord:" + I);
                break;
            }
            }
            MyDoEvents();
        }


        string MyRnd()
        {
            string x;
            x = "";
            while (Strings.Len(x) < 32)
                x += Strings.Mid(VBMath.Rnd(), 4, 1);
            // A I N F O 2 (36)
            return Strings.Mid(x, 3, 28);
        }



        void DoCommandLineInput(string MyCommands)
        {
            string Cmd;
            string[] T = new string[1];
            long I;

            Cmd = MyCommands;


            Cmd = " /drilldown=" & MyUniverse.MySystem.USER.DirectoryPath1 & "\\C\\c#keyWord.symbol";
            Cmd = Cmd + " /drilldown=" & MyUniverse.MySystem.USER.DirectoryPath1 & "\\Demo C.Files\\Story.c";

            while (Strings.Len(Cmd) > 0)
            {
                var oldT = T;
                T = new string[Information.UBound(T) + 1 + 1];
                if (oldT != null)
                    Array.Copy(oldT, T, Math.Min(Information.UBound(T) + 1 + 1, oldT.Length));
                T[Information.UBound(T)] = Pop(ref Cmd, MyUniverse.SysGen.Constants.ConstantDelimeters);
            }

            for (I = Information.LBound(T) + 1; I <= Information.UBound(T); I++)
            {
                switch (Strings.LCase(T[I]))
                {
                case "/import":
                {
                    break;
                }

                case "/export":
                {
                    break;
                }

                case "/login":
                {
                    break;
                }

                case "/drilldown":
                {
                    MyDeCompile(FlowChartScreen.PictureBox1, T[I + 1]);
                    break;
                }

                default:
                {
                    break;
                }
                }
            }
        }



        void MakeListOfLanguagesClassesFromFiles(string RootLanguageFile, string RootDirectory)
        {
            string[] AllLanguagesClass;
            string X;
            string[] MyMenuItemToAdd;
            long I, Kounter;

            AllLanguagesClass = new string[1];
            AllLanguagesClass[0] = null;

            MyMenuItemToAdd = new string[1];

            Kounter = 0;
            X = FileSystem.Dir(RootLanguageFile & "\\*.", Constants.vbDirectory);
            // AInfo( 9 9 9, "Top Directory for getting Computer Language files", RootLanguageFile, X)
            while (X != "")
            {
                Kounter += 1;
                var oldAllLanguagesClass = AllLanguagesClass;
                AllLanguagesClass = new string[Kounter + 1];
                if (oldAllLanguagesClass != null)
                    Array.Copy(oldAllLanguagesClass, AllLanguagesClass, Math.Min(Kounter + 1, oldAllLanguagesClass.Length)); // save all of the directory
                AllLanguagesClass[Kounter] = RootLanguageFile & "\\" & X;
                X = FileSystem.Dir();
            }


            MyMenuItemToAdd[0] = FileNameOnly(RootLanguageFile);

            MakeLanguageClassDropDown(AllLanguagesClass);


            for (i = 1; i <= Information.UBound(AllLanguagesClass); i++)
                MakeListOfLanguagesClassesFromFiles(AllLanguagesClass[I], AllLanguagesClass[I]);
        }





        void MakeDialectListFromFile(string DialectFileName)
        {
            string X;
            string[] MyMenuItemToAdd = new string[1];
            MyMenuItemToAdd[0] = null;

            X = FileSystem.Dir(DialectFileName & "\\* definition.symbol"); // now get all of the Definition files in this directory
            while (X != "")
            {
                if (Strings.InStr(Strings.LCase(X), "Definition.symbol") != 0)
                {
                    X = Strings.Replace(X, "Definition.symbol", "");
                    var oldMyMenuItemToAdd = MyMenuItemToAdd;
                    MyMenuItemToAdd = new string[Information.UBound(MyMenuItemToAdd) + 1 + 1];
                    // AInfo( 9 9 9, "Computer Language file", RootLanguageFile, X)
                    if (oldMyMenuItemToAdd != null)
                        Array.Copy(oldMyMenuItemToAdd, MyMenuItemToAdd, Math.Min(Information.UBound(MyMenuItemToAdd) + 1 + 1, oldMyMenuItemToAdd.Length));
                    MyMenuItemToAdd[Information.UBound(MyMenuItemToAdd)] = Strings.Trim(X);
                }
                X = FileSystem.Dir();
            }
            MakeDielectDropDown(MyMenuItemToAdd);
        }

        void MakeLanguageClassDropDown(string MyMenuItemStringArray[])
        {
            long I;
            string X;
            X = MyMenuItemStringArray[0];
            if (Information.UBound(MyMenuItemStringArray) < 1)
                return; // must be in a sub directory
            // First add the class if not already there.
            for (I = 0; I <= OptionScreen.ListBoxLanguage.Items.Count - 1; I++)
            {
                if (OptionScreen.ListBoxLanguage.Items.Item(I).ToString == MyMenuItemStringArray[0])
                    X = null;
            }
            if (X != null)
                OptionScreen.ListBoxLanguage.Items.Add(X);
            for (I = 1; I <= Information.UBound(MyMenuItemStringArray); I++)
            {
                if (Strings.Len(FileNameOnly(MyMenuItemStringArray[I])) > 0)
                    OptionScreen.ListBoxLanguage.Items.Add(FileNameOnly(MyMenuItemStringArray[I]));
            }
        }


        string FileNameOnly(string P)
        {
            FileNameOnly = P;
            while (Strings.InStr(FileNameOnly, "\\") != 0)
                FileNameOnly = Strings.Mid(FileNameOnly, Strings.InStr(FileNameOnly, &"\\") + 1, Strings.Len(FileNameOnly));
        }



        void MakeDielectDropDown(string MyMenuItemStringArray[])
        {
            long I;
            OptionScreen.ListBoxDialect.Items.Clear();
            for (I = 1; I <= Information.UBound(MyMenuItemStringArray); I++)
                OptionScreen.ListBoxDialect.Items.Add(Strings.Trim(MyMenuItemStringArray[I]));
        }








        // Routine  Sets up (and resets) the original values for all parameters (for new, open, and next level file)
        void Init() // Load all Starting list, combobox(s) and other Information(s)
        {
            sbyte D;
            long I;
            long II, Idex;
            string TempCode;
            MyPointStructure MyDebugP;





            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex = -2;
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -2;
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = "xyzzy";

            MyUniverse.MyStaticData.MyEnum.LastWhatString = "zzzzz";
            MyUniverse.MyStaticData.MyEnum.LastComboBox = "zzzzz";
            MyUniverse.MyStaticData.MyEnum.Last_Enum = -1;
            MyUniverse.MyStaticData.MyEnum.LastResults = new string[21];
            MyUniverse.MyStaticData.MyUnEnum.LastWhatString = "zzzzz";
            MyUniverse.MyStaticData.MyUnEnum.LastComboBox = "zzzzz";
            MyUniverse.MyStaticData.MyUnEnum.LastUnEnum = "zzzzz";
            MyUniverse.MyStaticData.MyUnEnum.LastResults = new string[21];

            MyUniverse.MySystem.USER.Info_AssemblyName = My.Application.Info.AssemblyName;
            MyUniverse.MySystem.USER.Info_CompanyName = My.Application.Info.CompanyName;
            MyUniverse.MySystem.USER.Info_Copyright = My.Application.Info.Copyright;
            MyUniverse.MySystem.USER.Info_Description = My.Application.Info.Description;
            MyUniverse.MySystem.USER.DirectoryPath1 = My.Application.Info.DirectoryPath;
            MyUniverse.MySystem.USER.DirectoryPath2 = Application.UserAppDataPath.ToString();

            MyUniverse.MySystem.USER.Info_ProductName = My.Application.Info.ProductName;
            MyUniverse.MySystem.USER.Info_StackTrace = My.Application.Info.StackTrace;
            MyUniverse.MySystem.USER.Info_Title = My.Application.Info.Title;
            MyUniverse.MySystem.USER.Info_Trademark = My.Application.Info.Trademark;
            MyUniverse.MySystem.USER.Info_Version = My.Application.Info.Version.ToString;
            MyUniverse.MySystem.USER.Info_WorkingSet = My.Application.Info.WorkingSet.ToString;
            MyUniverse.MySystem.USER.MinimumSplashScreenDisplayTime = My.Application.MinimumSplashScreenDisplayTime.ToString;
            MyUniverse.MySystem.USER.UICulture_DisplayName = My.Application.UICulture.DisplayName;
            MyUniverse.MySystem.USER.UICulture_EnglishName = My.Application.UICulture.EnglishName;
            MyUniverse.MySystem.USER.UICulture_Name = My.Application.UICulture.Name;
            MyUniverse.MySystem.USER.UICulture_NativeName = My.Application.UICulture.NativeName;
            MyUniverse.MySystem.USER.UICulture_Parent_Name = My.Application.UICulture.Parent.Name;
            MyUniverse.MySystem.USER.UICulture_TwoLetterISOLanguageName = My.Application.UICulture.ThreeLetterISOLanguageName;
            MyUniverse.MySystem.USER.UICulture_ThreeLetterWindowsLanguageName = My.Application.UICulture.ThreeLetterWindowsLanguageName;
            MyUniverse.MySystem.USER.UICulture_TwoLetterISOLanguageName = My.Application.UICulture.TwoLetterISOLanguageName;
            MyUniverse.MySystem.USER.Info_CompanyName = My.Computer.FileSystem.CurrentDirectory;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_CurrentUserApplicationData = My.Computer.FileSystem.SpecialDirectories.AllUsersApplicationData;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_CurrentUserApplicationData = My.Computer.FileSystem.SpecialDirectories.CurrentUserApplicationData;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_Desktop = My.Computer.FileSystem.SpecialDirectories.Desktop;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_MyDocuments = My.Computer.FileSystem.SpecialDirectories.MyDocuments;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_MyMusic = My.Computer.FileSystem.SpecialDirectories.MyMusic;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_MyPictures = My.Computer.FileSystem.SpecialDirectories.MyPictures;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_ProgramFiles = My.Computer.FileSystem.SpecialDirectories.ProgramFiles;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_Programs = My.Computer.FileSystem.SpecialDirectories.Programs;
            MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_Temp = My.Computer.FileSystem.SpecialDirectories.Temp;
            MyUniverse.MySystem.USER.Info_AvailablePhysicalMemory = My.Computer.Info.AvailablePhysicalMemory.ToString;
            MyUniverse.MySystem.USER.Info_AvailableVirtualMemory = My.Computer.Info.AvailableVirtualMemory.ToString;
            MyUniverse.MySystem.USER.Info_OSFullName = My.Computer.Info.OSFullName;
            MyUniverse.MySystem.USER.Info_OSPlatform = My.Computer.Info.OSPlatform;
            MyUniverse.MySystem.USER.Info_OSVersion = My.Computer.Info.OSVersion;
            MyUniverse.MySystem.USER.Info_TotalPhysicalMemory = My.Computer.Info.TotalPhysicalMemory.ToString;
            MyUniverse.MySystem.USER.Info_TotalVirtualMemory = My.Computer.Info.TotalVirtualMemory.ToString;
            MyUniverse.MySystem.USER.Mouse_WheelScrollLines = My.Computer.Mouse.WheelScrollLines.ToString;
            MyUniverse.MySystem.USER.Mouse_WheelExists = My.Computer.Mouse.WheelExists.ToString;
            MyUniverse.MySystem.USER.Name = My.Computer.Name;
            MyUniverse.MySystem.USER.Network_GetType_FullName = My.Computer.Network.GetType.FullName;
            MyUniverse.MySystem.USER.Network_GetType_MemberType = My.Computer.Network.GetType.MemberType.ToString;
            MyUniverse.MySystem.USER.Network_GetType_Namespace = My.Computer.Network.GetType.Namespace;
            MyUniverse.MySystem.USER.Registry_CurrentUser_Name = My.Computer.Registry.CurrentUser.Name;
            MyUniverse.MySystem.USER.Registry_LocalMachine_Name = My.Computer.Registry.LocalMachine.Name;
            MyUniverse.MySystem.USER.Registry_PerformanceData_Name = My.Computer.Registry.PerformanceData.Name;
            MyUniverse.MySystem.USER.User_Name = My.Computer.Registry.Users.Name;
            MyUniverse.MySystem.USER.Screen_DeviceName = My.Computer.Screen.DeviceName;
            MyUniverse.MySystem.USER.Screen_BitsPerPixel = My.Computer.Screen.BitsPerPixel.ToString;
            MyUniverse.MySystem.USER.Screen_Bounds_Size_Width = My.Computer.Screen.Bounds.Size.Width.ToString;
            MyUniverse.MySystem.USER.Screen_Bounds_Size_Height = My.Computer.Screen.Bounds.Size.Height.ToString;
            MyUniverse.MySystem.USER.Screen_WorkingArea_Width = My.Computer.Screen.WorkingArea.Width.ToString;
            MyUniverse.MySystem.USER.Screen_WorkingArea_Height = My.Computer.Screen.WorkingArea.Height.ToString;
            MyUniverse.MySystem.USER.CurrentPrincipal_Identity_Name = My.User.CurrentPrincipal.Identity.Name;
            MyUniverse.MySystem.USER.CurrentPrincipal_Identity_GetType_FullName = My.User.CurrentPrincipal.Identity.GetType.FullName;
            MyUniverse.MySystem.USER.CurrentPrincipal_Identity_GetType_GUID = My.User.CurrentPrincipal.Identity.GetType.GUID.ToString;
            MyUniverse.MySystem.USER.User_Name = My.User.Name;
            MyUniverse.MySystem.USER.WebServices_GetType_GUID = My.WebServices.GetType.GUID.ToString;
            MyUniverse.MySystem.USER.WebServices_GetType_Assembly_FullName = My.WebServices.GetType.Assembly.FullName;
            MyUniverse.MySystem.USER.WebServices_GetType_Assembly_Location = My.WebServices.GetType.Assembly.Location;
            MyUniverse.MySystem.USER.WebServices_GetType_AssemblyQualifiedName = My.WebServices.GetType.AssemblyQualifiedName;
            MyUniverse.MySystem.USER.WebServices_GetType_Name = My.WebServices.GetType.Name;
            MyUniverse.MySystem.USER.WebServices_GetType_Namespace = My.WebServices.GetType.Namespace;
            MyUniverse.MySystem.USER.WebServices_GetType_UnderlyingSystemType_FullName = My.WebServices.GetType.UnderlyingSystemType.FullName;



            MyUniverse.MySystem.Dumps.OutputFileName1 = Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory & "\\Dump1.txt";
            MyUniverse.MySystem.Dumps.OutputFileName2 = Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory & "\\Dump2.txt";
            MyUniverse.MySystem.Dumps.OutputFileName3 = Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory & "\\Dump3.txt";


            TempCode = MyUniverse.MySystem.Dumps.OutputFileName1 == Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory & "\\Dump1.txt";
            if (FileSystem.Dir(TempCode) != "")
                FileSystem.Kill(TempCode);
            TempCode = MyUniverse.MySystem.Dumps.OutputFileName1 == Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory & "\\Dump2.txt";
            if (FileSystem.Dir(TempCode) != "")
                FileSystem.Kill(TempCode);
            TempCode = MyUniverse.MySystem.Dumps.OutputFileName1 == Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory & "\\Dump3.txt";
            if (FileSystem.Dir(TempCode) != "")
                FileSystem.Kill(TempCode);



            MyUniverse.Security = SetSecurityOption();
            if (SecurityOption(1) != 1)
            {
                Interaction.MsgBox("Invalid key " + MyUniverse.Security + " " + MyUniverse.MySS.Temps.Templong);
                Application.ExitThread();
            }

            TempCode = CPUID();
            SplashScreen.Visible = true;

            SplashScreen.LabelExpireDate.Text = "test expires in " + DateTime.DateDiff(Microsoft.VisualBasic.DateInterval.Day, DateTime.Today(), (DateTime)"12/31/2021") + " days...";
            DisplayMyStatus(SplashScreen.LabelExpireDate.Text);
            MyDoEvents();
            DisplayMyStatus(SplashScreen.LabelExpireDate.Text);
            MyDoEvents();
            MyDoEvents();
            DisplayMyStatus(SplashScreen.LabelExpireDate.Text);
            MyDoEvents();
            MyUniverse.MySS.Inputs.LineNumberIn = 1; // The number of lines input (starts at one, and goes up evertime another line is enteres (from files, or textbox)
            MyUniverse.ProgramOptions.SelectedColor = "Black";
            MyUniverse.ProgramOptions.SelectedDataType = "Logic";
            MyUniverse.ProgramOptions.SelectedInputOutput = "Both";
            MyUniverse.ProgramOptions.SelectedRotation = "Default";
            MyUniverse.ProgramOptions.SelectedSymbolName = "Start";


            MyUniverse.ProgramOptions.SelectedPathStart = "Flat";
            MyUniverse.ProgramOptions.SelectedPathEnd = "Flat";
            MyUniverse.ProgramOptions.SelectedPathLineStyle = "Solid";
            MyUniverse.ProgramOptions.SelectedNumberOfBytes = "4";



            MyUniverse.MySystem.FlowChartOptions = new SymbolOptionsStructure[11];
            MyUniverse.MySystem.FlowChartOptions[0].OptionNames = "Symbol option 0";
            MyUniverse.MySystem.FlowChartOptions[1].OptionNames = "Symbol option 1";
            MyUniverse.MySystem.FlowChartOptions[2].OptionNames = "Symbol option 2";
            MyUniverse.MySystem.FlowChartOptions[3].OptionNames = "Symbol option 3";
            MyUniverse.MySystem.FlowChartOptions[4].OptionNames = "Symbol option 4";
            MyUniverse.MySystem.FlowChartOptions[5].OptionNames = "Symbol option 5";
            MyUniverse.MySystem.FlowChartOptions[6].OptionNames = "Symbol option 6";
            MyUniverse.MySystem.FlowChartOptions[7].OptionNames = "Symbol option 7";
            MyUniverse.MySystem.FlowChartOptions[8].OptionNames = "Symbol option 8";
            MyUniverse.MySystem.FlowChartOptions[9].OptionNames = "Symbol option 9";
            MyUniverse.MySystem.FlowChartOptions[10].OptionNames = "Symbol option 10";

            MyUniverse.ProgramOptions.SymbolChanged = false;
            MyUniverse.MySystem.USER.MyCurrentDirectory = Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory; // Where you are at.
            MyUniverse.ProgramOptions.Helpurl = "FILE:\\" & MyUniverse.MySystem.USER.MyCurrentDirectory & "\\FlowChartHelpFiles\\FlowChartHelp011.html";

                MyUniverse.SysGen.FindingMyBugsFlag = false;

            MyUniverse.SysGen.Constants.RMStart = "{[(";
            MyUniverse.SysGen.Constants.RMEnd = ")]}";


            CheckThisC_L_();


            MyUniverse.SysGen.Constants.ConstantQuote = " " + Strings.Chr(34) + " "; // Put white space around quotes 2020 08 20
            MyUniverse.SysGen.Constants.ConstantQuotes = MyUniverse.SysGen.Constants.RMStart + "quote" + MyUniverse.SysGen.Constants.RMEnd; // <"">
            MyUniverse.SysGen.Constants.ConstantVariable = MyUniverse.SysGen.Constants.RMStart + "Variable" + MyUniverse.SysGen.Constants.RMEnd;
            MyUniverse.SysGen.Constants.ConstantNumber = MyUniverse.SysGen.Constants.RMStart + "Number" + MyUniverse.SysGen.Constants.RMEnd;
            MyUniverse.SysGen.Constants.ConstantAlpha = MyUniverse.SysGen.Constants.RMStart + "Alpha" + MyUniverse.SysGen.Constants.RMEnd;
            MyUniverse.SysGen.Constants.ConstantSpecialCharacter = MyUniverse.SysGen.Constants.RMStart + "Special" + MyUniverse.SysGen.Constants.RMEnd;
            MyUniverse.SysGen.Constants.ConstantComment = MyUniverse.SysGen.Constants.RMStart + "Comment" + MyUniverse.SysGen.Constants.RMEnd;

            MyUniverse.SysGen.Constants.constantSymbolCenter = 250;  // this defines the max distance from 0,0 of the symbol (-250 to 250) byt the symbol is actually 0-500
            MyUniverse.SysGen.Constants.constantSpacingFactor = 120; // 20 ' number of symbols down before going over another row

            MyUniverse.SysGen.Constants.constantMinPenSize = 9;
            MyUniverse.SysGen.Constants.constantMaxPenSize = 25;

            MyUniverse.SysGen.Constants.constantMinBoxSize = 100;
            MyUniverse.SysGen.Constants.constantFirstLineTextOffset = 50;
            MyUniverse.SysGen.Constants.constantSecondLineTextOffset = 100;
            MyUniverse.SysGen.Constants.constantDistanceBetweenControls = 5;
            MyUniverse.SysGen.Constants.constantRecordsBeforeSaveIsAllowed = 0;
            MyUniverse.SysGen.Constants.constantDistanceToMovePaths = 101;
            MyUniverse.SysGen.Constants.ConstantSpecialCharacters = "`~!@#$%^&*()_-+={[}]|\:;, '<,>.?/" + Strings.Chr(34);
            MyUniverse.SysGen.Constants.ConstantWhiteSpace = " " + Constants.vbLf + Constants.vbCr + Strings.Chr(9) + Constants.vbVerticalTab + Constants.vbFormFeed + Constants.vbCrLf;
            MyUniverse.SysGen.Constants.ConstantDelimeters = MyUniverse.SysGen.Constants.ConstantWhiteSpace + FD + ",="; // White Space



            // Load the options here
            for (I = 1; I <= 32; I++)
                OptionScreen.CheckedListBoxOptionSelection.Items.Add(Conversion.Str(I), CheckState.Unchecked);


            I = 0; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "   Check List"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 1; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "1  Display Path Name"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 2; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "2  Display Symbol Name"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 3; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "3  Display ID Stroke"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 4; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "4  Display File Name"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 5; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "5  Display Notes"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 6; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "6  Display OpCode"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 7; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "7  Display Code"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 8; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "8  Display Index Short Cut Pointer"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 9; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "9  Display ErrorText"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 10; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "10 Display InputOutPut"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 11; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "11 Display Errors"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 12; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "12 Display PathNames"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 13; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "13 Display Constants"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 14; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "14 Make Paths Orthogonal"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 15; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "15 Move Symbols from on top of each other"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 16; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "16 Output Line Numbers"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 17; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "17 Display Data Value on Paths"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 18; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "18 Disable ClipBoard Processor"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 19; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "19 Auto Route"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 20; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "20 Display Point data type"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 21; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "21 Display Symbol Name"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 22; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "22 Expanded Export"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 23; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "23 Use hand to scroll"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
            I = 24; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "24 Number Points"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 25; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "25 Reserved 25"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            // todo need to turn these off before release version (For debugging only
            I = 26; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "26 Stop Display debug "; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 27; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "27 Dump Status"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 28; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "28 Dump Messages"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 29; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "29 Dump errors"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 30; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "30 Dump Bugs"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);
            I = 31; OptionScreen.CheckedListBoxOptionSelection.Items(I) = "31 internal Testing"; OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Unchecked);


            MyUniverse.SysGen.NumberOfButtonsActive = 1; // Init causes it to reset
            // MyTrace(31, "Init", 2241 - 1483)

            GetMyPen = Pens.Black;
            // Make sure all of te forms are loaded. 
            // flow10' Can I not do this yet?            ShowAllForms(ShowScreen1, ShowScreen1, ShowScreen1, ShowScreen1, ShowScreen1, ShowScreen1)
            // flow10' can I not do this yet?            ShowAllForms(HideScreen1, HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1)
            // Need to remove the second parameter and replace it with the actual location when it is found(Looked for)
            OptionScreen.ListBoxLanguage.Items.Clear();
            OptionScreen.ListBoxDialect.Items.Clear();
            MakeListOfLanguagesClassesFromFiles(MyUniverse.MySystem.USER.DirectoryPath1 & "\\Languages", MyUniverse.MySystem.USER.DirectoryPath1 & "\Languages");

            // FindingMyBugs(100)

            MyDoEvents();


            DrillDown_FileName = "*";
            // 
            My_keyWord[My_KeyConstUnknown] = "/unknown";
            My_keyWord[My_KeyConstName] = "/name";            // symbol
            My_keyWord[My_KeyConstPoint] = "/point";           // symbol
            My_keyWord[My_KeyConstLine] = "/line";            // symbol
            My_keyWord[My_KeyConstUse] = "/use";             // FlowChart
            My_keyWord[My_KeyConstPath] = "/path";            // FlowChart
            My_keyWord[My_KeyConstDataType] = "/datatype";        // 
            My_keyWord[My_KeyConstFileName] = "/filename";        // symbol
            My_keyWord[My_KeyConstVersion] = "/version";         // symbol
            My_keyWord[My_KeyConstAuthor] = "/author";          // symbol
            My_keyWord[My_KeyConstLanguage] = "/language";        // 
            My_keyWord[My_KeyConstStroke] = "/stroke";         // symbol
            My_keyWord[My_KeyConstError] = "/error";           // FlowChart
            My_keyWord[My_KeyConstDelete] = "/delete";          // FlowChart
            My_keyWord[My_KeyConstConstant] = "/constant"; // FlowChart
            My_keyWord[My_KeyConstX1] = "/x1"; // not required
            My_keyWord[My_KeyConstY1] = "/y1"; // not required
            My_keyWord[My_KeyConstX2] = "/x2"; // not required
            My_keyWord[My_KeyConstY2] = "/y2"; // not required
            My_keyWord[My_KeyConstColor] = "/color"; // 
            My_keyWord[My_KeyConstNotes] = "/notes"; // symbol
            My_keyWord[My_KeyConstOpcode] = "/opcode"; // symbol
            My_keyWord[My_KeyConstThisCode] = "/thiscode";
            My_keyWord[My_KeyConstOption] = "/option";
            My_keyWord[My_KeyConstLanguageKeyWord] = "/keyword";
            My_keyWord[My_KeyConstmicrocodetext] = "/microcodetext"; // symbol
            // My_keyWord(My_KeyConstUnused29) = "/unknown_29" 'Future
            // My_keyWord(My_KeyConstUnused30) = "/unknown_30" 'Future
            // My_keyWord(My_KeyConstUnused31) = "/unknown_31" 'Future
            // My_keyWord(My_KeyConstUnused32) = "/unknown_32" 'Future

            // FindingMyBugs(100)

            DoOption(51, "on", "");

            MyUniverse.MyCheatSheet.ColorsSorted = 0; // Flagged as nothing to sort.
            MyUniverse.MyCheatSheet.DataTypeSorted = 0;
            MyUniverse.MyCheatSheet.NamedSorted = 0;
            MyUniverse.MyCheatSheet.FlowChartSorted = 0;

            MyAddErrorMessages();
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("Both, 3");              // bit one, two
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("Input, 1");             // bit one
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("All, 0");
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("OptionalBoth, 7");      // bit 1,2,3
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("OptionalInput, 5");     // bit 1,3
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("OptionalOutput, 6");    // bit 1,2
            SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Add("Output, 2");            // bit 2

            // SupportTables (Unchangable)
            SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Clear();
            SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Add("Dash, 1");
            SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Add("DashDot, 3");
            SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Add("DashDotDot, 4");
            SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Add("Dot, 2");
            SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Add("Solid, 0");

            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Clear();
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("AnchorMask, 240");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("ArrowAnchor, 20");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("DiamondAnchor, 19");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("Flat, 0");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("NoAnchor, 16");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("Round, 2");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("RoundAnchor, 18");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("Square, 1");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("SquareAnchor, 17");
            SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Add("Triangle, 3");

            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Clear();
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("AnchorMask, 240");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("ArrowAnchor, 20");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("DiamondAnchor, 19");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("Flat, 0");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("NoAnchor, 16");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("Round, 2");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("RoundAnchor, 18");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("Square, 1");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("SquareAnchor, 17");
            SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Add("Triangle, 3");


            // todo make this into an internal list, and then only select and display the rotation names
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Clear();
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("Default"); SaveRotation(0, "1 , 0 , 0 , 1, ^. Flips to  ^. Stays the same ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("Flip"); SaveRotation(1, "-1, 0, 0, 1, ^ .Flips To  v. sideways flip ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("Flop"); SaveRotation(2, "1, 0, 0, -1, ^ .Flips To  v. top side flips down ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("Rotate90"); SaveRotation(3, "0, 1, -1, 0, ^ .Flips To  > rotate 90 degrees period On bottom");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("Rotate180"); SaveRotation(4, "-1, 0, 0, -1, ^ .Flips To  .v rotate 180");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("Rotate270"); SaveRotation(5, "0, -1, 1, 0, ^ .Flips To  <rotate 270 ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add(" FlipRotate90"); SaveRotation(6, "0, -1, 1, 0, ^ .Flips To  > period On top flip Then rotate 90 ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("FlipRotate180"); SaveRotation(7, "1, 0, 0, -1, ^ .Flips To  v. flip Then rotate 180 (mirror image Of) ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("FlipRotate270"); SaveRotation(8, "0 , -1 , -1 , 0, ^. Flips To  <Period On bottom ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add(" FlopRotate90"); SaveRotation(9, "0 , -1 , -1 , 0, ^. Flips To  > period On bottom Same As ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("FlopRotate180"); SaveRotation(10, "-1 , 0 , 0 , 1, ^. Flips To  .^ same As flip rotate180 ");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("FlopRotate270"); SaveRotation(11, "0 , 1 , 1 , 0, ^. Flips To  ^. period On top");
            SymbolScreen.ToolStripDropDownRotation.DropDownItems.Add("FlipFlop"); SaveRotation(12, "0 , -1 , -1 , 0, ^. Flips To  ^. same As rotate180 ");

            // FindingMyBugs(100)


            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Clear();
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("0");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("16");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("32");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("64");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("128");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("256");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("512");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1024");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2048");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4096");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8192");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("16384");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("32768");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("65536");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("131072");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("262144");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("524288");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1048576");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2097152");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4194304");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8388608");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("16777216");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("33554432");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("67108864");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("134217728");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("268435456");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("536870912");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("1073741824");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("2147483648");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("4294967296");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("8589934592");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("17179869184");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("17179869184");
            SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Add("34359738378");




            SymbolScreen.ToolStripDropDownLineWidth.DropDownItems.Clear();
            for (II = 0; II <= 50; II++)
                SymbolScreen.ToolStripDropDownLineWidth.DropDownItems.Add(Conversion.Str(II));

            // FindingMyBugs(100)

            // original changed for testing.
            D = 0; MyDirections[D, 1, 1] = -10; MyDirections[D, 1, 2] = -10; MyDirections[D, 2, 1] = 10; MyDirections[D, 2, 2] = 10; // No Direction
            D = 1; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = -10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10; // -10  '
            D = 2; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = -10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // NorthEast

            D = 3; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = 10; MyDirections[D, 2, 2] = -10; // 
            D = 4; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = 10; MyDirections[D, 2, 2] = -10; // Right
            D = 5; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = 10; MyDirections[D, 2, 2] = -10; // 

            D = 6; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = 10;  // 
            D = 7; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = 10;  // 
            D = 8; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = 10;  // Bottom
            D = 9; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = 10;  // 
            D = 10; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = 10;  // 

            D = 11; MyDirections[D, 1, 1] = -10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // 
            D = 12; MyDirections[D, 1, 1] = -10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // Left
            D = 13; MyDirections[D, 1, 1] = -10; MyDirections[D, 1, 2] = 10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // 

            D = 14; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = -10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // 
            D = 15; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = -10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // 
            D = 16; MyDirections[D, 1, 1] = 10; MyDirections[D, 1, 2] = -10; MyDirections[D, 2, 1] = -10; MyDirections[D, 2, 2] = -10;  // Top


            // MyUniverse.SysGen.MySnap = 50 'It's fixed for now, but should be an option
            MyUniverse.SysGen.Snaps.MySnap = 1; // lines on the symbol
            MyUniverse.SysGen.Snaps.MyPointSnap = 50; // paths And points
            MyUniverse.SysGen.Snaps.MySymbolSnap = 2000; // symbol placement On the flowchart

            MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = true;

            FindingMyBugs(100);

            // almost a constant
            ZeroZero.Xx = 0;
            ZeroZero.Yy = 0;
            SetNameOfPoint(ref ZeroZero, "", "", "");
            ZeroZeroZeroZero = MyLine1(ZeroZero, ZeroZero);

            MyUniverse.SysGen.HighestSymbolNumber = 100;
            // Popvalue(Mid(TimeString, 7, 2) & Mid(TimeString, 4, 2) & Mid(TimeString, 1, 2))

            MyUniverse.SysGen.MinBox = MyUniverse.SysGen.Constants.constantMinBoxSize;
            MyUniverse.SysGen.MyFlowChartScale = ConstantMinFLowChartScale * 8; // 1=1,1/2=.5,1/4=.25,1/8=.125,1/16=.0625    1/32=.03125,1/64=.015625,1/126=.0078125
            // todo make this so that it will also beable to scroll on the symbol screen, other wise it has to stay at one.
            // Or limited to a scale that is smaller than the size of the screen (height when maximized)
            MyUniverse.SysGen.MySymbolScale = 1.0; // fixed and never changes?
            LimitScale();
            MyUniverse.SysGen.Size.Xx = 1000;
            MyUniverse.SysGen.Size.Yy = 1000;
            SetNameOfPoint(ref MyUniverse.SysGen.Size, "", "", "");

            SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Clear();
            // Known Colors right now. (Can/Should be added to with Alpha/Red/Green/Blue (Later))
            ImportColors("AliceBlue" + FD + "255" + FD + "240" + FD + "248" + FD + "255" + FD + "DashDotDot" + FD + "Triangle" + FD + "RoundAnchor");
            ImportColors("AntiqueWhite" + FD + "255" + FD + "250" + FD + "235" + FD + "215" + FD + "DashDot" + FD + "RoundAnchor" + FD + "ArrowAnchor");
            ImportColors("aqua" + FD + "255" + FD + "1" + FD + "255" + FD + "255" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("aquamarine" + FD + "255" + FD + "127" + FD + "255" + FD + "212" + FD + "DashDotDot" + FD + "Round" + FD + "NoAnchor");
            ImportColors("Azure" + FD + "255" + FD + "240" + FD + "255" + FD + "255" + FD + "DashDot" + FD + "flat" + FD + "NoAnchor");
            ImportColors("beige" + FD + "255" + FD + "245" + FD + "245" + FD + "220" + FD + "Dot" + FD + "flat" + FD + "Square");
            ImportColors("bisque" + FD + "255" + FD + "255" + FD + "228" + FD + "196" + FD + "DashDotDot" + FD + "DiamondAnchor" + FD + "SquareAnchor");
            ImportColors("Black" + FD + "255" + FD + "1" + FD + "1" + FD + "1" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("BlanchedAlmond" + FD + "255" + FD + "255" + FD + "235" + FD + "205" + FD + "Dash" + FD + "DiamondAnchor" + FD + "Triangle");
            ImportColors("Blue" + FD + "255" + FD + "1" + FD + "1" + FD + "255" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("BlueViolet" + FD + "255" + FD + "138" + FD + "43" + FD + "226" + FD + "DashDotDot" + FD + "Triangle" + FD + "SquareAnchor");
            ImportColors("Brown" + FD + "255" + FD + "165" + FD + "42" + FD + "42" + FD + "Dash" + FD + "NoAnchor" + FD + "flat");
            ImportColors("BurlyWood" + FD + "255" + FD + "222" + FD + "184" + FD + "135" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "NoAnchor");
            ImportColors("CadetBlue" + FD + "255" + FD + "95" + FD + "158" + FD + "160" + FD + "DashDot" + FD + "NoAnchor" + FD + "flat");
            ImportColors("Chartreuse" + FD + "255" + FD + "127" + FD + "255" + FD + "1" + FD + "Dash" + FD + "DiamondAnchor" + FD + "Round");
            ImportColors("Chocolate" + FD + "255" + FD + "210" + FD + "105" + FD + "30" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "Square");
            ImportColors("Coral" + FD + "255" + FD + "255" + FD + "127" + FD + "80" + FD + "DashDot" + FD + "NoAnchor" + FD + "flat");
            ImportColors("CornflowerBlue" + FD + "255" + FD + "100" + FD + "149" + FD + "237" + FD + "Dot" + FD + "RoundAnchor" + FD + "SquareAnchor");
            ImportColors("Cornsilk" + FD + "255" + FD + "255" + FD + "248" + FD + "220" + FD + "DashDotDot" + FD + "RoundAnchor" + FD + "NoAnchor");
            ImportColors("Crimson" + FD + "255" + FD + "220" + FD + "20" + FD + "60" + FD + "DashDot" + FD + "Round" + FD + "NoAnchor");
            ImportColors("Cyan" + FD + "255" + FD + "1" + FD + "255" + FD + "255" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("DarkBlue" + FD + "255" + FD + "1" + FD + "1" + FD + "139" + FD + "Dot" + FD + "flat" + FD + "SquareAnchor");
            ImportColors("DarkCyan" + FD + "255" + FD + "1" + FD + "139" + FD + "139" + FD + "DashDotDot" + FD + "Round" + FD + "flat");
            ImportColors("DarkGoldenrod" + FD + "255" + FD + "184" + FD + "134" + FD + "11" + FD + "DashDot" + FD + "Square" + FD + "NoAnchor");
            ImportColors("DarkGray" + FD + "255" + FD + "169" + FD + "169" + FD + "169" + FD + "Dash" + FD + "Square" + FD + "flat");
            ImportColors("DarkGreen" + FD + "255" + FD + "1" + FD + "100" + FD + "1" + FD + "Dot" + FD + "Triangle" + FD + "NoAnchor");
            ImportColors("DarkKhaki" + FD + "255" + FD + "189" + FD + "183" + FD + "107" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "SquareAnchor");
            ImportColors("DarkMagenta" + FD + "255" + FD + "139" + FD + "1" + FD + "139" + FD + "DashDot" + FD + "RoundAnchor" + FD + "DiamondAnchor");
            ImportColors("DarkOliveGreen" + FD + "255" + FD + "85" + FD + "107" + FD + "47" + FD + "Dash" + FD + "DiamondAnchor" + FD + "RoundAnchor");
            ImportColors("DarkOrange" + FD + "255" + FD + "255" + FD + "140" + FD + "1" + FD + "Dot" + FD + "Triangle" + FD + "RoundAnchor");
            ImportColors("DarkOrchid" + FD + "255" + FD + "153" + FD + "50" + FD + "204" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "Round");
            ImportColors("DarkRed" + FD + "255" + FD + "139" + FD + "1" + FD + "1" + FD + "DashDot" + FD + "DiamondAnchor" + FD + "Round");
            ImportColors("DarkSalmon" + FD + "255" + FD + "233" + FD + "150" + FD + "122" + FD + "Dot" + FD + "Square" + FD + "Square");
            ImportColors("DarkSeaGreen" + FD + "255" + FD + "143" + FD + "188" + FD + "139" + FD + "DashDotDot" + FD + "flat" + FD + "SquareAnchor");
            ImportColors("DarkSlateBlue" + FD + "255" + FD + "72" + FD + "61" + FD + "139" + FD + "DashDot" + FD + "NoAnchor" + FD + "DiamondAnchor");
            ImportColors("DarkSlateGray" + FD + "255" + FD + "47" + FD + "79" + FD + "79" + FD + "Dash" + FD + "Square" + FD + "Triangle");
            ImportColors("DarkTurquoise" + FD + "255" + FD + "1" + FD + "206" + FD + "209" + FD + "Dot" + FD + "Square" + FD + "Square");
            ImportColors("DarkViolet" + FD + "255" + FD + "148" + FD + "1" + FD + "211" + FD + "DashDotDot" + FD + "Triangle" + FD + "DiamondAnchor");
            // ImportColors(DataTypeError" & FD & "255" & FD & "255" & FD & "1" & FD & "1" & FD & "DashDotDot" & FD & "Triangle" & FD & "DiamondAnchor)
            ImportColors("DeepPink" + FD + "255" + FD + "255" + FD + "20" + FD + "147" + FD + "DashDot" + FD + "Square" + FD + "flat");
            ImportColors("DeepSkyBlue" + FD + "255" + FD + "1" + FD + "191" + FD + "255" + FD + "Dash" + FD + "NoAnchor" + FD + "flat");
            ImportColors("DimGray" + FD + "255" + FD + "105" + FD + "105" + FD + "105" + FD + "Dot" + FD + "NoAnchor" + FD + "Square");
            ImportColors("DodgerBlue" + FD + "255" + FD + "30" + FD + "144" + FD + "255" + FD + "DashDotDot" + FD + "Triangle" + FD + "ArrowAnchor");
            ImportColors("Firebrick" + FD + "255" + FD + "178" + FD + "34" + FD + "34" + FD + "DashDot" + FD + "Round" + FD + "Triangle");
            ImportColors("FloralWhite" + FD + "255" + FD + "255" + FD + "250" + FD + "240" + FD + "Dash" + FD + "Triangle" + FD + "flat");
            ImportColors("ForestGreen" + FD + "255" + FD + "34" + FD + "139" + FD + "34" + FD + "Dot" + FD + "NoAnchor" + FD + "Triangle");
            ImportColors("Fuchsia" + FD + "255" + FD + "255" + FD + "1" + FD + "255" + FD + "DashDotDot" + FD + "SquareAnchor" + FD + "Round");
            ImportColors("Gainsboro" + FD + "255" + FD + "220" + FD + "220" + FD + "220" + FD + "Dash" + FD + "Round" + FD + "ArrowAnchor");
            ImportColors("GhostWhite" + FD + "255" + FD + "248" + FD + "248" + FD + "255" + FD + "Dot" + FD + "NoAnchor" + FD + "SquareAnchor");
            ImportColors("Gold" + FD + "255" + FD + "255" + FD + "215" + FD + "1" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Goldenrod" + FD + "255" + FD + "218" + FD + "165" + FD + "32" + FD + "DashDot" + FD + "NoAnchor" + FD + "SquareAnchor");
            ImportColors("Gray" + FD + "255" + FD + "128" + FD + "128" + FD + "128" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Green" + FD + "255" + FD + "1" + FD + "128" + FD + "1" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("GreenYellow" + FD + "255" + FD + "173" + FD + "255" + FD + "47" + FD + "DashDot" + FD + "NoAnchor" + FD + "NoAnchor");
            ImportColors("Honeydew" + FD + "255" + FD + "240" + FD + "255" + FD + "240" + FD + "Dash" + FD + "ArrowAnchor" + FD + "NoAnchor");
            ImportColors("HotPink" + FD + "255" + FD + "255" + FD + "105" + FD + "180" + FD + "Dot" + FD + "SquareAnchor" + FD + "NoAnchor");
            ImportColors("IndianRed" + FD + "255" + FD + "205" + FD + "92" + FD + "92" + FD + "DashDot" + FD + "Triangle" + FD + "NoAnchor");
            ImportColors("Indigo" + FD + "255" + FD + "75" + FD + "1" + FD + "130" + FD + "Dash" + FD + "ArrowAnchor" + FD + "NoAnchor");
            ImportColors("Ivory" + FD + "255" + FD + "255" + FD + "255" + FD + "240" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Khaki" + FD + "255" + FD + "240" + FD + "230" + FD + "140" + FD + "DashDotDot" + FD + "flat" + FD + "Round");
            ImportColors("Lavender" + FD + "255" + FD + "230" + FD + "230" + FD + "250" + FD + "DashDot" + FD + "RoundAnchor" + FD + "SquareAnchor");
            ImportColors("LavenderBlush" + FD + "255" + FD + "255" + FD + "240" + FD + "245" + FD + "Dash" + FD + "RoundAnchor" + FD + "ArrowAnchor");
            ImportColors("LawnGreen" + FD + "255" + FD + "124" + FD + "252" + FD + "1" + FD + "Dot" + FD + "SquareAnchor" + FD + "ArrowAnchor");
            ImportColors("LemonChiffon" + FD + "255" + FD + "255" + FD + "250" + FD + "205" + FD + "DashDot" + FD + "Triangle" + FD + "RoundAnchor");
            ImportColors("LightBlue" + FD + "255" + FD + "173" + FD + "216" + FD + "230" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "flat");
            ImportColors("LightCoral" + FD + "255" + FD + "240" + FD + "128" + FD + "128" + FD + "DashDot" + FD + "flat" + FD + "NoAnchor");
            ImportColors("LightCyan" + FD + "255" + FD + "224" + FD + "255" + FD + "255" + FD + "Dash" + FD + "flat" + FD + "Round");
            ImportColors("LightGoldenrodYellow" + FD + "255" + FD + "250" + FD + "250" + FD + "210" + FD + "Dot" + FD + "Triangle" + FD + "Square");
            ImportColors("LightGray" + FD + "255" + FD + "211" + FD + "211" + FD + "211" + FD + "DashDotDot" + FD + "RoundAnchor" + FD + "Square");
            ImportColors("LightGreen" + FD + "255" + FD + "144" + FD + "238" + FD + "144" + FD + "DashDot" + FD + "Triangle" + FD + "Round");
            ImportColors("LightPink" + FD + "255" + FD + "255" + FD + "182" + FD + "193" + FD + "Dash" + FD + "SquareAnchor" + FD + "NoAnchor");
            ImportColors("LightSalmon" + FD + "255" + FD + "255" + FD + "160" + FD + "122" + FD + "Dot" + FD + "Triangle" + FD + "SquareAnchor");
            ImportColors("LightSeaGreen" + FD + "255" + FD + "32" + FD + "178" + FD + "170" + FD + "DashDotDot" + FD + "ArrowAnchor" + FD + "flat");
            ImportColors("LightSkyBlue" + FD + "255" + FD + "135" + FD + "206" + FD + "250" + FD + "DashDot" + FD + "Triangle" + FD + "NoAnchor");
            ImportColors("LightSlateGray" + FD + "255" + FD + "119" + FD + "136" + FD + "153" + FD + "Dot" + FD + "DiamondAnchor" + FD + "RoundAnchor");
            ImportColors("LightSteelBlue" + FD + "255" + FD + "176" + FD + "196" + FD + "222" + FD + "DashDotDot" + FD + "RoundAnchor" + FD + "SquareAnchor");
            ImportColors("LightYellow" + FD + "255" + FD + "255" + FD + "255" + FD + "224" + FD + "DashDot" + FD + "ArrowAnchor" + FD + "NoAnchor");
            ImportColors("Lime" + FD + "255" + FD + "1" + FD + "255" + FD + "1" + FD + "Dash" + FD + "ArrowAnchor" + FD + "Round");
            ImportColors("LimeGreen" + FD + "255" + FD + "50" + FD + "205" + FD + "50" + FD + "Dot" + FD + "flat" + FD + "Round");
            ImportColors("Linen" + FD + "255" + FD + "250" + FD + "240" + FD + "230" + FD + "DashDotDot" + FD + "Round" + FD + "Triangle");
            // ImportColors(Logic"& FD & "255"& FD & "255"& FD & "255"& FD & "255"& FD & "Solid"& FD & "square"& FD & "square)
            ImportColors("Magenta" + FD + "255" + FD + "255" + FD + "1" + FD + "255" + FD + "DashDot" + FD + "NoAnchor" + FD + "Triangle");
            ImportColors("Maroon" + FD + "255" + FD + "128" + FD + "1" + FD + "1" + FD + "Dot" + FD + "Triangle" + FD + "ArrowAnchor");
            ImportColors("MediumAquamarine" + FD + "255" + FD + "102" + FD + "205" + FD + "170" + FD + "Dash" + FD + "SquareAnchor" + FD + "Square");
            ImportColors("MediumBlue" + FD + "255" + FD + "1" + FD + "1" + FD + "205" + FD + "Dot" + FD + "NoAnchor" + FD + "Round");
            ImportColors("MediumOrchid" + FD + "255" + FD + "186" + FD + "85" + FD + "211" + FD + "DashDotDot" + FD + "ArrowAnchor" + FD + "Round");
            ImportColors("MediumPurple" + FD + "255" + FD + "147" + FD + "112" + FD + "219" + FD + "DashDot" + FD + "Square" + FD + "RoundAnchor");
            ImportColors("MediumSeaGreen" + FD + "255" + FD + "60" + FD + "179" + FD + "113" + FD + "Dash" + FD + "Triangle" + FD + "NoAnchor");
            ImportColors("MediumSlateBlue" + FD + "255" + FD + "123" + FD + "104" + FD + "238" + FD + "Dot" + FD + "SquareAnchor" + FD + "flat");
            ImportColors("MediumSpringGreen" + FD + "255" + FD + "1" + FD + "250" + FD + "154" + FD + "DashDot" + FD + "Triangle" + FD + "Triangle");
            ImportColors("MediumTurquoise" + FD + "255" + FD + "72" + FD + "209" + FD + "204" + FD + "Dash" + FD + "flat" + FD + "Triangle");
            ImportColors("MediumVioletRed" + FD + "255" + FD + "199" + FD + "21" + FD + "133" + FD + "Dot" + FD + "NoAnchor" + FD + "Round");
            ImportColors("MidnightBlue" + FD + "255" + FD + "25" + FD + "25" + FD + "112" + FD + "DashDotDot" + FD + "RoundAnchor" + FD + "Square");
            ImportColors("MintCream" + FD + "255" + FD + "245" + FD + "255" + FD + "250" + FD + "DashDot" + FD + "RoundAnchor" + FD + "DiamondAnchor");
            ImportColors("MistyRose" + FD + "255" + FD + "255" + FD + "228" + FD + "225" + FD + "Dash" + FD + "ArrowAnchor" + FD + "NoAnchor");
            ImportColors("Moccasin" + FD + "255" + FD + "255" + FD + "228" + FD + "181" + FD + "Dot" + FD + "Square" + FD + "DiamondAnchor");
            ImportColors("NavajoWhite" + FD + "255" + FD + "255" + FD + "222" + FD + "173" + FD + "DashDotDot" + FD + "SquareAnchor" + FD + "NoAnchor");
            ImportColors("Navy" + FD + "255" + FD + "1" + FD + "1" + FD + "128" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("OldLace" + FD + "255" + FD + "253" + FD + "245" + FD + "230" + FD + "Dash" + FD + "NoAnchor" + FD + "SquareAnchor");
            ImportColors("Olive" + FD + "255" + FD + "128" + FD + "128" + FD + "1" + FD + "Dot" + FD + "Round" + FD + "DiamondAnchor");
            ImportColors("OliveDrab" + FD + "255" + FD + "107" + FD + "142" + FD + "35" + FD + "DashDot" + FD + "NoAnchor" + FD + "Square");
            ImportColors("Orange" + FD + "255" + FD + "255" + FD + "165" + FD + "1" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("OrangeRed" + FD + "255" + FD + "255" + FD + "69" + FD + "1" + FD + "Dot" + FD + "SquareAnchor" + FD + "NoAnchor");
            ImportColors("Orchid" + FD + "255" + FD + "218" + FD + "112" + FD + "214" + FD + "DashDotDot" + FD + "Round" + FD + "RoundAnchor");
            ImportColors("PaleGoldenrod" + FD + "255" + FD + "238" + FD + "232" + FD + "170" + FD + "Dash" + FD + "SquareAnchor" + FD + "SquareAnchor");
            ImportColors("PaleGreen" + FD + "255" + FD + "152" + FD + "251" + FD + "152" + FD + "Dot" + FD + "RoundAnchor" + FD + "DiamondAnchor");
            ImportColors("PaleTurquoise" + FD + "255" + FD + "175" + FD + "238" + FD + "238" + FD + "DashDotDot" + FD + "SquareAnchor" + FD + "Triangle");
            ImportColors("PaleVioletRed" + FD + "255" + FD + "219" + FD + "112" + FD + "147" + FD + "DashDot" + FD + "ArrowAnchor" + FD + "Square");
            ImportColors("PapayaWhip" + FD + "255" + FD + "255" + FD + "239" + FD + "213" + FD + "Dash" + FD + "ArrowAnchor" + FD + "flat");
            ImportColors("PeachPuff" + FD + "255" + FD + "255" + FD + "218" + FD + "185" + FD + "Dot" + FD + "Triangle" + FD + "Round");
            ImportColors("Peru" + FD + "255" + FD + "205" + FD + "133" + FD + "63" + FD + "DashDotDot" + FD + "Triangle" + FD + "Round");
            ImportColors("Pink" + FD + "255" + FD + "255" + FD + "192" + FD + "203" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Plum" + FD + "255" + FD + "221" + FD + "160" + FD + "221" + FD + "Dash" + FD + "DiamondAnchor" + FD + "Round");
            ImportColors("PowderBlue" + FD + "255" + FD + "176" + FD + "224" + FD + "230" + FD + "DashDotDot" + FD + "Round" + FD + "Square");
            ImportColors("Purple" + FD + "255" + FD + "128" + FD + "1" + FD + "128" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Red" + FD + "255" + FD + "255" + FD + "1" + FD + "1" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("RosyBrown" + FD + "255" + FD + "188" + FD + "143" + FD + "143" + FD + "DashDot" + FD + "SquareAnchor" + FD + "NoAnchor");
            ImportColors("RoyalBlue" + FD + "255" + FD + "65" + FD + "105" + FD + "225" + FD + "Dash" + FD + "SquareAnchor" + FD + "DiamondAnchor");
            ImportColors("SaddleBrown" + FD + "255" + FD + "139" + FD + "69" + FD + "19" + FD + "DashDotDot" + FD + "RoundAnchor" + FD + "Triangle");
            ImportColors("Salmon" + FD + "255" + FD + "250" + FD + "128" + FD + "114" + FD + "DashDot" + FD + "RoundAnchor" + FD + "ArrowAnchor");
            ImportColors("SandyBrown" + FD + "255" + FD + "244" + FD + "164" + FD + "96" + FD + "Dash" + FD + "RoundAnchor" + FD + "Round");
            ImportColors("SeaGreen" + FD + "255" + FD + "46" + FD + "139" + FD + "87" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("SeaShell" + FD + "255" + FD + "255" + FD + "245" + FD + "238" + FD + "DashDotDot" + FD + "Round" + FD + "SquareAnchor");
            ImportColors("Sienna" + FD + "255" + FD + "160" + FD + "82" + FD + "45" + FD + "DashDot" + FD + "DiamondAnchor" + FD + "SquareAnchor");
            ImportColors("Silver" + FD + "255" + FD + "192" + FD + "192" + FD + "192" + FD + "Dash" + FD + "DiamondAnchor" + FD + "NoAnchor");
            ImportColors("SkyBlue" + FD + "255" + FD + "135" + FD + "206" + FD + "235" + FD + "Dot" + FD + "Square" + FD + "NoAnchor");
            ImportColors("SlateBlue" + FD + "255" + FD + "106" + FD + "90" + FD + "205" + FD + "DashDot" + FD + "ArrowAnchor" + FD + "RoundAnchor");
            ImportColors("SlateGray" + FD + "255" + FD + "112" + FD + "128" + FD + "144" + FD + "Dash" + FD + "Triangle" + FD + "Square");
            ImportColors("Snow" + FD + "255" + FD + "255" + FD + "250" + FD + "250" + FD + "Dot" + FD + "flat" + FD + "ArrowAnchor");
            ImportColors("SpringGreen" + FD + "255" + FD + "1" + FD + "255" + FD + "127" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "Triangle");
            ImportColors("SteelBlue" + FD + "255" + FD + "70" + FD + "130" + FD + "180" + FD + "DashDot" + FD + "NoAnchor" + FD + "Triangle");
            ImportColors("Tan" + FD + "255" + FD + "210" + FD + "180" + FD + "140" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Teal" + FD + "255" + FD + "1" + FD + "128" + FD + "128" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Thistle" + FD + "255" + FD + "216" + FD + "191" + FD + "216" + FD + "DashDotDot" + FD + "NoAnchor" + FD + "RoundAnchor");
            ImportColors("Tomato" + FD + "255" + FD + "255" + FD + "99" + FD + "71" + FD + "DashDot" + FD + "Round" + FD + "DiamondAnchor");
            ImportColors("Transparent" + FD + "1" + FD + "1" + FD + "1" + FD + "1" + FD + "Solid" + FD + "NoAnchor" + FD + "NoAnchor");
            ImportColors("Turquoise" + FD + "255" + FD + "64" + FD + "224" + FD + "208" + FD + "Dash" + FD + "ArrowAnchor" + FD + "SquareAnchor");
            ImportColors("Violet" + FD + "255" + FD + "238" + FD + "130" + FD + "238" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("Wheat" + FD + "255" + FD + "245" + FD + "222" + FD + "179" + FD + "DashDotDot" + FD + "SquareAnchor" + FD + "DiamondAnchor");
            ImportColors("White" + FD + "255" + FD + "255" + FD + "255" + FD + "255" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("WhiteSmoke" + FD + "255" + FD + "245" + FD + "245" + FD + "245" + FD + "Dash" + FD + "NoAnchor" + FD + "SquareAnchor");
            ImportColors("Yellow" + FD + "255" + FD + "255" + FD + "255" + FD + "1" + FD + "Solid" + FD + "Round" + FD + "Round");
            ImportColors("YellowGreen" + FD + "255" + FD + "154" + FD + "205" + FD + "50" + FD + "DashDotDot" + FD + "ArrowAnchor" + FD + "flat");


            MyUniverse.ProgramOptions.SelectedColor = "Black";

            SymbolScreen.ToolStripDropDownDataType.DropDownItems.Clear();

            // "/datatype=datatypename" & FD & " Number Of Bytes" & FD & " Color Name" & FD & " Color Width" & FD & " Describtion"
            ImportDataTypes("logic" + FD + "1" + FD + "Black" + FD + "3" + FD + "Logic Path", -94);
            ImportDataTypes("Bit" + FD + "1" + FD + "Blue" + FD + "3" + FD + "A Single On/off", -100);
            // ImportDataTypes("Boolean" & FD & "1" & FD & "Green" & FD & "3" & FD & "A Boolean variable", -99)
            ImportDataTypes("Byte" + FD + "8" + FD + "MistyRose" + FD + "4" + FD + "A Byte (8 bits)", -98);
            ImportDataTypes("Erase" + FD + "1" + FD + "Orange" + FD + "1" + FD + "Logic Path For Errors", -97); // cHANGE THIS BACK TO wHITE
            ImportDataTypes("Floating" + FD + "8" + FD + "DodgerBlue" + FD + "8" + FD + "A floating-point variable WinDef", -96);
            // ImportDataTypes("INT8" & FD & "1" & FD & "Orange" & FD & "2" & FD & "An 8-bit Or 1 Byte signed Integer BaseTsd", -89)
            ImportDataTypes("Int16" + FD + "2" + FD + "Aquamarine" + FD + "2" + FD + "A 16-bit Or 2 bytes signed Integer BaseTsd", -97);
            ImportDataTypes("long" + FD + "4" + FD + "Aqua" + FD + "4" + FD + "A 32-bit Or 4 bytes signed Integer -2147483648 through 2147483647 BaseTsd", -91);
            ImportDataTypes("Int64" + FD + "8" + FD + "Red" + FD + "8" + FD + "A 64-bit Or 8 bytes signed Integer ?+/- 9223372036854775807", -90);
            ImportDataTypes("Int128" + FD + "16" + FD + "MediumOrchid" + FD + "12" + FD + "A 128 bit register ", -95);
            ImportDataTypes("Int256" + FD + "32" + FD + "MediumBlue" + FD + "16" + FD + "A 256 bit register", -95);
            ImportDataTypes("Int512" + FD + "64" + FD + "MediumPurple" + FD + "19" + FD + "A 512 bit register (XMM or YMM)", -95);
            // ImportDataTypes("Integer" & FD & "2" & FD & "Orange" & FD & "2" & FD & "An 16-bit Or 2 Byte signed Integer", -95)
            // ImportDataTypes("Long" & FD & "4" & FD & "CadetBlue" & FD & "4" & FD & "4 bytes  32 bits", -93)
            // ImportDataTypes("LongLong" & FD & "8" & FD & "CornflowerBlue" & FD & "8" & FD & "8bytes  84 bits", -92)
            // ImportDataTypes("Void" & FD & "1" & FD & "Red" & FD & "5" & FD & "Any type WinNT")
            // ImportDataTypes("WINAPI,8" & FD & "ForestGreen" & FD & "10" & FD & "The calling convention For system Function WinDef")
            ImportDataTypes("String" + FD + "512" + FD + "Orange" + FD + "8" + FD + "pointer to string", -92);
            // ImportDataTypes("Word" & FD & "2" & FD & "BlueViolet" & FD & "2" & FD & "2 bytes - 16 Bits", -91)
            ImportDataTypes("Errored" + FD + "1" + FD + "Red" + FD + "1" + FD + "Logic Path For Errors", -97);

            MyUniverse.MySymbolPoints = new MySymbolPointPreference[123]; // Maxium number of points in a 500x500 on grid of 50
            ImportSymbolPointPreference();

            MyUniverse.OptionDisplay = new MyDisplayStructure[33]; // Fixed number of the options disl;aydss
            // I lost what the defauls of this use to be.

            // hack the color of the text is fixed for now, but needs to be be able to change it from the imports (later)

            SetColorOptions(0, "AliceBlue", 300, 0, 250, 50); // Check list (No Used)
            SetColorOptions(1, "IndianRed", 0, -25, 250, 50); // Display Point Names
            SetColorOptions(2, "DarkBlue", 0, -250, 250, 50); // Display Symbol Name
            SetColorOptions(3, "OrangeRed", -250, -225, 250, 50); // Display ID Stroke
            SetColorOptions(4, "ForestGreen", -250, -175, 250, 50); // Display File Name
            SetColorOptions(5, "Gray", 25, 15, 250, 50); // Display Notes
            SetColorOptions(6, "DarkOrchid", -250, -125, 250, 50); // Display OpCode
            SetColorOptions(7, "Blue", 25, 25, 250, 50); // Display Program Code Text
            SetColorOptions(8, "YellowGreen", -250, -225, 250, 50); // Display Short Cut Pointer (Should never use)
            SetColorOptions(9, "Red", -250, 75, 250, 50); // Display Error Text
            SetColorOptions(10, "SaddleBrown", -25, -25, 250, 50); // Display Input Output name type
            SetColorOptions(11, "GreenYellow", +25, -25, 250, 50); // Display Errors
            SetColorOptions(12, "Maroon", 0, -25, 250, 50); // Display Path Names
            SetColorOptions(13, "Black", 0, -25, 250, 50); // Display Constants
            SetColorOptions(14, "Red", 50, 250, 250, 50); // Make Paths Orthogonal(No Used)
            SetColorOptions(15, "Wheat", 50, 200, 250, 50); // Move Symbols from on top of each other (The amount moved each time Times 2)
            SetColorOptions(16, "Red", 50, 150, 250, 50); // Output Line Number (Not used)
            SetColorOptions(17, "RosyBrown", 100, -25, 250, 50); // Display Data Vbalue on Paths (Only after I finish my interrupter)
            SetColorOptions(18, "Red", 50, 50, 250, 50); // 
            SetColorOptions(19, "Red", 50, -50, 250, 50); // 
            SetColorOptions(20, "Red", 50, -100, 250, 50); // 
            SetColorOptions(21, "LawnGreen", 50, -150, 250, 50); // 
            SetColorOptions(22, "Red", 50, -200, 250, 50); // 
            SetColorOptions(23, "Red", 50, -250, 250, 50); // 
            SetColorOptions(24, "Red", 50, 225, 250, 50); // 
            SetColorOptions(25, "Red", 50, 175, 250, 50); // 
            SetColorOptions(26, "Red", 50, 125, 250, 50); // 
            SetColorOptions(27, "Red", 50, 75, 250, 50); // 
            SetColorOptions(28, "Red", 50, 25, 250, 50); // 
            SetColorOptions(29, "Red", 50, -25, 250, 50); // 
            SetColorOptions(30, "Red", 50, -75, 250, 50); // 
            SetColorOptions(31, "Red", 50, -125, 250, 50); // Write warning and errors (not used)
            SetColorOptions(32, "Red", 50, -225, 250, 50); // Debug (mydebug() checking)


            AddAtomsToKeywordOROperatorORFunctionList("Function", MyConstantIgnoreFunctionOperatorkeyWord + "Function", ref Language_Function, FileInputOutputScreen.ProgressBarFunctions);
            AddAtomsToKeywordOROperatorORFunctionList("Function", "remark", ref Language_Function, FileInputOutputScreen.ProgressBarFunctions);
            AddAtomsToKeywordOROperatorORFunctionList("Operator", MyConstantIgnoreFunctionOperatorkeyWord + "Operator", ref Language_Operator, FileInputOutputScreen.ProgressBarOperators);
            AddAtomsToKeywordOROperatorORFunctionList("keyWord", MyConstantIgnoreFunctionOperatorkeyWord + "keyWord", ref Language_KeyWord, FileInputOutputScreen.ProgressBarKeyWords);

            // FindingMyBugs(100)

            SymbolScreen.PictureBox1.Width = MyUniverse.SysGen.Constants.constantSymbolCenter * 2 * System.Convert.Tolong(MyUniverse.SysGen.MySymbolScale);
            SymbolScreen.PictureBox1.Height = MyUniverse.SysGen.Constants.constantSymbolCenter * 2 * System.Convert.Tolong(MyUniverse.SysGen.MySymbolScale);



            MyDebugP.Named.PathName = "None";

            MyUniverse.MyStaticData.MinXY.Xx = FlowChartScreen.PictureBox1.Top;
            MyUniverse.MyStaticData.MaxXY.Xx = FlowChartScreen.PictureBox1.Width;

            MyUniverse.MyStaticData.MinXY.Yy = FlowChartScreen.PictureBox1.Left;
            MyUniverse.MyStaticData.MaxXY.Yy = FlowChartScreen.PictureBox1.Height;

            // Makeing sure that there is at least a start symbol defined for everything

            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownButtonColor, MyUniverse.ProgramOptions.SelectedColor);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownDataType, MyUniverse.ProgramOptions.SelectedDataType);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownInputOutput, MyUniverse.ProgramOptions.SelectedInputOutput);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownRotation, MyUniverse.ProgramOptions.SelectedRotation);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownPathStart, MyUniverse.ProgramOptions.SelectedPathStart);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownPathEnd, MyUniverse.ProgramOptions.SelectedPathEnd);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownPathLineStyle, MyUniverse.ProgramOptions.SelectedPathLineStyle);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownNumberOfBytes, MyUniverse.ProgramOptions.SelectedNumberOfBytes);






            // Address0: CommandLine Goto Address1
            // TempCode = MyUniverse.SysGen.Constants.RMStart & "address0.PathName" & MyUniverse.SysGen.Constants.RMEnd & FD
            // TempCode = TempCode & FD & MyUniverse.SysGen.Constants.RMStart & "CommandLine.PathName" & MyUniverse.SysGen.Constants.RMEnd & FD
            // TempCode = TempCode & FD & " GotoNextLine " & MyUniverse.SysGen.Constants.RMStart & "Address1.PathName" & MyUniverse.SysGen.Constants.RMEnd & FD
            TempCode = "Remark" + AddCameFromLine(Constants.vbCrLf + AddGotoNextLine("main()" + Constants.vbCrLf));

            Idex = AddNewNamedRecord("Start", TempCode, " No OpCode", "Start Of the Program", "Internal", "No Language", "FlowChart Program", "0.1", "ABCDEFGHIJKLMNOP", Convertmicrocodetext2Sintax(ref My_CodeLine_Parsed, TempCode));
            AddNEWSymbolLineRecord("Start", "/name", 0, 0, 0, 0, "Start", 0);
            AddNEWSymbolpointRecord("Start", "/point", 0, 250, "output", "logic", " Address1", 0);
            AddNEWSymbolpointRecord("Start", "/point", 0, -250, "Input", "logic", " Address0", 0);
            // AddNEWSymbolpointRecord("Start", "/point", 200, 200, "output", "string", "CommandLine", 0)
            GetSelfCorrectingIndexes("Start");
            AddNEWSymbolLineRecord("Start", "/line", -200, 100, 200, 100, "Green", 0);
            AddNEWSymbolLineRecord("Start", "/line", 200, 100, 250, 0, "Blue", 0);
            AddNEWSymbolLineRecord("Start", "/line", 250, 0, 200, -100, "Orange", 0);
            AddNEWSymbolLineRecord("Start", "/line", 200, -100, -200, -100, "Red", 0);
            AddNEWSymbolLineRecord("Start", "/line", -200, -100, -250, 0, "Purple", 0);
            AddNEWSymbolLineRecord("Start", "/line", -250, 0, -200, 100, "Green", 0);
            GetSelfCorrectingIndexes("Start");

            ReSortSymbolList();

            ShowSorts("Named", ReSortStringArray("Named", ref Named_FileSintax, ref Named_FileSintax_Isam));
            ShowSorts("Named", ReSortStringArray("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM));
            CheckForAnySortNeeded("Init", 103);



            Idex = AddANewFlowChartRecord();
            // Placed the start at the beggining just to put something into the table/file
            FlowChart_FileCoded[Idex] = System.Convert.ToByte(MyKeyword_2_Byte("/use"));
            FlowChart_FilePathSymbolName[Idex] = "Start";
            // Removed             FlowChart_TableCompiledMacroCodeText(Idex, "Start")

            FlowChart_FileX1[Idex] = 1000; // have to start somewhere, miught as well be here.
            FlowChart_FileY1[Idex] = 1000; // 
            FlowChart_File_X2_Rotation[Idex] = 0;
            FlowChart_File_Y2_Option[Idex] = 0;
            FlowChart_File_DataType[Idex] = ""; // todo find out what I should put in here and belowas the default
            // RemovedFlowChart_FileCompiledMacroCodeText(Idex) = ""

            FlowChart_iSAM_Name[constantALLTables] = Idex;
            FlowChart_iSAM_Name[Idex] = Idex;
            FlowChart_iSAM_X1[Idex] = Idex;
            FlowChart_iSAM_Y1[Idex] = Idex;
            FlowChart_iSAM_X2[Idex] = Idex;
            FlowChart_iSAM_Y2[Idex] = Idex;


            // AddNEWSymbolpointRecord("Start", "/point", 0, 250, "output", "logic", " Address1", 0)
            // AddNEWSymbolpointRecord("Start", "/point", 0, -250, "Input", "logic", " Address0", 0)
            // AddNEWSymbolpointRecord("Start", "/point", 250, 250, "output", "string", "CommandLine", 0)

            AddNEWFlowChartRecordPath("address0", "/path", 1000, 750, 1000, 250, "logic", 0);
            AddNEWFlowChartRecordPath("Address1", "/path", 1000, 1250, 1000, 1500, "logic", 0);
            AddNEWFlowChartRecordPath("CommandLine", "/path", 1200, 1200, 1450, 1450, "string", 0);
            CheckForAnySortNeeded("", 104); // hack
            ShowSorts("FlowChart", ReSortFlowChart(Idex));
            // CheckForAnySortNeeded("", 105) 'hack


            MyPlacement(false); // sets the min's

            ShowAllForms(ShowScreen1, ShowScreen1, ShowScreen1, HideScreen1, HideScreen1, HideScreen1);

            FindingMyBugs(100);

            formatLanguage = "/language= Language Name";
            formatColor = "/Color=ColorName" + FD + " Alpha" + FD + " Red" + FD + " Green" + FD + " Blue" + FD + " Style" + FD + " StartCap" + FD + " EndCap";
            formatDatatype = "/datatype=datatypename" + FD + " Number Of Bytes" + FD + " Color Name" + FD + " Color Width" + FD + " Describtion";
            formatSymbolName = "/Name=Symbol Name" + FD + " options";
            // Need to get the {/...} options from the combobox 
            formatPoint = "/Point = X" + FD + " Y" + FD + " {Input/Output...}" + FD + " Data Type" + FD + " Name";
            formatLine = "/Line=x1" + FD + " y1" + FD + " x2" + FD + " y2" + FD + " Color";
            formatNameOfFile = "/FileName=Device:/Path/FileName.Extension";
            formatStroke = "/Stroke={}";
            formatNotes = "/Notes={}";
            FormatOrder = "/Order=name1,(name2,name3,(name4,name5),name6)...";
            formatVersion = "/Version={}";
            formatAuthor = "/Author={}";
            formatOpcode = "/OpCode={}";
            formatPath = "/Path=Name" + FD + " x1" + FD + " y1" + FD + " x2" + FD + " y2" + FD + " Data type";
            formatUse = "/Use=Name" + FD + " X" + FD + " Y" + FD + " rotation" + FD + " future dynamic options";
            formatConstant = "/Constant=name " + FD + " X" + FD + " Y" + FD + " Value";
            FormatMacroText = "/microcodetext=OrderName, Text " + MyUniverse.SysGen.Constants.RMStart + " replacements" + MyUniverse.SysGen.Constants.RMEnd + " text ...";
            FormatOption = "/Option=number" + FD + "{on or off}";
            FormatError = "/error = Code" + FD + " name" + FD + " x1" + FD + " y1" + FD + " Name " + FD + " {other things maybe}";
            FormatDelete = "/Delete ...";
            FormatThisCode = "/ThisCode added to /path or /constant ";
            FormatLanguage_KeyWord = "/Keyword=ReservedWord  {" + FD + "only one word" + FD + " no spaces allowed currently}";
            FormatLanguage_Function = "/Function=FunctionWord  " + FD + "only one function name no (), {}, [] etc " + FD;
            FormatLanguage_operator = "/Operator=Operator  {" + FD + "only one operator ie: +" + FD + " no space allowed currently}";
            FormatSintaxKeyWord = "/Syntax={keyword" + FD + "special characters" + FD + MyUniverse.SysGen.Constants.RMStart + "variables" + MyUniverse.SysGen.Constants.RMEnd + " for variables " + FD + "quote marks " + FD + " between each one   ect...";
            FormatSet_ = "/set=delimiters," + MyUniverse.SysGen.Constants.RMStart + FD + MyUniverse.SysGen.Constants.RMEnd + "" + Constants.vbCrLf + "/Set=Options,1-32 Turns on this option" + Constants.vbCrLf + "/Set=Scale,625-10000" + Constants.vbCrLf + "/Set=Grids,lines(1-10),PathsPoints(lines,250),Symbols(pathspoints,10000), " + Constants.vbCrLf + "/Set=Dump,Dump1.txt,Dump2.txt,Dump3.txt,dump4.txt" + Constants.vbCrLf + "/Set=points,Index,X,Y" + Constants.vbCrLf + "/Set=text,Index,X,Y";

            // FindingMyBugs(100)

            FileInputOutputScreen.ToolStripButtonFlowChartToSourceCode.ToolTipText = "FlowChart To Source Code";
            FileInputOutputScreen.ToolStripButtonOpenFile.ToolTipText = "Open FlowChart File";
            FileInputOutputScreen.ToolStripButtonSaveFileAs.ToolTipText = "Save File As";
            FileInputOutputScreen.ToolStripButtonShowFlowChart.ToolTipText = "Show FlowChart Screen";
            FileInputOutputScreen.ToolStripButtonSourceCodeToFlowChartCode.ToolTipText = "Decompile Source Code To FlowChart";

            FlowChartScreen.ToolStripButtonAddConstant.ToolTipText = "Add Constant";
            FlowChartScreen.ToolStripButtonAddPath.ToolTipText = "Add Path";
            FlowChartScreen.ToolStripButtonDeleteobject.ToolTipText = "Delete ";
            FlowChartScreen.ToolStripButtonMoveObject.ToolTipText = "Move";
            FlowChartScreen.ToolStripButtonOpenForm.ToolTipText = "File I/O";
            FlowChartScreen.ToolStripButtonOptionForm.ToolTipText = "Show Options Screen";
            FlowChartScreen.ToolStripButtonRedraw.ToolTipText = "Redraw";
            FlowChartScreen.ToolStripButtonSymbolForm.ToolTipText = "Show Symbol Screen";
            FlowChartScreen.ToolStripButtonZoomIn.ToolTipText = "Zoom In";
            FlowChartScreen.ToolStripButtonZoomOut.ToolTipText = "Zoom Out";
            FlowChartScreen.ToolStripDropDownSelectSymbol.ToolTipText = "Select Symbol To Place";


            FindingMyBugs(100);


            SetUpHelpForm(SymbolScreen);
            SetUpHelpcomboBox(SymbolScreen, SymbolScreen.ComboBoxPointNameList, "Input Point name here");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedSymbolName, "Enter a new symbol name here (or change the current symbol to a new name)");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedDescription, "Enter the Description");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedNameOfFile, "Enter the path and file name and .symbol for this symbols location");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedNotes, "Enter any notes about the use of this symbol");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedOpCode, "Enter the machine code (Optional)");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedProgramText, "Enter an example of the text for this symbol.  Which will create the syntax when used.");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedStroke, "This is for the mouse movement to select this symbol");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxNamedSyntax, "This syntax is made when you make any changes to the program example text");
            SetUpHelpTextBox(SymbolScreen, SymbolScreen.TextBoxSymbolVersionAuthor, "Enter this version and author as 0.0.0 programmers or company name (copyright, phone number and so on)");

            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label1, "Label1")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label2, "Label2")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label3, "Label3")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label4, "Label4")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label5, "Label5")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label6, "Label6")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label7, "Label7")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label8, "Label8")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label9, "Label9")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.LabelProgramStatus, "Label10")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label11, "Label11")
            // SetUpHelpLabel(SymbolScreen, SymbolScreen.Label12, "Label12")

            // FindingMyBugs(100)


            SymbolScreen.ToolStripButtonAddLine.ToolTipText = "Add a colored Line";
            SymbolScreen.ToolStripButtonAddPoint.ToolTipText = "Add a named point";
            SymbolScreen.ToolStripButtonDelete.ToolTipText = "Delete A Point/Line";
            SymbolScreen.ToolStripButtonFlowChartForm_FromSymbolScreen.ToolTipText = "Show FlowChart Screen";
            SymbolScreen.ToolStripButtonMove.ToolTipText = "Move Point/Line";
            SymbolScreen.ToolStripButtonNewSymbol.ToolTipText = "Make A New Symbol";
            SymbolScreen.ToolStripButtonOptionForm_FromSymbolScreen.ToolTipText = "Show Options";
            SymbolScreen.ToolStripButtonUpdateSymbol.ToolTipText = "Update the Symbol";
            SymbolScreen.ToolStripDropDownButtonColor.ToolTipText = "Select the Color Of Lines (And DataTypes)";
            SymbolScreen.ToolStripDropDownDataType.ToolTipText = "Select the Data type";
            SymbolScreen.ToolStripDropDownSelectSymbol.ToolTipText = "Select the Symbol";

            SymbolScreen.HelpProviderPictureBox1.SetHelpString(SymbolScreen.PictureBox1, "PictureBox1");
            SymbolScreen.HelpProviderSymbolScreen.SetHelpString(SymbolScreen, "SymbolScreen");

            OptionScreen.ToolStripButtonCheckAllData.ToolTipText = "Check All FlowChart Data";
            OptionScreen.ToolStripButtonDeleteUnusedSymbols.ToolTipText = "Delete all Unused Symbols";
            OptionScreen.ToolStripButtonDump.ToolTipText = "Dump into File ...";
            OptionScreen.ToolStripButtonDeleteUnusedSymbols.ToolTipText = "Remove all unused symbols";
            OptionScreen.ToolStripButtonDeleteErrorMsgs.ToolTipText = "Delete FlowChart rrror messages";
            OptionScreen.ToolStripButtonFlowChartForm_FromOptionScreen.ToolTipText = "Show FlowChart";
            OptionScreen.ToolStripButtonSymbolForm_FromOptionScreen.ToolTipText = "Show Symbol";


            FindingMyBugs(100);


            // 
            // OptionsSetDefaults(SymbolScreen.ToolStripDropDownLineWidth, "1") '


            MyUniverse.ProgramOptions.SelectedColor = "Black";
            MyUniverse.ProgramOptions.SelectedDataType = "logic";
            MyUniverse.ProgramOptions.SelectedInputOutput = "Both";
            MyUniverse.ProgramOptions.SelectedRotation = "Default";
            MyUniverse.ProgramOptions.SelectedSymbolName = "Start";

            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownButtonColor, MyUniverse.ProgramOptions.SelectedColor);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownDataType, MyUniverse.ProgramOptions.SelectedDataType);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownInputOutput, MyUniverse.ProgramOptions.SelectedInputOutput);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownRotation, MyUniverse.ProgramOptions.SelectedRotation);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);
            SelectInToolStripDropDownButton(FlowChartScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);


            MyUniverse.ProgramOptions.SelectedPathStart = "Flat";
            MyUniverse.ProgramOptions.SelectedPathEnd = "Flat";
            MyUniverse.ProgramOptions.SelectedPathLineStyle = "Solid";
            MyUniverse.ProgramOptions.SelectedNumberOfBytes = "4";

            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownPathStart, MyUniverse.ProgramOptions.SelectedPathStart);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownPathEnd, MyUniverse.ProgramOptions.SelectedPathEnd);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownPathLineStyle, MyUniverse.ProgramOptions.SelectedPathLineStyle);
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownNumberOfBytes, MyUniverse.ProgramOptions.SelectedNumberOfBytes);

            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);
            SelectInToolStripDropDownButton(FlowChartScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);

            // FindingMyBugs(100)
            ShowAllForms(HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1, HideScreen1);

            SplashScreen.Visible = false;
            ShowAllForms(HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1, HideScreen1);

            MyFlowChartNameSpace.F_C.ProgramAlive = true;
            ShowAllForms(HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1, HideScreen1);
            DoCommandLineInput(Interaction.Command());
        } // End of INIT()

        void SetColorOptions(long Idex, string ColorName, long X, long Y, long SetWidth, long SetHeight)
        {
            MyGetBrush_static(ColorName);
            MyUniverse.OptionDisplay[Idex].ColorBrush = GetMyBrush;
            MyUniverse.OptionDisplay[Idex].X = X;
            MyUniverse.OptionDisplay[Idex].Y = Y;
            MyUniverse.OptionDisplay[Idex].ColorName = ColorName; // Check list (No Used)
            MyUniverse.OptionDisplay[Idex].Textheight = SetHeight;
            MyUniverse.OptionDisplay[Idex].Textwidth = SetWidth;
        }



        string CheckThisPathName(string PathName, long IndexFlowChart)
        {
            string MyPathName;
            MyPathName = NameOfPointOnly(FlowChart_TablePath_Name(IndexFlowChart));
            PathName = NameOfPointOnly(PathName);
            if (Strings.Len(PathName) == 0)
            {
                if (FlowChart_TableCode(IndexFlowChart) == "/path")
                    PathName = MyPathName;
                else
                    return MakePathName("vNOT_PATH_" + Strings.Left((VBMath.Rnd() * 1000000 + 1000000).ToString(), 7));
                if (Strings.Len(PathName) == 0)
                    PathName = MyPathName;
            }
            if (PathName != MyPathName)
                Abug(820, " Path names do not match", HighLight(PathName) + HighLight(MyPathName), FindIndex_In_TableNetLinks(IndexFlowChart) + ":" + MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)));
            return PathName;
        }

        void CheckThisC_L_()
        {
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_Case))
                MyUniverse.ProgramOptions.C_L_Case = "no";
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_MultiLine))
                MyUniverse.ProgramOptions.C_L_MultiLine = ":";// "ThereIsNoMultiLines" 'default
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_Comment))
                MyUniverse.ProgramOptions.C_L_Comment = Strings.Chr(34).ToString();
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_Extention))
                MyUniverse.ProgramOptions.C_L_Extention = "Source";
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_VarChars))
                MyUniverse.ProgramOptions.C_L_VarChars = "_.";
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_DialectName))
                MyUniverse.ProgramOptions.C_L_DialectName = "Generic";
            if (Information.IsNothing(MyUniverse.SysGen.Constants.ConstantGotoNextLine))
                MyUniverse.SysGen.Constants.ConstantGotoNextLine = "GotoNextLine";
            if (Information.IsNothing(MyUniverse.SysGen.Constants.ConstantCameFromLine))
                MyUniverse.SysGen.Constants.ConstantCameFromLine = "CameFromLine";
            if (Information.IsNothing(MyUniverse.ProgramOptions.C_L_Process))
                MyUniverse.ProgramOptions.C_L_Process = "FCGeneric";
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string MyKeyword2String(long Keyword)
        {
            MyKeyword2String = My_keyWord[Keyword];
        }


        // *************************************************************************
        // Returns the number of the character string
        byte MyKeyword_2_Byte(string Keyword)         // My_keyWord are now always in order, so I need to change this to a binary search (Cause the list can be in the thounsands)
        {
            for (MyKeyword_2_Byte = System.Convert.ToByte(Information.LBound(My_keyWord)); MyKeyword_2_Byte <= System.Convert.ToByte(Information.UBound(My_keyWord)); MyKeyword_2_Byte++)
            {
                if (My_keyWord[MyKeyword_2_Byte] == Strings.Trim(Keyword))
                    return MyKeyword_2_Byte;
            }
            MyKeyword_2_Byte = System.Convert.ToByte(Information.LBound(My_keyWord)); // allways points to unknown?
        }


        // ***********************************************************************
        // Routine Just to let the user know whats going on, more or less
        void DisplayMyStatus(string MyMessage) // puts a status  string into the textbox on all forms
        {
            string X;
            X = MyMessage;
            X = PopLine(ref X);
            // Save updating the screen if it is the same status
            if (X == SplashScreen.LabelExpireDate.Text + " " + FlowChartScreen.LabelProgramStatus.Text)
                return;
            X = SplashScreen.LabelExpireDate.Text + X;
            if (FlowChartScreen.Visible == true)
                FlowChartScreen.LabelProgramStatus.Text = X;
            if (SymbolScreen.Visible == true)
                SymbolScreen.LabelProgramStatus.Text = X;
            if (OptionScreen.Visible == true)
                OptionScreen.LabelProgramStatus.Text = X;
            if (FileInputOutputScreen.Visible == true)
                FileInputOutputScreen.LabelProgramStatus.Text = X;
            MyDoEvents(); // To make sure that a message gets updated on the screed.
            // If MyOptionTest(26) = False Then
            System.Diagnostics.Debug.Write(Constants.vbCrLf + DateTime.Now() + CountStack() + " Status:" + HighLight(MyMessage));
            // End If
            Dump3(27, HighLight("Display My Status: " + MyMessage));
        }


        void MyOpen(string DoingWhat)        // Routine This is actuall to open a new file to edit. 
        {
            string MyFileName;
            ShowAllForms(HideScreen1, HideScreen1, HideScreen1, ShowScreen1, ShowScreen1, HideScreen1);

            CheckForAnySortNeeded("", 300);
            switch (Strings.LCase(Strings.Trim(DoingWhat)))
            {
            case "write":
            {
                MyFileName = XOpenFile("write", "Saving the file for this symbol " + DrillDown_FileName + "." + MyUniverse.ProgramOptions.C_L_Extention); // , DrillDown_FileName & "." & MyUniverse.ProgramOptions.C_L_Extention)
                if (MyFileName == null)
                    return;
                Export(MyFileName);
                break;
            }

            case "read":
            {
                MyFileName = XOpenFile("read", "Open the file for this FlowChart " + DrillDown_FileName); // & ".", DrillDownFileName)
                if (MyFileName == null)
                    return;
                Import(MyFileName);
                break;
            }

            default:
            {
                MyMsgCtr(1001, "MyOpen", DoingWhat, DrillDown_FileName, "", "", "", "", "", "", "");
                break;
            }
            }
        }


        // This fills temp MyArrays with a symbols information
        // changed on 20200711
        long GetSelfCorrectingIndexes(string SymbolName)
        {
            long IndexNamed;

            IndexNamed = FindIndexIniSAMTable("Named", "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            if ((IndexNamed == constantMyErrorCode) | (IndexNamed == 0))
                // A I N F O 2 (5)
                return constantMyErrorCode;// This name is not a valid symbol name in the table, so ignore it // we have a valid symbol, that shoul have graphics with it.

            // If there is a short cut then
            // Get the short cut
            GetSelfCorrectingIndexes = Named_TableSymbolIndexes(IndexNamed); // Named_TableSymbolIndexes(SymbolName, IndexNamed)
            if (GetSelfCorrectingIndexes > 0)
            {
                if (Symbol_TableCoded_String(GetSelfCorrectingIndexes) == "/name")
                {
                    if (Symbol_TableSymbolName(GetSelfCorrectingIndexes) == SymbolName)
                        // We have matching names, and it is the start of the symbol graphics with a /name
                        // A I N F O 2 (-6)
                        return GetSelfCorrectingIndexes;// This is a good record // Pointing to the start of the wrong symbol So Fix it
                } // Pointing to something other than the start of the symbol so fix it
            } // We have a valid named symbol, but not graphics (or the graphics point got lost) so fix it

            // IndexNamed is valid
            // but index_symbol is not so we have to fix it  [ by checking every one ]
            // Find the name again to correct
            for (GetSelfCorrectingIndexes = 1; GetSelfCorrectingIndexes <= TopOfFile("Symbol"); GetSelfCorrectingIndexes++)
            {
                if (Symbol_TableCoded_String(GetSelfCorrectingIndexes) == "/name")
                {
                    if (Symbol_TableSymbolName(GetSelfCorrectingIndexes) == SymbolName)
                    {
                        Named_TableSymbolIndexes(IndexNamed, GetSelfCorrectingIndexes); // updating it with a new corfrect Indexes'("Named", IndexNamed, GetSelfCorrectingIndexes) 'updating it with a new corfrect Indexes
                        return GetSelfCorrectingIndexes;
                    } // Pointing to the start of the wrong symbol So Fix it
                } // Pointing to something other than the start of the symbol so fix it
            }
            // This should flag it for future that it has been check and not found. 
            // A I N F O 2 (-7)
            Named_TableSymbolIndexes(IndexNamed, constantMyErrorCode); // an error as it has no symbol graphics, only a name
            GetSelfCorrectingIndexes = constantMyErrorCode;
        }


        string ReplaceWithActuralControlCharacter(string A)
        {
            switch ((Strings.UCase(A)))
            {
            case "CRLF":
            {
                return Strings.Chr(13);
            }

            case "FL_NUL" // (null)"  This should not be allowed
                :
            {
                return Strings.Chr(0);
            }

            case "FL_SOH" // (start of heading)"
                :
            {
                return Strings.Chr(1);
            }

            case "FL_STX" // (start of text)"
                :
            {
                return Strings.Chr(2);
            }

            case "FL_ETX" // (end of text)"
                :
            {
                return Strings.Chr(3);
            }

            case "FL_EOT" // (end of transmission)"
                :
            {
                return Strings.Chr(4);
            }

            case "FL_ENQ" // (enquiry)"
                :
            {
                return Strings.Chr(5);
            }

            case "FL_ACK" // (acknowledge)"
                :
            {
                return Strings.Chr(6);
            }

            case "FL_BEL" // (bell)"
                :
            {
                return Strings.Chr(7);
            }

            case "FL_BS" // (backspace)"
                :
            {
                return Strings.Chr(8);
            }

            case "FL_TAB" // (horizontal tab)"
                :
            {
                return Strings.Chr(9);
            }

            case "FL_LF" // (NL line feed, new line)"
                :
            {
                return Strings.Chr(10);
            }

            case "FL_VT" // (vertical tab)"
                :
            {
                return Strings.Chr(11);
            }

            case "FL_FF" // (NP form feed, new page)"
                :
            {
                return Strings.Chr(12);
            }

            case "FL_CR" // (carriage return)"
                :
            {
                return Strings.Chr(13);
            }

            case "FL_SO" // (shift out)"
                :
            {
                return Strings.Chr(14);
            }

            case "FL_SI" // (shift in)"
                :
            {
                return Strings.Chr(15);
            }

            case "FL_DLE" // (data link escape)"
                :
            {
                return Strings.Chr(16);
            }

            case "FL_DC1" // (device control 1)"
                :
            {
                return Strings.Chr(17);
            }

            case "FL_DC2" // (device control 2)"
                :
            {
                return Strings.Chr(18);
            }

            case "FL_DC3" // (device control 3)"
                :
            {
                return Strings.Chr(19);
            }

            case "FL_DC4" // (device control 4)"
                :
            {
                return Strings.Chr(20);
            }

            case "FL_21 NAK" // (negative acknowledge)"
                :
            {
                return Strings.Chr(21);
            }

            case "FL_SYN" // (synchronous idle)"
                :
            {
                return Strings.Chr(22);
            }

            case "FL_ETB" // (end of trans. block)"
                :
            {
                return Strings.Chr(23);
            }

            case "FL_CAN" // (cancel)"
                :
            {
                return Strings.Chr(24);
            }

            case "FL_EM" // (end of medium)"
                :
            {
                return Strings.Chr(25);
            }

            case "FL_SUB" // (substitute)"
                :
            {
                return Strings.Chr(26);
            }

            case "FL_ESC" // (escape)"
                :
            {
                return Strings.Chr(27);
            }

            case "FL_FS" // (file separator)"
                :
            {
                return Strings.Chr(28);
            }

            case "FL_GS" // (group separator)"
                :
            {
                return Strings.Chr(29);
            }

            case "FL_RS" // (record separator)"
                :
            {
                return Strings.Chr(30);
            }

            case "FL_US" // (unit separator)"
                :
            {
                return Strings.Chr(31);
            }

            default:
            {
                return A;
            }
            }
        }

        string FlowChart_Replacement_Text(long IndexFlowChart) // , MyString As String) As String
        {
            string MyStringTemp;
            string EditedString;
            string FindingString;
            string RePlaceMentString;
            long IndexNamed;
            // Find the symbol
            CheckForAnySortNeeded("", 112);
            IndexNamed = FindIndexIniSAMTable("Named", "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, FlowChart_TableSymbol_Name(IndexFlowChart));
            CheckForAnySortNeeded("", 113);
            MyCheckIndexs(IndexFlowChart, 0, IndexNamed, 0, 0);

            // MyMsgCtr(1340, "GetSelfCorrectingIndexes",
            // "8 Names:",
            // FlowChart_TableSymbol_Name(IndexFlowChart),
            // Named_TableSymbolName(Named_FileSymbolName_iSAM(IndexNamed - 1)),
            // Named_TableSymbolName(Named_FileSymbolName_iSAM(IndexNamed)),
            // Named_TableSymbolName(Named_FileSymbolName_iSAM(IndexNamed + 1)),
            // CStr(IndexFlowChart), CStr(IndexNamed), "", "")
            if (IndexNamed < 1)
                // A I N F O 2 (37)
                return null;
            // I = Named_FileSymbolName_iSAM(I)
            // get the symbol program source code to edit.
            EditedString = Named_TableMicroCodeText(IndexNamed);

            // 03/12/19 Removed all of the test for the right properities named, because if it's the wrong name, then it will be ignored in the replace attempt
            // 03/12/19 TopOfFile code by 1/3 
            MyStringTemp = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));

            while (Strings.Len(MyStringTemp) > 1)
            {

                // Get Rid of anything so that we correct it back to start with a "/"
                while (Strings.Left(MyStringTemp + "?", 1) != "/" & Strings.Len(MyStringTemp) > 0)
                    MyStringTemp = Strings.Mid(MyStringTemp, 2);

                FindingString = MyUniverse.SysGen.Constants.RMStart + Strings.Trim(Strings.Mid(Pop(ref MyStringTemp, MyUniverse.SysGen.Constants.ConstantDelimeters), 3)) + MyUniverse.SysGen.Constants.RMEnd;
                RePlaceMentString = Pop(ref MyStringTemp, MyUniverse.SysGen.Constants.ConstantDelimeters);
                EditedString = MyReplace(EditedString, FindingString, RePlaceMentString);
            }
            FlowChart_Replacement_Text = EditedString;
        }


        void MyDeCompile(string Where, string InputFileName)  // Converts from language into FlowChart
        {
            string InputFileText;
            long IndexFlowChart;
            // Bugs:
            // It does not make /paths for all of the connections to a symbol. 
            // It does not connect paths of the same name to each other. (Updatedlinks to do this)
            // It does not place symbols in the 'best' place
            // ReDim Named_FileSintax_Isam(UBound(Named_FileSymbolName)) ' and deleted afwards

            // no one had this many lines of code (or it would destrory the program anyway)
            MyUniverse.MySS = FillImportLine();
            // MyUniverse.SymbolPointCount = 1 ' First point 
            // todo need to not reset ths .use? if it has already been used. 

            MyPlacement(false); // sets the min's

            // MyMsgCtr(1116, "MyDeCompile", "Starting to convert source code to FlowChart computer language", "", "", "", "", "", "", "", "")

            if (Strings.Len(InputFileName) < 4)
                InputFileName = XOpenFile("decompile", "Open The Source Code File");
            if (InputFileName == null)
                return;

            if (FileSystem.Dir(InputFileName) == "")
                return;

            // Now open it for output

            // MyMsgCtr(1149, "MyDeCompile", InputFileName, "", "", "", "", "", "", "", "")

            Clear_Screen_Only(Where);

            // make symbols for everything that has microcodetext and no Syntax
            CheckAndFixSintax();

            using (System.IO.TextReader reader = System.IO.File.OpenText(InputFileName))
            {
                InputFileText = reader.ReadToEnd();
            }
            MyUniverse.MySS.Inputs.LineNumberIn += 1;
            MyPlacement(true); // Only place it should add 
            MyUniverse.MySS.Inputs.KeyLineOrFile = InputFileText;
            while (Strings.Len(MyUniverse.MySS.Inputs.KeyLineOrFile) > 0)
            {
                DisplayMyStatus("Line Number " + MyUniverse.MySS.Inputs.LineNumberIn.ToString());
                // A I N F O 2 (166) 'hack
                MyDeCompileLine(MyUniverse.MySS.Inputs.KeyLineOrFile);
                FindingMyBugs(40); // hack Least amount of checking here
                MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, TopOfFile("named"));
            }
            // reader.Close()
            // End Using



            // ReDim Named_FileSintax_Isam(1) ' and deleted afwards
            for (IndexFlowChart = TopOfFile("FlowChart"); IndexFlowChart >= 1; IndexFlowChart += -1)
            {
                DisplayMyStatus("Linking " + IndexFlowChart);
                // passing a /use symbolname as a pathname here.
                UpDateFlowChartLinks(IndexFlowChart, MyUniverse.MySS.Inputs.LineNumberIn, Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)));
                PaintAll(Where, IndexFlowChart, IndexFlowChart);
            }
            DisplayMyStatus("Finished Doing the Compile.");
        }

        void MyDeCompileLine(string My_InputCodeLine) // Converts each line of source code into a FlowChart (and symbol if required)
        {
            string SymbolName;
            string PathName;
            long MyErrors;
            if (Strings.Left(MyTrim(My_InputCodeLine), 1) == "/")
            {
                if (Strings.Left(My_InputCodeLine, 2) != "//")
                {
                    ImportLineOrFile(My_InputCodeLine);
                    return;
                }
            }

            DisplayMyStatus("Line Number " + MyUniverse.MySS.Inputs.LineNumberIn.ToString());
            PathName = "??";

            MyUniverse.MySS.Inputs.KeyLineOrFile = MyTrim(My_InputCodeLine);
            MyErrors = 10000; // number of lines of code or errors '9,223,372,036,854,775,807 ' This should be enough to avoid a forever loop
            MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, TopOfFile("named"));
            while (MyErrors > 0)  // will exit when the end of file is reached.
            {
                MyErrors -= 1;
                MyUniverse.MySS.Inputs.KeyParameters = MyTrim(PopLine(ref MyUniverse.MySS.Inputs.KeyLineOrFile));
                MyUniverse.MySS.Inputs.KeyParameters = C_L_PreProcessor(MyUniverse.MySS.Inputs.KeyParameters);

                while (Strings.Len(MyUniverse.MySS.Inputs.KeyParameters) > 0)
                {
                    MyUniverse.MySS.Inputs.LineNumberIn += 1;
                    MyPlacement(true); // Second place it should add
                    // FindingMyBugs(30) 'hace Least amount of checking here
                    MyMakeArraySizesBigger();
                    MyUniverse.MySS.MyIndexEs.IndexNamed = FindSymbolSintax(MyUniverse.MySS.Inputs.KeyParameters);
                    if (MyUniverse.MySS.MyIndexEs.IndexNamed > constantMyErrorCode)
                    {
                        SymbolName = Named_TableSymbolName(MyUniverse.MySS.MyIndexEs.IndexNamed);
                        PathName = "?";
                    }
                    else
                        SymbolName = null;
                    MyCheckIndexs(0, 0, MyUniverse.MySS.MyIndexEs.IndexNamed, 0, 0);
                    if (MyUniverse.MySS.MyIndexEs.IndexNamed <= 0)
                    {
                        MyUniverse.MySS.MyIndexEs.IndexNamed = MakeSymbolFromSinTax(MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn, PathName);
                        if (MyUniverse.MySS.MyIndexEs.IndexNamed > 0)
                        {
                            SymbolName = Named_TableSymbolName(MyUniverse.MySS.MyIndexEs.IndexNamed);
                            MyDoEvents();
                            PaintAll(FlowChartScreen.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1);
                            MyDoEvents();
                        }
                        else
                            Abug(109, " added a line, and did not get a symbol named in return ", MyUniverse.MySS.MyIndexEs.IndexNamed, MyUniverse.MySS.Inputs.KeyParameters);
                        // SymbolName = AddNewName("Error_")
                        MyPlacement(false);
                        MakeUseANDPath(MyUniverse.MySS.Inputs.KeyParameters, SymbolName, MyUniverse.MySS.MyIndexEs.IndexNamed, MyUniverse.MySS.Inputs.LineNumberIn, PathName);
                        MyUniverse.MySS.Inputs.KeyParameters = "";
                        MyDoEvents();
                        PaintAll(FlowChartScreen.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1);
                        SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, Named_TableSymbolName(MyUniverse.MySS.MyIndexEs.IndexNamed));
                        MyDoEvents();
                    }
                    else
                    {
                        MakeUseANDPath(MyUniverse.MySS.Inputs.KeyParameters, SymbolName, MyUniverse.MySS.MyIndexEs.IndexNamed, MyUniverse.MySS.Inputs.LineNumberIn, PathName);
                        MyUniverse.MySS.Inputs.KeyParameters = ""; // End of this line?

                        PaintAll(FlowChartScreen.PictureBox1, TopOfFile("FlowChart") - 1, TopOfFile("FlowChart") + 1);
                    }

                    // should we be searching for keylin, or symbolname? (Changed to symbolname 2020 08 17 for no reason
                    MyUniverse.MySS.MyIndexEs.IndexNamed = FindIndexIniSAMTable("Named", "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName); // MyUniverse.MySS.Inputs.KeyParameters)
                    if (MyUniverse.MySS.MyIndexEs.IndexNamed == constantMyErrorCode)
                        MyUniverse.MySS.MyIndexEs.IndexNamed = CheckNotInList("named", ref "Do Not Add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref SymbolName);// MyUniverse.MySS.Inputs.KeyParameters)
                    if (MyUniverse.MySS.MyIndexEs.IndexNamed < 1)
                        Abug(111, " The symbol " + SymbolName, "was not found!", MyUniverse.MySS.MyIndexEs.IndexNamed);
                    else
                    {
                        AddSymbolToDropDown(Named_TableSymbolName(MyUniverse.MySS.MyIndexEs.IndexNamed));
                        SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, Named_TableSymbolName(MyUniverse.MySS.MyIndexEs.IndexNamed));
                    }

                    Clear_Screen(SymbolScreen.PictureBox1);
                }
                if (Strings.Len(MyUniverse.MySS.Inputs.KeyLineOrFile) <= 0)
                    return; // to avoid error count
            }
            ReSortSymbolList();
        }



        string Convertmicrocodetext2Sintax(string MyArray[], string microcodetext)
        {
            pathnames = MyParse(ref MyArray, microcodetext);
            return Strings.Trim(MakeStatementSintax(MyArray));
        }



        // This should update all of the links to this 'set' of paths connect to this link's (X-Y)
        // And return the next use index number to compile
        string CompileThisSymbolText(long IndexFlowChart)
        {
            long IndexNamed;
            string MyConnectionsToMyCode;
            string ThisIs;
            string ThisIsSymbolName;
            string ThisIsExtensionName;
            string ThisIsValue;
            string Temp, Temp2;
            int I1, I2, I3, I4, I5;

            CheckForAnySortNeeded("", 114);
            IndexNamed = FindIndexIniSAMTable("Named", "Dontadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, FlowChart_TableSymbol_Name(IndexFlowChart));
            CheckForAnySortNeeded("", 115);
            MyCheckIndexs(IndexFlowChart, 0, IndexNamed, 0, 0);

            CompileThisSymbolText = Named_Tablemicrocodetext(IndexNamed);

            switch (Strings.LCase(FlowChart_TableCode(IndexFlowChart))) // Should only get /USE codes
            {
            case "/use":
            {
                MyConnectionsToMyCode = ""; // FlowChart_TableCompiledMacroCodeText(IndexFlowChart )
                                            // Find The Next Goto Symbol to compile As The Next One  (If already processed then Pick one not done (at Random?))
                CheckForAnySortNeeded("", 116);
                IndexNamed = FindIndexIniSAMTable("Named", "Dontadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, FlowChart_TableSymbol_Name(IndexFlowChart));
                CheckForAnySortNeeded("", 117);
                MyCheckIndexs(IndexFlowChart, 0, IndexNamed, 0, 0);

                CompileThisSymbolText = FlowChart_Replacement_Text(IndexFlowChart); // , Named_Tablemicrocodetext(IndexNamed)) '3/16/19
                                                                                    // Now Get all of the names of the variables that connect to this use and replace them.
                I1 = 1;
                while ((I1 + 3 < Strings.Len(MyConnectionsToMyCode)))
                {
                    ThisIs = Strings.Trim(Pop(ref MyConnectionsToMyCode, MyUniverse.SysGen.Constants.ConstantDelimeters));
                    I1 = Strings.InStr(I1, MyConnectionsToMyCode + MyUniverse.SysGen.Constants.RMStart, MyUniverse.SysGen.Constants.RMStart); // start 
                    I2 = Strings.InStr(I1, MyConnectionsToMyCode + ".", "."); // middle of it
                    I3 = Strings.InStr(I1, MyConnectionsToMyCode + MyUniverse.SysGen.Constants.RMEnd, MyUniverse.SysGen.Constants.RMEnd); // end of it
                    I4 = Strings.InStr(I1, MyConnectionsToMyCode + "=", "="); // get the value of what this is
                    I5 = Strings.InStr(I1 + 1, MyConnectionsToMyCode + MyUniverse.SysGen.Constants.RMStart, MyUniverse.SysGen.Constants.RMStart); // start of the Next and end of the line

                    if (I2 <= I1)
                        Abug(112, "the period is before the start of the replacement", ThisIs, MyConnectionsToMyCode);
                    if (I3 <= I2)
                        Abug(113, "the period is after the end of the replacement", ThisIs, MyConnectionsToMyCode);
                    if (I4 <= I3)
                        Abug(114, "the equal sign is before the replacement", ThisIs, MyConnectionsToMyCode);
                    if (I5 <= I4)
                        Abug(115, "the end is before the replacement", ThisIs, MyConnectionsToMyCode);
                    if (I2 > I3)
                        I2 = I3 - 1;
                    if (I1 == I2 | I2 == I3 | I3 == I4 | I4 == I5)
                        Abug(116, " Not correct diagram ", ThisIs, MyConnectionsToMyCode);
                    else
                    {
                        ThisIsSymbolName = Strings.Mid(MyConnectionsToMyCode, I1 + 1, I2 - I1 - 1); // From [ to .
                                                                                                    // wrong
                                                                                                    // MyUniverse.DebugA = "" 'hack
                                                                                                    // ThisIsExtensionName = Mid(MyConnectionsToMyCode, I2 + 1, I3 - I2 - 1) 'from . to ]
                                                                                                    // wrong
                                                                                                    // MyUniverse.DebugA = "" 'hack
                        if (I5 <= I4)
                            I5 = I4 + 1;
                        ThisIsValue = Strings.Mid(MyConnectionsToMyCode, I4 + 1, I5 - I4 - 1); // from = to [


                        ThisIsExtensionName = Strings.Mid(MyConnectionsToMyCode, I2 + 1, I3 - I2 - 1); // from . to ]
                        CompileThisSymbolText = MyReplace(CompileThisSymbolText, MyUniverse.SysGen.Constants.RMStart + ThisIsSymbolName + "." + ThisIsExtensionName + MyUniverse.SysGen.Constants.RMEnd, ThisIsValue);
                        switch (Strings.LCase(Strings.Trim(ThisIs)))
                        {
                        case "/point":
                        {
                            Temp = MyConnectionsToMyCode; // FlowChart_TableLinks(IndexFlowChart )
                            Temp = MyFixLine(Temp);
                            while (Strings.Len(Temp) > 0)
                            {
                                Temp2 = Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters);
                                while (Strings.Left(Temp2, 1) == FD)
                                    Temp2 = Strings.Mid(Temp2, 2, Strings.Len(Temp2));
                                FindingMyBugs(10); // hace Least amount of checking here


                                // TODO WHY AM i SETTING TEMP2, INSTEAD OF TEMP? JUST TO GET RID OF IT??
                                switch (Strings.LCase(Strings.Trim(Temp2)))
                                {
                                case "/x1":
                                {
                                    // ?Temp2 =
                                    Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters);
                                    break;
                                }

                                case "/y1":
                                {
                                    // ?Temp2 =
                                    Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters);
                                    break;
                                }

                                case "/x2":
                                {
                                    // ?Temp2 =
                                    Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters);
                                    break;
                                }

                                case "/y2":
                                {
                                    // ?Temp2 = 
                                    Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters);
                                    break;
                                }

                                default:
                                {
                                    break;
                                }
                                }
                            }

                            break;
                        }

                        case "/use":
                        case "/path":
                        case "/line":
                        {
                            Temp = "";
                            break;
                        }

                        default:
                        {
                            MyMsgCtr(1030, "MyCompile", FlowChart_TableCode(IndexFlowChart) + MyConnectionsToMyCode, ThisIs, "", "", "", "", "", "", "");
                            break;
                        }
                        } // Ench item of the status of this use
                    }
                } // Get the next item of this use status

                break;
            }

            case "/error"  // ignore all errors for now
                :
            {
                break;
            }

            case "/constant" // ignore all constants for now
                :
            {
                break;
            }

            case "/path"  // Ignore all paths for now
                :
            {
                ConnectPath(IndexFlowChart);
                break;
            }

            default:
            {
                MyMsgCtr(1117, "CompileThisSymbolText", FlowChart_TableCode(IndexFlowChart), "", "", "", "", "", "", "", "");
                break;
            }
            }
        }

        void MyCompile(string  Where) // Converts from a FlowChart into Source Code
        {
            long IndexFlowChart;
            long IndexNamed;
            long IndexSymbol;
            long IndexNetLinks;
            string OutputFileName;
            string MyCode;
            string Temp;
            // Dim MyWriter As StreamWriter
            MyUniverse.MySS = FillImportLine();

            Clear_Screen_Only(Where);
            OutputFileName = XOpenFile("compile", "Saving the compiled source For " + DrillDown_FileName + "." + MyUniverse.ProgramOptions.C_L_Extention); // 2020 08 10 , DrillDownFileName)
            if (OutputFileName == null)
                return;

            if (FileSystem.Dir(OutputFileName) == "")
            {
                // System.IO.File.Create(OutputFileName)
                using (System.IO.StreamWriter Writer = System.IO.File.CreateText(OutputFileName))
                {
                }
            }

            using (StreamWriter mywriter = new StreamWriter(OutputFileName))
            {
                Clear_Screen_Only(Where);
                FindingMyBugs(10); // hack Least amount of checking here
                for (IndexNetLinks = 1; IndexNetLinks <= Information.UBound(Net_FileLinks); IndexNetLinks++)
                {
                    AInfo1(999, MyShowNetLnks(IndexNetLinks), "", "");
                    Temp = Net_TableLinks(IndexNetLinks);
                    MyCode = FlowChart_Table_DataType(PopNonZeroValue(ref Temp)) + " ";
                    MyCode += Net_TableNames(IndexNetLinks);
                    MyWriteLine1(mywriter, MyCode);
                }


                for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
                {
                    FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
                    MyCheckIndexs(IndexFlowChart, 0, IndexNamed, 0, 0);
                    UpDateFlowChartLinks(IndexFlowChart, MyUniverse.MySS.Inputs.LineNumberIn, FlowChart_FilePathSymbolName[IndexFlowChart]);
                    ReSetScrollBars(IndexFlowChart);
                    switch (Strings.LCase(FlowChart_TableCode(IndexFlowChart)))
                    {
                    case "/use":
                    {
                        CheckForAnySortNeeded("", 118);
                        IndexNamed = FindIndexIniSAMTable("Named", "dontadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, FlowChart_TableSymbol_Name(IndexFlowChart));
                        CheckForAnySortNeeded("", 119);
                        MyCheckIndexs(IndexFlowChart, 0, IndexNamed, 0, 0);
                        IndexSymbol = Named_FileSymbolName_iSAM[IndexNamed];
                        FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
                        MyCheckIndexs(IndexFlowChart, 0, IndexNamed, 0, 0);
                        // Added 3/16/19 for check of replacements
                        MyCode = CompileEachSymbol(IndexFlowChart, MyUniverse.MySS.Inputs.LineNumberIn);
                        // CheckBoxOutputLineNumbers
                        if (MyOptionTest(16) == true)
                            MyCode = MyCode + MyUniverse.ProgramOptions.C_L_Comment + " Line " + MyUniverse.MySS.Inputs.LineNumberIn;
                        else
                        {
                        }
                        MyWriteLine1(mywriter, MyCode);
                        MyUniverse.MySS.Inputs.LineNumberIn += 1;
                        MyPlacement(true);// THird place it should add
                        break;
                    }

                    case "/path":
                    {
                        ConnectPath(IndexFlowChart);
                        break;
                    }

                    case "/error":
                    {
                        break;
                    }

                    case "/constant":
                    {
                        break;
                    }

                    default:
                    {
                        MyMsgCtr(1031, "MyCompile", FlowChart_TableCode(IndexFlowChart), IndexFlowChart.ToString(), "", "", "", "", "", "", "");
                        break;
                    }
                    }
                }
            }
            // FileClose(MyWriter)
            // End Using
            Clear_Screen(Where);
            DisplayMyStatus("Translation into source code Finished.");
        }



        // Routine 'Compile' is where it starts checking, then makes the text output
        string CompileEachSymbol(long IndexFlowChart, long LineNumber)
        {
            // Get the links between the symbols (path names)
            UpDateFlowChartLinks(IndexFlowChart, LineNumber, FlowChart_FilePathSymbolName[IndexFlowChart]);
            // Replace the code with the names of the paths (And other information)
            CompileEachSymbol = CompileThisSymbolText(IndexFlowChart); // Write out this symbol then get the next one to do
        }


        void MakePaths(long IndexFlowChart1, long IndexFlowChart2, long LineNumber) // make new paths connecting two together
        {
            string SymbolNamed; // Links,DataTypeIs 
            long X1, Y1, X2, Y2;
            long NetIndex1, NetIndex2;
            string NetLinks1, NetLinks2;
            string A1, A2;
            long InNetLinksAt;

            if (IndexFlowChart1 == IndexFlowChart2)
                return; // do not make a path from itself to itself

            // must be /paths
            if (FlowChart_TableCode(IndexFlowChart1) != "/path")
                return;
            if (FlowChart_TableCode(IndexFlowChart2) != "/path")
                return;

            NetIndex1 = FlowChart_TablePathNumber(IndexFlowChart1);
            if (NetIndex1 < 1)
                AInfo(821, "Path Name Problem A)" + NetIndex1, MyShowFlowChartRecord(IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1));
            NetIndex2 = FlowChart_TablePathNumber(IndexFlowChart2);
            if (NetIndex2 < 1)
                AInfo(822, "Path Name Problem B)" + NetIndex2, MyShowFlowChartRecord(IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1));
            NetLinks1 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart1));
            if (Strings.Len(NetLinks1) < 1)
                AInfo(823, "Path Name Problem C)" + NetLinks1, MyShowFlowChartRecord(IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1));
            NetLinks2 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart2));
            if (Strings.Len(NetLinks2) < 1)
                AInfo(824, "Path Name Problem D)" + NetLinks2, MyShowFlowChartRecord(IndexFlowChart1), FindIndex_In_TableNetLinks(IndexFlowChart1));

            if (NetLinks1 == "" | NetLinks2 == "")
                Abug(803, "Net is empty", NetLinks1, NetLinks2);// MyShowNetLnks(IndexFlowChart1  ), MyShowNetLnks(IndexFlowChart2  ))

            // error two nets are the same, so should delete one
            if (IndexFlowChart1 != IndexFlowChart2)
            {
                if (NetLinks1 == NetLinks2)
                {
                    Abug(117, " Two paths are the same ", MyShowNetLnks(NetIndex1), MyShowNetLnks(NetIndex2));
                    Abug(118, " Two paths are the same ", MyShowFlowChartRecord(IndexFlowChart1), MyShowFlowChartRecord(IndexFlowChart2));
                }
                else
                {
                    Abug(804, "Problem with these two paths ", MyShowNetLnks(IndexFlowChart1), MyShowNetLnks(IndexFlowChart2));
                    return; // cause the paths are already connected
                }
            }
            else
                Abug(119, "Making the same path again", IndexFlowChart1, IndexFlowChart2);


            InNetLinksAt = FindIndex_In_TableNetLinks(IndexFlowChart1);
            if (InNetLinksAt < 0)
                MakeNew_NetLinks(IndexFlowChart1, FlowChart_TablePathNumber(IndexFlowChart1));

            if (NetLinks1 != NetLinks2)
            {
                // we should be combinine two differant named nets together?
                Abug(121, "Two differant paths " + IndexFlowChart1 + " : " + IndexFlowChart2, MyShowNetLnks(NetIndex1), MyShowNetLnks(NetIndex2));
                SymbolNamed = FlowChart_TablePathName(IndexFlowChart1) + "&" + FlowChart_TablePathName(IndexFlowChart1);
            }
            else
                SymbolNamed = FlowChart_TablePathName(IndexFlowChart1);

            // Must have the same name (maybe, or else it is an error , it is an error, )
            if (FlowChart_TablePathName(IndexFlowChart1) != FlowChart_TablePathName(IndexFlowChart2))
                return;

            // From the second point in one
            X1 = FlowChart_TableX2(IndexFlowChart1);
            Y1 = FlowChart_TableY2(IndexFlowChart1);
            // To the second point in the other
            X2 = FlowChart_TableX2(IndexFlowChart2);
            Y2 = FlowChart_TableY2(IndexFlowChart2);
            // should also clean the two of them out 
            A1 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart1));
            A2 = Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart2));
            ainfo2(2);
            MyDrawPath(FlowChartScreen.PictureBox1, MyLine1(X1, Y1, X2, Y2), "yelow");
            // ainfo2(3)
            UpDateFlowChartLinks(TopOfFile("FlowChart"), LineNumber, SymbolNamed);
            AddNEWFlowChartRecordPath(SymbolNamed, "/path", X1, Y1, System.Convert.ToString(X2), System.Convert.ToString(Y2), "error", LineNumber);
        }


        void UpDateFlowChartLinks(long IndexFlowChart, long LineNumber, string PathName) // /Use fills in information /Path adds to net number list and saves netnumber into links
        {
            // Dim idex As long
            long IndexNamed, IndexSymbol, IndexPath;
            string MY_DatatypeName, My_RotationName, My_Input_Output_Both, SL, MyPathName;
            long My_DataTypeIndex;
            string ThisPointName, ThisSymbolName; // holds the name
            string Temp;
            MyPointStructure SymbolXY;
            long MyPathX, MyPathY;

            // PathName = CheckThisPathName(PathName, IndexFlowChart)
            // hack this is not a path location, but the center of the symbol!
            // PathX = FlowChart_TableX1(IndexFlowChart )
            // PathY = FlowChart_TableY1(IndexFlowChart )

            // FindingMyBugs(20) 'hace Least amount of checking here
            // The following causes the links to be save twice in size

            switch (Strings.LCase(FlowChart_TableCode(IndexFlowChart)))
            {
                case "/use"  // Find all of the points of a symbol (And Put them Together in FCStatus)
                    :
                {
                    if (MyCheckValidUse(IndexFlowChart) == false)
                        return;
                    CheckForAnySortNeeded("", 120);
                    IndexNamed = FindIndexIniSAMTable("Named", "Add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, FlowChart_TableSymbol_Name(IndexFlowChart));
                    if (IndexNamed == constantMyErrorCode)
                        return;
                    CheckForAnySortNeeded("", 121);
                    MyCheckIndexs(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0);
                    // ThisSymbolName = Named_FileSymbolName(IndexNamed) ' need to check for error of -1 return
                    IndexSymbol = GetSelfCorrectingIndexes(FlowChart_TableSymbol_Name(IndexFlowChart));
                    MyCheckIndexs(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0);
                    ThisSymbolName = FlowChart_TableSymbol_Name(IndexFlowChart);
                    SL = "";

                    // hack only need one of these two.
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".name" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(ThisSymbolName); // This symbol name
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".name" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableSymbolName(IndexNamed)); // hack
                    SL += Temp; // hack, 


                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".index" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(IndexFlowChart.ToString());
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".x" + MyUniverse.SysGen.Constants.RMEnd + "=" + FlowChart_TableX1(IndexFlowChart).ToString();
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".y" + MyUniverse.SysGen.Constants.RMEnd + "=" + FlowChart_TableY1(IndexFlowChart).ToString();
                    SL += Temp;
                    // rotation
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".Rotation" + MyUniverse.SysGen.Constants.RMEnd + "=" + FlowChart_Table_Rotation(IndexFlowChart);
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".DataType" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".OpCode" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableOpCode(IndexNamed));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".notes" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableNotes(IndexNamed));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".FileName" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableNameofFile(IndexNamed));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".Author" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableAuthor(IndexNamed));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".Version" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableVersion(IndexNamed));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".Stroke" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableStroke(IndexNamed));
                    SL += Temp;
                    Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".Indexes" + MyUniverse.SysGen.Constants.RMEnd + "=" + Named_TableSymbolIndexes(IndexNamed);
                    SL += Temp;

                    if (IndexSymbol > 0)
                    {
                        FindingMyBugs(10); // hack Least amount of checking here
                        if (Symbol_TableCoded_String(IndexSymbol) == "/name")
                        {
                            // Removed                             If Len(FlowChart_TableCompiledMacroCodeText(IndexFlowChart )) > 2 Then
                            // Removed                             Abug(122, FlowChart_TableCompiledMacroCodeText(IndexFlowChart ), 0, 0)
                            // Removed                             If FindIndex_In_TableNetLinks(IndexFlowChart ) < 1 Then makeNew_NetLinks(IndexFlowChart , FlowChart_TableSymbol_Name(IndexFlowChart ))
                            // Removed                         Else
                            // Removed                         End If
                            My_RotationName = FlowChart_Table_Rotation(IndexFlowChart);
                            FindingMyBugs(10); // hack Least amount of checking here
                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".name" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Symbol_TableSymbolName(IndexSymbol));
                            SL += Temp;
                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".xa" + MyUniverse.SysGen.Constants.RMEnd + "=" + MyRotated(IndexSymbol, IndexFlowChart).Xx;
                            SL += Temp;
                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".ya" + MyUniverse.SysGen.Constants.RMEnd + "=" + MyRotated(IndexSymbol, IndexFlowChart).Yy;
                            SL += Temp;
                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".rotation" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(My_RotationName);
                            SL += Temp;
                            if (Strings.LCase(Symbol_TableSymbolName(IndexSymbol)) == Strings.LCase(FlowChart_TableSymbol_Name(IndexFlowChart)))
                            {
                                Temp = MyUniverse.SysGen.Constants.RMStart + ThisSymbolName + ".code" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Named_TableMicroCodeText(IndexSymbol));
                                SL += Temp + "*****";
                                IndexSymbol += 1;
                                MyCheckIndexs(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0);
                                while (Symbol_TableCoded_String(IndexSymbol) != "/name" & IndexSymbol < TopOfFile("Symbol"))
                                {
                                    switch (Symbol_TableCoded_String(IndexSymbol))
                                    {
                                    case "/point":
                                    {
                                        FixSinTaxCode(IndexNamed);
                                        ThisPointName = NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol));
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".name" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(ThisPointName);
                                        SL += Temp;
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".index" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(IndexSymbol.ToString());
                                        SL += Temp;
                                        My_RotationName = FlowChart_Table_Rotation(IndexFlowChart);
                                        My_Input_Output_Both = Symbol_Table_InputOutput(IndexSymbol);
                                        MY_DatatypeName = Symbol_Table_DataType(IndexSymbol);
                                        My_DataTypeIndex = FindDataTypeIndex(MY_DatatypeName);
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".name" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(Symbol_Table_NameOfPoint(IndexSymbol));
                                        SL += Temp;
                                        SymbolXY.Xx = MyRotated(IndexSymbol, IndexFlowChart).Xx;
                                        SymbolXY.Yy = MyRotated(IndexSymbol, IndexFlowChart).Yy;
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".x" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MyRotated(IndexSymbol, IndexFlowChart).Xx.ToString());
                                        MyPathX = MyRotated(IndexSymbol, IndexFlowChart).Xx;
                                        SL += Temp;
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".y" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MyRotated(IndexSymbol, IndexFlowChart).Yy.ToString());
                                        MyPathY = MyRotated(IndexSymbol, IndexFlowChart).Yy;
                                        SL += Temp;
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".IO" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(My_Input_Output_Both);
                                        SL += Temp;
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".Rotation" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(My_RotationName);
                                        SL += Temp;
                                        Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".Datatype" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MY_DatatypeName);
                                        SL += Temp;

                                        IndexPath = FindPathNameAt(MyPoint1XY(MyPathX, MyPathY));
                                        if (IndexPath > 0)
                                        {
                                            MyPathName = FlowChart_TablePathName(IndexPath); // data type
                                                                                             // PathX = MyRotated_1(IndexSymbol, IndexPath, My_RotationName).X
                                                                                             // PathY = MyRotated_1(IndexSymbol, IndexPath, My_RotationName).Y
                                                                                             // 2020  07 16 change it to have not rotation aor symbol (Cause Im calling the wrong subroutine.) 

                                            if (MyDistance(MyPoint1XY(FlowChart_TableX1(IndexPath), FlowChart_TableY1(IndexPath)), MyPoint2XY(SymbolXY.Xx, SymbolXY.Yy)) < MyDistance(MyPoint1XY(FlowChart_TableX2(IndexPath), FlowChart_TableY2(IndexPath)), MyPoint2XY(SymbolXY.Xx, SymbolXY.Yy)))
                                            {
                                                MyPathX = FlowChart_TableX1(IndexPath);
                                                MyPathY = FlowChart_TableY1(IndexPath);
                                            }
                                            else
                                            {
                                                MyPathX = FlowChart_TableX2(IndexPath);
                                                MyPathY = FlowChart_TableY2(IndexPath);
                                            }
                                            // PathX = MyRotated_1(0, IndexPath, "default").X
                                            // PathY = MyRotated_1(0, IndexPath, "default").Y
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".PathName" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MyPathName);
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".Variable" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MyPathName);
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".PathX" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MyPathX.ToString());
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".pathY" + MyUniverse.SysGen.Constants.RMEnd + "=" + PrintAbleNull(MyPathY.ToString());
                                            SL += Temp;
                                            // This is not the distance from the symbol to the path
                                            // Temp = ConstantSeperators & MyUniverse.SysGen.Constants.RMStart  & ThisPointName & ".Distance =" &
                                            // MyDistance(MyRotated_1(IndexSymbol, IndexFlowChart , My_RotationName),
                                            // MyPoint2XY(FlowChart_TableX1(IndexFlowChart ), FlowChart_TableY1(IndexFlowChart )))
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".Distance" + MyUniverse.SysGen.Constants.RMEnd + "=" + MyDistance(MyPoint2XY(MyPathX, MyPathY), MyPoint2XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)));
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".DataTypeName" + MyUniverse.SysGen.Constants.RMEnd + "=" + MY_DatatypeName;
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".DataTypeDescribtion" + MyUniverse.SysGen.Constants.RMEnd + "=" + DataType_TableDescribtion(My_DataTypeIndex);
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".Bytes" + MyUniverse.SysGen.Constants.RMEnd + "=" + DataType_TableNumberOfBytes(My_DataTypeIndex);
                                            SL += Temp;

                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".DataTypeColor" + MyUniverse.SysGen.Constants.RMEnd + "=" + FindColorFromDataType(DataType_TableName(My_DataTypeIndex));
                                            SL += Temp;
                                            Temp = MyUniverse.SysGen.Constants.RMStart + ThisPointName + ".Width" + MyUniverse.SysGen.Constants.RMEnd + "=" + DataType_TableWidth(My_DataTypeIndex);
                                            SL += Temp;
                                        }
                                        else
                                        {
                                            Temp = MyUniverse.SysGen.Constants.RMStart + MakeNewName("Errored_", IndexFlowChart, "NoPathConnected") + ".PathName" + MyUniverse.SysGen.Constants.RMEnd + "=NULL)";
                                            SL += Temp;
                                        }
                                        // hack removed??
                                        // removed this cause we are in a /use 
                                        // If FindIndex_In_TableNetLinks(IndexFlowChart) < 1 Then
                                        // MakeNew_NetLinks(IndexFlowChart, FlowChart_TablePath_Name(IndexFlowChart))
                                        // End If
                                        // Takes more time to move all of this sting but it's easier to debug for now
                                        MyCheckValidUse(IndexFlowChart);
                                        break;
                                    }

                                    case "/line" // Ignore
                                        :
                                    {
                                        break;
                                    }

                                    default:
                                    {
                                        Abug(124, "Unknown code ", MyShowSymbolRecords(IndexSymbol), Symbol_TableCoded_String(IndexSymbol));
                                        break;
                                    }
                                    }
                                    IndexSymbol += 1;
                                    MyCheckIndexs(IndexFlowChart, IndexSymbol, IndexNamed, 0, 0);
                                }
                            }
                        }
                    }

                    break;
                }

                case "/path" // Find all of the lines of a path (And put them together in FCStatus)
                    :
                {
                    ConnectPath(IndexFlowChart);
                    ainfo2(5);
                    FindAllPaths(IndexFlowChart, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), PathName); // byXY
                    ainfo2(6);
                    FindAllPaths(IndexFlowChart, MyPoint1XY(FlowChart_TableX2(IndexFlowChart), FlowChart_TableY2(IndexFlowChart)), PathName); // byXY
                    ainfo2(7);
                    FindAllPaths_2(IndexFlowChart, LineNumber, PathName); // By Path Name
                    ainfo2(8);
                    ConnectPath(IndexFlowChart);
                    ainfo2(9);
                    break;
                }

                case "/constant" // I'm ignoring this for now. 
                    :
                {
                    // Abug(125, "UpdateFlowChartLinks", 0, 1)
                    if (FindIndex_In_TableNetLinks(IndexFlowChart) < 1)
                        MakeNew_NetLinks(IndexFlowChart, FlowChart_TablePath_Name(IndexFlowChart));
                    break;
                }

                case "/error":
                {
                    break;
                }

                default:
                {
                    AInfo(604, "not updating Links for ", FlowChart_TableCode(IndexFlowChart), IndexFlowChart);
                    break;
                }
            }
            FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
        }

        void MyMouseWheel(long e) // catches the mouse wheel to zoom in or out
        {
            if (e > 0)
                MyZoomIn(e);
            else if (e < 0)
                MyZoomOut(e);
        }



        void LimitScale()
        {
            if (MyUniverse.SysGen.MyFlowChartScale < ConstantMinFLowChartScale)
            {
                MyUniverse.SysGen.MyFlowChartScale = ConstantMinFLowChartScale; // 1/16
                DisplayStatus(ref FlowChartScreen.LabelProgramStatus.Text, "FlowCHart Scale limit is " + System.Convert.ToString(MyUniverse.SysGen.MyFlowChartScale));
            }
            if (MyUniverse.SysGen.MyFlowChartScale > ConstantMaxFlowChartScale)
            {
                MyUniverse.SysGen.MyFlowChartScale = ConstantMaxFlowChartScale;
                DisplayStatus(ref FlowChartScreen.LabelProgramStatus.Text, "FlowChart Scale limit is " + System.Convert.ToString(MyUniverse.SysGen.MyFlowChartScale));
            }
            // todo need to also limit the symbol scale from 1 to 4?
            if (MyUniverse.SysGen.MySymbolScale > 8)
            {
                MyUniverse.SysGen.MySymbolScale = 2;
                DisplayStatus(ref MyUniverse.SysGen.MySymbolScale.ToString(), "Symbol Scale limit is " + MyUniverse.SysGen.MySymbolScale.ToString());
            }
            if (MyUniverse.SysGen.MySymbolScale < 1)
            {
                MyUniverse.SysGen.MySymbolScale = 1;
                DisplayStatus(ref MyUniverse.SysGen.MySymbolScale.ToString(), "Symbol Scale limit is " + MyUniverse.SysGen.MySymbolScale.ToString());
            }
        }


        // Routine Makes the pictures bigger
        void MyZoomIn() // Steps scale up
        {
            MyUniverse.SysGen.MyFlowChartScale *= ConstantFlowChartScaleChange;
            LimitScale();
            Clear_Screen(FlowChartScreen.PictureBox1);
            MyButtonsEnableRules();
        }

        // Routine makes the picture smaller
        void MyZoomOut() // steps scale down
        {
            MyUniverse.SysGen.MyFlowChartScale /= (double)ConstantFlowChartScaleChange;
            LimitScale();
            Clear_Screen(FlowChartScreen.PictureBox1);
        }


        // Routine just save where the mouse went down at.
        void MyMouseDown(MyPointStructure e) // saves xy for mouse button pushed down
        {
            MyUniverse.Area.MyInputScreenXY.a.Xx = e.X;
            MyUniverse.Area.MyInputScreenXY.a.Yy = e.Y;
            MyUniverse.MyMouseAndDrawing.MouseStroke = ""; // New Symbol
        }

        void MyPlacement(bool AddOrNot)
        {
            long x, y, s, maxXY1;
            const long PlaceMent = 8; // times the size of the symbol (/2)
            MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing = MyUniverse.SysGen.Constants.constantSymbolCenter * MyUniverse.SysGen.Constants.constantSpacingFactor;
            x = MyUniverse.SysGen.Placement.Xx;
            y = MyUniverse.SysGen.Placement.Yy;
            s = MyUniverse.SysGen.Constants.constantSymbolCenter;
            maxXY1 = MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing * PlaceMent;
            if (AddOrNot == true)
                y = y + s * PlaceMent;
            if (y > maxXY1)
            {
                x += s * PlaceMent; // Move over 
                y = s;
            }
            if (x < s * PlaceMent)
                x = s * PlaceMent;
            if (y < s * 2)
                y = s * PlaceMent;
            MyUniverse.SysGen.Placement.Xx = x;
            MyUniverse.SysGen.Placement.Yy = y;
        }


        MyLineStructure MySnapindex(long IndexFlowChart) // , XY As long)
        {
            MyLineStructure XYZ;
            XYZ.a.Xx = FlowChart_TableX1(IndexFlowChart);
            XYZ.a.Yy = FlowChart_TableY1(IndexFlowChart);
            XYZ.b.Xx = FlowChart_TableX2(IndexFlowChart);
            XYZ.b.Yy = FlowChart_TableY2(IndexFlowChart);
            MySnapindex = MySnapXYXY(FlowChart_TableCode(IndexFlowChart), XYZ.a.Xx, XYZ.a.Yy, XYZ.b.Xx, XYZ.b.Yy);
        }

        MyLineStructure MySnapXYXY(string FlowChartCOde, long X1, long Y1, long X2, long Y2)
        {
            // IndexFlowChart As long) As MyLineStructure
            MyLineStructure XY;
            MySnapXYXY = default(MyLineStructure);
            XY = default(MyLineStructure);
            MySnapXYXY.a.Named.SymbolName = "?998?";
            // XYZ.a.Xx = FlowChart_TableX1(IndexFlowChart)
            // XYZ.a.Yy = FlowChart_TableY1(IndexFlowChart)
            XY.a.Named.PathName = "?999?";
            XY.a.Xx = X1;
            XY.a.Yy = Y1;
            switch (FlowChartCOde) // FlowChart_TableCode(IndexFlowChart)
            {
            case "/constant":
            {
                return MyLineXY(MyPoint1XY(X1, Y1), ZeroZero);
            }

            case "/use":
            {
                return MyLineXY(MySymbolSnap(MyPoint1XY(X1, Y1)), ZeroZero);
            }

            case "/path":
            {
                XY.b.Xx = X2; // FlowChart_TableX2(IndexFlowChart)
                XY.b.Yy = Y2; // FlowChart_TableY2(IndexFlowChart)
                MyPathSnap(ref MySnapXYXY, XY);
                break;
            }

            case "/error":
            {
                return MyLineXY(MyPoint1XY(X1, Y1), ZeroZero);
            }

            case "/unknown":
            {
                return MyLineXY(MyPoint1XY(X1, Y1), ZeroZero);
            }

            case "/point":
            {
                Abug(999, "Can not have a point in a flow chart, only inside a symbol", MyShowPoint(X1, Y1), "");
                break;
            }

            case null:
            {
                return MyLineXY(MyPoint1XY(X1, Y1), ZeroZero);
            }

            default:
            {
                Abug(127, "This is not movable to a grid", FlowChartCOde, "");
                return MyLineXY(MyPoint1XY(X1, Y1), XY.b); // no snap
            }
            }
        }

        // todo need to also have a snaptoline-1, snaptosymbol-1000
        void AllPaths2PointSnap(string  Where) // moves all path ends to connect to something
        {
            long IndexFlowChart, Jdex;
            MyPointStructure XY;
            XY = default(MyPointStructure);
            for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
            {
                UpDateFlowChartLinks(IndexFlowChart, 0, Net_TableNames(FlowChart_FilePathSymbolName[IndexFlowChart]));
                switch (FlowChart_TableCode(IndexFlowChart))
                {
                    case object _ when MyKeyword_2_Byte("/path").ToString()  // KeyConstPath
                        :
                    {
                        XY.Xx = FlowChart_TableX1(IndexFlowChart);
                        XY.Yy = FlowChart_TableY1(IndexFlowChart);
                        Jdex = MyFindPoint(Where, XY, IndexFlowChart);
                        XY.Xx = FlowChart_TableX2(IndexFlowChart);
                        XY.Yy = FlowChart_TableY2(IndexFlowChart);
                        Jdex = MyFindPoint(Where, XY, IndexFlowChart);
                        break;
                    }
                }
            }
        }


        string RandomColor()
        {
            ;/* Cannot convert LocalDeclarationStatementSyntax, System.NotSupportedException: StaticKeyword not supported!
   at ICSharpCode.CodeConverter.CSharp.SyntaxKindExtensions.ConvertToken(SyntaxKind t, TokenContext context)
   at ICSharpCode.CodeConverter.CSharp.CommonConversions.ConvertModifier(SyntaxToken m, TokenContext context)
   at ICSharpCode.CodeConverter.CSharp.CommonConversions.<ConvertModifiersCore>d__15.MoveNext()
   at System.Linq.Enumerable.WhereEnumerableIterator`1.MoveNext()
   at Microsoft.CodeAnalysis.SyntaxTokenList.CreateNode(IEnumerable`1 tokens)
   at ICSharpCode.CodeConverter.CSharp.CommonConversions.ConvertModifiers(IEnumerable`1 modifiers, TokenContext context, Boolean isVariableOrConst)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
            Static LastColor As long = 0

 */
            LastColor = (LastColor + 1) % TopOfFile("Color");
            return Color_TableName(LastColor);
        }


        // Routine Most everything is done in mouse up button
        void MyMouseMove(string  Where, MyPointStructure e)
        {
            MyPointStructure XY;
            MyPointStructure XY2;
            string What;
            if (MyFlowChartNameSpace.F_C.ProgramAlive == false)
                return;

            if (Where.Parent.Name == FlowChartScreen.Name)
                What = "/path";
            else
                What = "/line";


            XY = default(MyPointStructure);
            XY2 = default(MyPointStructure);
            XY2.Xx = e.X;
            XY2.Yy = e.Y;


            // This is here only to remind me to do something about it.
            switch ((e.Button))
            {
            case object _ when MouseButtons.Left:
            {
                break;
            }

            case object _ when MouseButtons.Right:
            {
                break;
            }

            case object _ when MouseButtons.Middle:
            {
                break;
            }

            case object _ when MouseButtons.None:
            {
                break;
            }

            case object _ when MouseButtons.XButton1:
            {
                break;
            }

            case object _ when MouseButtons.XButton1:
            {
                break;
            }
            }

            switch (Strings.LCase(Strings.Trim(MyCmdModeString)))
            {
                case "cmdmovehand" // This should move the pictures to where the mouse is let go.
                    :
                {
                    break;
                }

                case "cmdaddpath" // do nothing (later draw line where line should go (and deleete the previous line))
                    :
                {
                    XY = Copy2WorldXY("/path", where, XY2);
                    switch ((e.Button))
                    {
                        case object _ when MouseButtons.Left // Draw a following line only if you use the left button
                            :
                        {
                            MyDrawLineXY_XY(where, MyUniverse.Area.MyWorldXY, "WHITE"); // Erase the last line
                            MyUniverse.Area.MyInputScreenXY.b.Xx = e.X;
                            MyUniverse.Area.MyInputScreenXY.b.Yy = e.Y;
                            MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/path", where, MyUniverse.Area.MyInputScreenXY.a);
                            MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/path", where, MyUniverse.Area.MyInputScreenXY.b);
                            // MakePathOrthogonal(MyUniverse.Area)
                            MyDrawLineXY_XY(where, MyUniverse.Area.MyWorldXY, "errored");   // width should/can only be one 
                            break;
                        }

                        case object _ when MouseButtons.Right // Reserved for /Stroke
                            :
                        {
                            break;
                        }

                        case object _ when MouseButtons.Middle:
                        {
                            break;
                        }

                        case object _ when MouseButtons.None:
                        {
                            break;
                        }

                        case object _ when MouseButtons.XButton1:
                        {
                            break;
                        }

                        case object _ when MouseButtons.XButton1:
                        {
                            break;
                        }
                    }

                    break;
                }

                case "cmddelete":
                {
                    break;
                }

                case "cmdaddsymbol" // do nothing (We should be in the select symbol mode just before this
                    :
                {
                    break;
                }

                case "cmdaddpoint":
                {
                    break;
                }

                case "cmdaddline":
                {
                    break;
                }

                case "cmdmove":
                {
                    MyCmdModeString = MyCmdModeString;
                    break;
                }

                case null:
                case "":
                case "?":
                {
                    MyDrawLineXY_XY(where, MyUniverse.Area.MyWorldXY, "WHITE"); // Erase the last line
                    MyUniverse.Area.MyInputScreenXY.b.Xx = e.X;
                    MyUniverse.Area.MyInputScreenXY.b.Yy = e.Y;
                    MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(What, Where, MyUniverse.Area.MyInputScreenXY.a);
                    MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(What, Where, MyUniverse.Area.MyInputScreenXY.b);
                    MyDrawLineXY_XY(where, MyUniverse.Area.MyWorldXY, RandomColor()); // Erase the last line
                    break;
                }

                default:
                {
                    Abug(128, "MyMouseMove() : Error ", HighLight(MyCmdModeString), "Unknown Command Mode");
                    break;
                }
            }
        }


        void FlashLine_NotUsed(string  where, MyPointStructure NewXY)
        {
            MyLineStructure Temp;
            string What;
            if (where.Parent.Name == FlowChartScreen.Name)
                What = "/path";
            else
                What = "/line";
            Temp = MyUniverse.Area.MyWorldXY;
            MyDrawLineXY_XY(where, Temp, "WHITE"); // Erase the last line
            Temp.b = Copy2WorldXY(What, where, NewXY);
            MyDrawLineXY_XY(where, MyUniverse.Area.MyWorldXY, RandomColor()); // Erase the last line
        }

        // Routine This is the major routines to do everything the user wanted with the mouse button UP .
        void MyMouseUp(string  Where, MyPointStructure e)
        {
            long IndexNamed, IndexSymbol, IndexFlowChart;
            string TempDebug;
            MyPointStructure Temp;
            Temp = default(MyPointStructure);
            MyUniverse.Area.MyInputScreenXY.b.Xx = e.X; // Where the mouse button is up
            MyUniverse.Area.MyInputScreenXY.b.Yy = e.Y;

            // Convert the mouse down and mouse up to be in real world (vs screen world) numbers
            // This is now failing, and always returns -500,-500
            if (MyUniverse.SysGen.MinBox < MyUniverse.SysGen.Constants.constantMinBoxSize)
                MyUniverse.SysGen.MinBox = MyUniverse.SysGen.Constants.constantMinBoxSize;
            switch (Strings.LCase(Strings.Trim(MyCmdModeString)))
            {
            case "":
            case null:
            {
                break;
            }

            case "cmdmovehand":
            {
                Abug(799, MyUniverse.SysGen.MyFlowChartScale.ToString(), MyShowPoint(MyUniverse.Area.MyInputScreenXY.a) + Constants.vbTab + MyShowPoint(MyUniverse.Area.MyInputScreenXY.b.Xx), MyDistance(MyUniverse.Area.MyInputScreenXY.a, MyUniverse.Area.MyInputScreenXY.b));
                // Abug(799, MyUniverse.Area.MyInputScreenXY.a.Xx, MyUniverse.Area.MyInputScreenXY.b.Xx, (MyUniverse.Area.MyInputScreenXY.b.Xx - MyUniverse.Area.MyInputScreenXY.a.Xx) * MyUniverse.SysGen.MyFlowChartScale)
                Abug(799, MyUniverse.Area.MyInputScreenXY.a.Xx, MyUniverse.Area.MyInputScreenXY.b.Xx, (MyUniverse.Area.MyInputScreenXY.b.Xx - MyUniverse.Area.MyInputScreenXY.a.Xx) * MyUniverse.SysGen.MyFlowChartScale);
                Temp.Xx = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.Xx + (MyUniverse.Area.MyInputScreenXY.a.Xx - MyUniverse.Area.MyInputScreenXY.b.Xx) * 4; // * MyUniverse.SysGen.MyFlowChartScale
                Temp.Yy = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.Yy + (MyUniverse.Area.MyInputScreenXY.a.Yy - MyUniverse.Area.MyInputScreenXY.b.Yy) * 4; // * MyUniverse.SysGen.MyFlowChartScale
                Temp = Copy2WorldXY("/", FlowChartScreen.PictureBox1, Temp);

                // Reset to screen coord..
                MyUniverse.MyMouseAndDrawing.MyScrenZeroZero = Copy2ScreenXY(FlowChartScreen.PictureBox1, Temp);
                Temp = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero;  // hack to wach for debug
                PaintAll(Where, 1, TopOfFile("flowchart"));
                break;
            }

            case "cmdaddpath":
            {
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/path", Where, MyUniverse.Area.MyInputScreenXY.a); // Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/path", Where, MyUniverse.Area.MyInputScreenXY.b); // Mouse button up

                MyMakeArraySizesBigger();
                // Search for the closest point First and then connect it
                IndexFlowChart = NewFlowChartRecord();
                // FlowChart_TablePathName(IndexFlowChart , MakeNewName("Path1", 0))   'unnamed path
                if (Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) == 0)
                {
                    FlowChartScreen.ToolStripTextBoxMyInputText.Text = FindPathNameAtLine();
                    if (Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) == 0)
                    {
                        FlowChartScreen.ToolStripTextBoxMyInputText.Text = Interaction.InputBox("Enter the path name", "Unnamed path");
                        if (Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) == 0)
                        {
                            FlowChartScreen.ToolStripTextBoxMyInputText.Text = MakeNewName("Path", MyUniverse.MySS.Inputs.LineNumberIn, "AutoPath");
                            if (Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) == 0)
                            {
                                FlowChartScreen.ToolStripTextBoxMyInputText.Text = "Path Name Error";
                                Abug(800, "Failed to name a new path segment", "", FlowChartScreen.ToolStripTextBoxMyInputText.Text);
                            }
                        }
                    }
                }
                FlowChart_TablePathSymbolName(IndexFlowChart, FlowChartScreen.ToolStripTextBoxMyInputText.Text);

                FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte("/path").ToString());
                MyPathSnap(ref MyUniverse.Area.MyWorldXY, MyUniverse.Area.MyWorldXY);

                FlowChart_TableX1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.Xx);
                FlowChart_TableY1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.Yy);
                FlowChart_TableX2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.Xx);
                FlowChart_TableY2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.Yy);
                FlowChart_Table_DataType(IndexFlowChart, MyFlowChartNameSpace.F_C.MyUniverse.ProgramOptions.FlowChartTextBox); // No Information

                MakePathOrthogonal(IndexFlowChart);
                // Paint the original end of table record then 
                PaintAll(Where, IndexFlowChart - 1, IndexFlowChart + 1);
                // assume that MakePathOrthogonal adds a record at the end of the table, if not, still no harm? just slower
                PaintAll(Where, TopOfFile("FlowChart"), TopOfFile("FlowChart"));
                break;
            }

            case "cmdaddsymbol":
            {
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/use", Where, MyUniverse.Area.MyInputScreenXY.a); // Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/use", Where, MyUniverse.Area.MyInputScreenXY.b); // Mouse button up

                MyMakeArraySizesBigger();
                if (MyUniverse.ProgramOptions.SelectedSymbolName == "")
                {
                    ShowAllForms(HideScreen1, ShowScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1);
                    FlowChart_TablePathSymbolName(TopOfFile("FlowChart"), MakeNewName("UseA", 0, "UnknowSymbol" + VBMath.Rnd(1000)));
                    return;
                }
                else
                {
                }
                IndexFlowChart = NewFlowChartRecord(); // need to have a resort, for the last item added only
                FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte("/Use").ToString()); // KeyConstUse) '"/use")
                FlowChart_TablePathSymbolName(IndexFlowChart, MyUniverse.ProgramOptions.SelectedSymbolName); // 
                FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte("/uSe").ToString()); // KeyConstUse) '"/use")

                MyUniverse.Area.MyWorldXY.a = MySymbolSnap(MyUniverse.Area.MyWorldXY.a);
                MyUniverse.Area.MyWorldXY.b = MySymbolSnap(MyUniverse.Area.MyWorldXY.b);

                FlowChart_TableX1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.Xx);
                FlowChart_TableY1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.Yy);
                FlowChart_Table_Rotation(IndexFlowChart, MyUniverse.ProgramOptions.SelectedRotation); // Rotation is assumed to be none for now
                FlowChart_TableOption(IndexFlowChart, ""); // Future opotions

                CheckForAnySortNeeded("", 122); // hack
                ShowSorts("FlowChart", ReSortFlowChart(IndexFlowChart));
                CheckForAnySortNeeded("", 123); // hack
                PaintAll(Where, IndexFlowChart - 1, IndexFlowChart + 1);
                break;
            }

            case "cmdaddconstant":
            {
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/constant", Where, MyUniverse.Area.MyInputScreenXY.a); // Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/constant", Where, MyUniverse.Area.MyInputScreenXY.b); // Mouse button up

                MyMakeArraySizesBigger();

                IndexFlowChart = NewFlowChartRecord();
                FlowChart_TableCode(IndexFlowChart, "/constant");


                MyUniverse.Area.MyWorldXY.a = MyPointSnap(MyUniverse.Area.MyWorldXY.a);
                // Why am I snapping to grid the second XY??????? ' Hack need to sdee what I am doing here.
                MyUniverse.Area.MyWorldXY.b = MyPointSnap(MyUniverse.Area.MyWorldXY.b);

                FlowChart_TableX1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.Xx);
                FlowChart_TableY1(IndexFlowChart, MyUniverse.Area.MyWorldXY.a.Yy);
                FlowChart_Table_DataType(IndexFlowChart, MyUniverse.ProgramOptions.SelectedDataType);

                // I do not need another record!
                // IndexFlowChart = NewFlowChartRecord()
                FlowChart_TableX2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.Xx);
                FlowChart_TableY2(IndexFlowChart, MyUniverse.Area.MyWorldXY.b.Yy);

                PaintAll(Where, IndexFlowChart - 1, IndexFlowChart + 1);
                CheckForAnySortNeeded("", 124); // hack
                ShowSorts("FlowChart", ReSortFlowChart(IndexFlowChart)); // need to have a resort, for the last item added only
                CheckForAnySortNeeded("", 125); // hack
                break;
            }

            case "cmdaddline":
            {
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/line", Where, MyUniverse.Area.MyInputScreenXY.a); // Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/line", Where, MyUniverse.Area.MyInputScreenXY.b); // Mouse button up

                MyMakeArraySizesBigger();
                CheckForAnySortNeeded("", 126);
                ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, IndexNamed)); // 3/12/19
                IndexNamed = FindIndexIniSAMTable("Named", "add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, MyUniverse.ProgramOptions.SelectedSymbolName); // 
                if (IndexNamed < 1)
                    FindingMyBugs(10);// hace Least amount of checking here
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed);

                if (IndexSymbol == constantMyErrorCode)
                {
                    // Abug(129, MyCmdModeString, IndexSymbol, 0)
                    IndexSymbol = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                    FindingMyBugs(10); // hack Least amount of checking here
                    if (IndexSymbol < 1)
                    {
                        FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                                           // 
                        MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), MyUniverse.ProgramOptions.SelectedSymbolName, "/name", MyLine1(ZeroZero, ZeroZero), "");
                        FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                    }
                    else
                    {
                        FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                                           // 
                        MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), MyUniverse.ProgramOptions.SelectedSymbolName, "/line", MyUniverse.Area.MyWorldXY, "");
                        FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                    }
                    FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
                    FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                }
                else
                {
                    FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                    MyInsertSymbolLineRecord(IndexSymbol + 1, Named_TableSymbolName(IndexNamed), "/line", MyUniverse.Area.MyWorldXY, SymbolScreen.ToolStripDropDownButtonColor.ToString);
                    FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                }

                break;
            }

            case "cmdaddpoint" // Places a point on the symbol screen, NOT a symbol on the flowchart screen
                :
            {
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/point", Where, MyUniverse.Area.MyInputScreenXY.a); // Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/point", Where, MyUniverse.Area.MyInputScreenXY.b); // Mouse button up

                CheckForAnySortNeeded("", 130);
                ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, IndexNamed)); // 3/12/19
                IndexNamed = FindIndexIniSAMTable("Named", "add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, MyUniverse.ProgramOptions.SelectedSymbolName);
                FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed);
                FixSinTaxCode(IndexNamed);
                if (IndexSymbol <= 0)
                {
                    IndexSymbol = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                    if (IndexSymbol < 1)
                    {
                        // Add a missing name record to the table
                        FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                        MyInsertSymbolLineRecord(NewTopOfFile("Symbol"), Named_TableSymbolName(IndexNamed), "/name", MyUniverse.Area.MyWorldXY, "");
                        FindingMyBugs(10); // hack Least amount of checking here 2020 08 04
                        IndexSymbol = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                    }
                    else
                        FindingMyBugs(10);// hack Least amount of checking here
                }
                else
                {
                    FindingMyBugs(10); // hack Least amount of checking here
                    if (Symbol_TableCoded_String(IndexSymbol) != "/name")
                    {
                        F_C.GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                        FindingMyBugs(10); // hack Least amount of checking here
                    }
                }

                NumberOfGraphicsInASymbol(FindInSymbolList(ref MyUniverse.ProgramOptions.SelectedSymbolName), 0); // Get Symbol info only
                                                                                                                  // This makes sure that the names of the points, and the color of the lines are in the list box 
                TempDebug = MyUniverse.ProgramOptions.SelectedInputOutput;
                if (PrintAbleNull(TempDebug) == "_")
                    TempDebug = "Both";

                MyUniverse.Area.MyWorldXY.b.Xx = MyEnumValue(Pop(ref TempDebug, MyUniverse.SysGen.Constants.ConstantDelimeters), SymbolScreen.ToolStripDropDownInputOutput);

                TempDebug = MyUniverse.ProgramOptions.SelectedInputOutput;

                MyUniverse.Area.MyWorldXY.b.Xx = MyEnumValue(Pop(ref MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.SysGen.Constants.ConstantDelimeters), SymbolScreen.ToolStripDropDownInputOutput);
                MyUniverse.Area.MyWorldXY.b.Yy = FindIndexIniSAMTable("Datatype", "Donotadd", ref DataType_FileName, ref DataType_Name_iSAM, MyUniverse.ProgramOptions.SelectedDataType);
                FindingMyBugs(10); // hack Least amount of checking here 2020 08 04

                // todo bug in that this is not giving the correct name, and needs to be written
                MyInsertSymbolLineRecord(IndexSymbol + 1, MyUniverse.ProgramOptions.SelectedSymbolName, "/point", MyUniverse.Area.MyWorldXY, SymbolScreen.ComboBoxPointNameList.Text);


                FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
                FixSinTaxCode(IndexNamed);
                FindingMyBugs(10);// hack Least amount of checking here 2020 08 04
                break;
            }

            case "cmdmove":
            {
                MyCmdMove(Where);
                FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
                break;
            }

            case "cmddelete":
            {
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY("/", Where, MyUniverse.Area.MyInputScreenXY.a); // Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY("/", Where, MyUniverse.Area.MyInputScreenXY.b); // Mouse button up
                switch (Where.Parent.Name)
                {
                case "FlowChartScreen":
                {
                    MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(Where, MyUniverse.Area.MyWorldXY.a, 0);
                    PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject);
                    FlowChart_TableCode(MyUniverse.ProgramOptions.SelectedObject, "/delete"); // Delete Mark Only
                                                                                              // We should be turning off the item
                    PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject - 1, MyUniverse.ProgramOptions.SelectedObject + 1);
                    break;
                }

                case "SymbolScreen":
                {
                    MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(Where, MyUniverse.Area.MyWorldXY.a, 0);
                    // PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject)
                    Symbol_TableCode(MyUniverse.ProgramOptions.SelectedObject, "/delete"); // Delete Mark Only
                    FindingMyBugs(10); // hack Least amount of checking here
                    CheckForAnySortNeeded("", 134);
                    IndexNamed = FindIndexIniSAMTable("Named", "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, MyUniverse.ProgramOptions.SelectedSymbolName); // 
                    CheckForAnySortNeeded("", 135);
                    if (IndexFlowChart == constantMyErrorCode)
                    {
                    }
                    else
                    {
                        // Named_TableSymbolIndexes( IndexFlowChart , 0) ' Delete the old Indexes (for now)
                        IndexFlowChart = GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                        Clear_Screen(Where);
                    }
                    // IndexFlowChart  = MyUniverse.SysGen.Constants.constantSymbolCenter + MyUniverse.SysGen.Constants.constantSymbolCenter
                    PaintEach(SymbolScreen.PictureBox1, MyPoint1XY(MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter), MyUniverse.ProgramOptions.SelectedSymbolName, "Default");// 
                    break;
                }

                case "OptionScreen":
                {
                    break;
                }
                }

                break;
            }

            default:
            {
                MyMsgCtr(1283, "MyMouseUp", MyCmdModeString, "", "", "", "", "", "", "", "");
                break;
            }
            }
            FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
            FindingMyBugs(10);
        }



        void MyCmdMove(string Where)
        {
            switch (Where)
            {
            case "FlowChartScreen":
            {
                // Get the closest object (/path could be either end of the path)
                MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(Where, MyUniverse.Area.MyWorldXY.a, 0);
                // We should flash this object 
                if (MyUniverse.ProgramOptions.SelectedObject != constantMyErrorCode)
                {
                    PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject);
                    switch (FlowChart_TableCode(MyUniverse.ProgramOptions.SelectedObject))
                    {
                    case "/path":
                    {
                        // need to find the closest end to change
                        MyUniverse.Area.MyWorldXY = MySnapIndex(MyUniverse.ProgramOptions.SelectedObject);
                        if (MyABS(MyUniverse.Area.MyWorldXY.a.Xx - FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.Yy - FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject)) > MyABS(MyUniverse.Area.MyWorldXY.a.Xx - FlowChart_TableX2(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.Yy - FlowChart_TableY2(MyUniverse.ProgramOptions.SelectedObject)))
                        {
                            PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject);

                            FlowChart_TableX2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Xx);
                            FlowChart_TableY2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Yy);
                        }
                        else
                        {
                            PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject);
                            FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Xx);
                            FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Yy);
                        }

                        break;
                    }

                    case "/use":
                    {
                        MoveSymbolAndAllPaths(Where, MyUniverse.ProgramOptions.SelectedObject, MyPoint1XY(MyUniverse.Area.MyWorldXY.b.Xx - MyUniverse.Area.MyWorldXY.a.Xx, MyUniverse.Area.MyWorldXY.b.Yy - MyUniverse.Area.MyWorldXY.a.Yy));
                        break;
                    }

                    case "/constant":
                    {
                        PaintErase(Where, MyUniverse.ProgramOptions.SelectedObject);
                        MyUniverse.Area.MyWorldXY.b = MyPointSnap(MyUniverse.Area.MyWorldXY.b);
                        FlowChart_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Xx);
                        FlowChart_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Yy);
                        break;
                    }

                    default:
                    {
                        Abug(131, "Didnt move this item", Strings.LCase(Strings.Trim(FlowChart_TableCode(MyUniverse.ProgramOptions.SelectedObject))), "");
                        break;
                    }
                    }

                    // redisplay 1 (We should be turning off the old location)
                    PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject);
                }
                else
                {
                    PaintAll(Where, 1, TopOfFile("FlowChart"));
                    Abug(132, "invalid movement attempted ", "could not find selected object", MyShowLine(MyUniverse.Area.MyWorldXY));
                }

                break;
            }

            case "SymbolScreen" // Move
                :
            {
                // Get the closest object (/path could be either end of the path)
                MyUniverse.ProgramOptions.SelectedObject = MyFindSymbolPoint(MyUniverse.Area.MyWorldXY.a, MyUniverse.ProgramOptions.SelectedSymbolName); // 
                                                                                                                                                         // We should flash this object 
                                                                                                                                                         // PaintAll(FlowChartScreen.PictureBox1, MyStaticData.SelectedObject, MyStaticData.SelectedObject)
                switch (Symbol_TableCoded_String(MyUniverse.ProgramOptions.SelectedObject))
                {
                case "/line":
                {
                    FindingMyBugs(10); // hack Least amount of checking here
                                       // need to find the closest end to change
                    if (MyABS(MyUniverse.Area.MyWorldXY.a.Xx - Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.Yy - Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject)) > MyABS(MyUniverse.Area.MyWorldXY.a.Xx - Symbol_TableX2(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.Yy - Symbol_TableY2(MyUniverse.ProgramOptions.SelectedObject)))
                    {
                        Symbol_TableX2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Xx);
                        Symbol_TableY2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Yy);
                    }
                    else
                    {
                        Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Xx);
                        Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Yy);
                    }

                    break;
                }

                case "/point":
                {
                    FindingMyBugs(10); // hack Least amount of checking here
                                       // move to where the mouse button let up
                    Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Xx);
                    Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.Yy);
                    break;
                }

                default:
                {
                    Abug(133, "did not move ", Symbol_TableCoded_String(MyUniverse.ProgramOptions.SelectedObject), "");
                    break;
                }
                }
                // redisplay 1 (We should be turning off the old location)
                PaintAll(Where, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject);
                break;
            }
            }
        }


        // Gives the Indexes to the data
        long FindiSAM_IN_Table(string MyTable, string Myfunction, string MyArray[],long iSAM[], string WhatToFind)
        {
            if (MyCompared1_a(MyUniverse.MyCheatSheet.LastString, WhatToFind) == 0)
            {
                if (MyUniverse.MyCheatSheet.LastIndex < Information.UBound(MyArray) & MyUniverse.MyCheatSheet.LastIndex > 0)
                {
                    if (MyCompared1_a(MyArray[MyUniverse.MyCheatSheet.LastIndex], WhatToFind) == 0)
                        // A I N F O 2 (8)
                        return MyUniverse.MyCheatSheet.LastIndex;
                }
            }
            CheckForAnySortNeeded("", 136);
            FindiSAM_IN_Table = FindIndexIniSAMTable(MyTable, Myfunction, ref MyArray, ref iSAM, WhatToFind);
            CheckForAnySortNeeded("", 137);
            if (FindiSAM_IN_Table == constantMyErrorCode)
                FindingMyBugs(10); // hace Least amount of checking here
            else
                FindiSAM_IN_Table = iSAM[MyMinMax(FindiSAM_IN_Table, 1, Information.UBound(MyArray))];
        }



        // Gives the Indexes to the data
        long FindiSAM_IN_Table(string MyTable, string Myfunction, long MyArrayLong[],long iSAM[], long WhatToFind)
        {
            long I;
            CheckForAnySortNeeded("", 138);
            I = FindIndexIniSAMTable(MyTable, ref Myfunction, ref MyArrayLong, ref iSAM, ref WhatToFind);
            CheckForAnySortNeeded("", 139);
            if (I == constantMyErrorCode)
            {
                Abug(134, MyTable, Myfunction, 0);
                FindiSAM_IN_Table = I;
            }
            else
                FindiSAM_IN_Table = iSAM[MyMinMax(I, 1, Information.UBound(MyArrayLong))];
        }



        void SelectInToolStripDropDownButton(ToolStripDropDownButton CB, string WhatToSelect)
        {
            long I;
            if (Information.IsNothing(WhatToSelect))
                return;
            // CB.DropDownItems.Find(WhatToSelect, True) ' undone not sure if this will work yet
            if (CB.DropDownItems.Count < 1)
                return;
            for (I = 0; I <= CB.DropDownItems.Count - 1; I++)
            {
                if (CB.DropDownItems(I).Text == WhatToSelect)
                {
                    CB.DropDownItems(I).Select();
                    CB.Text = WhatToSelect;
                    return;
                }
                if (Left(CB.DropDownItems(I).Text, Strings.Len(WhatToSelect + FD)) == WhatToSelect + FD)
                {
                    CB.DropDownItems(I).Select();
                    CB.Text = WhatToSelect;
                    return;
                }
            }
            Abug(135, "Unable to find the selection ", WhatToSelect, CB.Name);
        }


        // ***********************************************************************
        // checking that the symbol name is not already in the symbol table
        long CheckNotInList(string MyTable, string MyFunction, string MyArray[], long iSAM[], string SymbolName)
        {
            long Idex;
            for (Idex = 1; Idex <= TopOfFile(MyTable); Idex++)
            {
                switch (MyCompared3(MyArray[Idex], SymbolName, MyArray[Idex]))
                {
                case -5:
                {
                    break;
                }

                case -4:
                {
                    break;
                }

                case -3:
                {
                    break;
                }

                case -2:
                {
                    break;
                }

                case -1 // a=b
                    :
                {
                    // ainfo2(10)
                    return Idex;
                }

                case -0:
                {
                    break;
                }

                case 1 // b=c
                    :
                {
                    // A I N F O 2 (9)
                    return Idex;
                }

                case 2:
                {
                    break;
                }

                case 3:
                {
                    break;
                }

                case 4:
                {
                    break;
                }

                case 5:
                {
                    break;
                }
                }
            }
            CheckNotInList = constantMyErrorCode;  // Still Not Found 
        }


        // *******************************************
        // returns the Indexes to the index of the iSAM 
        long FindIndexIniSAMTable(string MyTable, string MyFunction, string MyArray[], long iSAM[], string WhatToFind)
        {
            // Follow IDEX it is using the top of file twice
            // ************************* This needs to be changed to a binary search instead of a=going through all of the list
            long Jdex, Kdex, Idex;
            long ErrorCount;
            if (Strings.Trim(WhatToFind) == "")
                return constantMyErrorCode;


            // 20200711 updated cheat 
            // If what you want to find is already found last time and so check if you do not have to find it again
            if (Strings.LCase(Strings.Trim(MyTable)) == Strings.LCase(Strings.Trim(MyUniverse.MyCheatSheet.LastiSAMStringTable)))
            {
                if (MyCompared1_a(MyUniverse.MyCheatSheet.LastiSAMStringString, WhatToFind) == 0)
                {
                    if (MyUniverse.MyCheatSheet.LastiSAMStringIndex <= TopOfFile(MyTable))
                        // A I N F O 2 (-40)
                        return MyUniverse.MyCheatSheet.LastiSAMStringIndex;
                }
            }

            // Now do binary search for it
            Kdex = TopOfFile(MyTable);

            Idex = MyMinMax(System.Convert.Tolong(Kdex / (double)2), 1, Kdex);
            Jdex = MyMinMax(System.Convert.Tolong(Idex / (double)2), 1, Kdex);

            ErrorCount = 2048;


            while (ErrorCount > 0)
            {
                ErrorCount -= 1;
                // Need test when to exit while
                Idex = MyMinMax(Idex, 1, Kdex);
                // AInfo(9 9 9 , MyCompared3(MyArray(iSAM(Idex)), WhatToFind, MyArray(iSAM(Idex + 1))), vbCrLf & MyArray(iSAM(Idex)) & vbCrLf & WhatToFind & vbCrLf & MyArray(iSAM(Idex + 1)), "")
                switch (MyCompared3(MyArray[iSAM[Idex]], WhatToFind, MyArray[iSAM[Idex + 1]]))
                {
                    case -5 // -5 A is not <= than C (A>C) Error
                        :
                    {
                        Abug(136, MyArray[iSAM[Idex]], WhatToFind, MyArray[iSAM[Idex + 1]]);
                        ShowSorts(MyTable, MyReSort(MyTable, ref MyArray, ref iSAM, Idex));
                        ShowSorts(MyTable, MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1));
                        ShowSorts(MyTable, MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1));
                        // A I N F O 2 (12)
                        return FindIndexIniSAMTable(MyTable, MyFunction, ref MyArray, ref iSAM, WhatToFind);
                    }

                    case -4 // -4 A = start Of list (So Lowest)
                        :
                    {
                        // When it should be before a list of the same thing.

                        while (MyCompared3(MyArray[iSAM[Idex]], WhatToFind, MyArray[iSAM[Idex + 1]]) == -4)
                        {
                            // AInfo1( 9 9 9 ,  MyCompared3(MyArray(iSAM(Idex)), WhatToFind, MyArray(iSAM(Idex + 1))), vbCrLf & MyArray(iSAM(Idex)) & vbCrLf & WhatToFind & vbCrLf & MyArray(iSAM(Idex + 1)), "")
                            Idex -= 1;
                            if (Idex == 1)
                            {
                                Idex = Kdex;
                                break;
                            }
                        }
                        if (Idex == 1)
                        {
                            Idex = Kdex;
                            break;
                        }
                        Idex = MyMinMax(Idex + 1, 1, Kdex);
                        break;
                    }

                    case -3 // -3 A is higher than B  
                        :
                    {
                        if (Idex == 1)
                        {
                            Idex = Kdex;
                            break; // In case what we want is before the beggining
                        }
                        Idex = MyMinMax(Idex - Jdex, 1, Kdex);
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case -2 // -2 B is higher than C ' So you have to look forwards 
                        :
                    {
                        Idex = MyMinMax(Idex + Jdex, 1, Kdex);
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case -1  // -1 is equal to A and 0 is between A and C
                        :
                    {
                        MyUniverse.MyCheatSheet.LastiSAMStringTable = MyTable;
                        MyUniverse.MyCheatSheet.LastiSAMStringString = WhatToFind;
                        MyUniverse.MyCheatSheet.LastiSAMStringIndex = iSAM[Idex];
                        // 'A I N F O 2 (-39)
                        return iSAM[Idex];
                    }

                    case 0 // test 2 & 10 A and C = nothing or A<b<C should be between these two
                        :
                    {
                        // binary search is failing here, but check it is not in list is finding it ERROR 'hack
                        // This is all extra code
                        FindIndexIniSAMTable = CheckNotInList(MyTable, ref MyFunction, ref MyArray, ref iSAM, ref WhatToFind);
                        if (FindIndexIniSAMTable == constantMyErrorCode)
                            // AInfo1( 9 9 9 ,  MyArray(iSAM(Idex)), WhatToFind, MyArray(iSAM(Idex + 1)))
                            break;
                        else
                        {
                            // AInfo(9 9 9 ,  MyArray(iSAM(FindIndexIniSAMTable)), WhatToFind, MyArray(iSAM(FindIndexIniSAMTable + 1)))
                            AInfo1(774, "binary search Found Item", WhatToFind, MyArray[FindIndexIniSAMTable]);
                            MyUniverse.MyCheatSheet.LastiSAMStringTable = MyTable;
                            MyUniverse.MyCheatSheet.LastiSAMStringString = WhatToFind;
                            MyUniverse.MyCheatSheet.LastiSAMStringIndex = FindIndexIniSAMTable;
                            return FindIndexIniSAMTable;
                        }

                        break;
                    }

                    case 1 // 1 B = C
                        :
                    {
                        Idex = MyMinMax(Idex + 1, 1, Kdex); // forward on so that you have what you found the one before
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case 2 // 2 A is lower than B 
                        :
                    {
                        Idex = MyMinMax(Idex + Jdex, 1, Kdex); // back up one
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case 3 // 3 Or C is higher then B
                        :
                    {
                        Idex = MyMinMax(Idex - Jdex, 1, Kdex); // back up one
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case 4 // 4 C is the end of the list (So Highest) [ Found this to not be true when B>A and C=nothing ]  and B > A 
                        :
                    {
                        Idex += 1; // To point the the end of the list
                        if (MyArray[iSAM[Idex]] > WhatToFind)
                            Abug(138, "Program data error!!! An invalid assumption because the list is not sorted correctly", PrintAbleNull(MyArray[iSAM[Idex]]) + " : " + PrintAbleNull(WhatToFind + " : " + MyArray[iSAM[Idex + 1]]), 0);
                        break; // Insert it at the end if "Add"
                        break;
                    }

                    case 5 // 5 Error (unknown relationship)
                        :
                    {
                        Abug(139, MyTable, MyFunction, 0);
                        return NewTopOfFile(MyTable);
                    }
                }
            }
            if (WhatToFind == "_" | WhatToFind == "" | Information.IsNothing(WhatToFind))
                // A I N F O 2 (14)
                return constantMyErrorCode;

            if (Strings.LCase(Strings.Trim(MyFunction)) == "add")
            {
                Idex = MyMinMax(Idex, 1, NewTopOfFile(MyTable));
                if (MyCompared1_a(MyArray[Idex], WhatToFind) == 0)
                {
                    CheckThisStringArray(6, ref MyArray, ref iSAM, Idex);
                    // A I N F O 2 (23)
                    return Idex; // 3/13/19 Should return the one found
                }


                // 20200625 Below fixes a issues' of adding something where there is something already.
                Idex = NewTopOfFile(MyTable);
                while (!Information.IsNothing(MyArray[Idex]))
                    Idex += 1;

                MyArray[Idex] = WhatToFind;
                iSAM[Idex] = Idex;
                ShowSorts(MyTable, MyReSort(MyTable, ref MyArray, ref iSAM, Idex)); // sorted
                switch (Strings.LCase(MyTable))// 220200711 changed to resort instead of flagging to resort it all
                {
                case "color":
                {
                    ShowSorts("Color", MyReSort("Color", ref Color_FileName, ref Color_Name_iSAM, Idex)); // Try to only sort the one added
                    break;
                }

                case "datatype":
                {
                    ShowSorts("DataType", MyReSort("DataType", ref DataType_FileName, ref DataType_Name_iSAM, Idex));
                    break;
                }

                case "named":
                {
                    ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, Idex));
                    break;
                }

                case "FlowChart":
                {
                    ReSortFlowChart(Idex);
                    break;
                }

                default:
                {
                    ShowSorts("Color", MyReSort("Color", ref Color_FileName, ref Color_Name_iSAM, Idex)); // Try to only sort the one added
                    ShowSorts("DataType", MyReSort("DataType", ref DataType_FileName, ref DataType_Name_iSAM, Idex));
                    ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, Idex));
                    ShowSorts("Named", MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, Idex));
                    ReSortFlowChart(Idex);
                    break;
                }
                }
                FindIndexIniSAMTable = Idex;
            }
            else
            {
                FindIndexIniSAMTable = CheckNotInList(MyTable, ref MyFunction, ref MyArray, ref iSAM, ref WhatToFind);
                if (FindIndexIniSAMTable <= 0)
                    FindIndexIniSAMTable = constantMyErrorCode;
                else
                {
                }
            }
        }

        // ***********************************************************************************
        // Find the  string name in the array of names (table listed for referance only)
        long FindInSortedLanguageList(string MyTable, string WhatToFind, string MyArray[])
        {
            long Jdex, Kdex, MaxDex, MinDex, MyErrors;
            // Never search for no name
            if (Strings.Trim(WhatToFind) == "" | Information.IsNothing(WhatToFind))
                // A I N F O 2 (15)
                return constantMyErrorCode;
            MyErrors = 1024;  // This is only to avoid looping for ever if there is a issues'
            Kdex = Information.UBound(MyArray); // Get the top of the array
            FindInSortedLanguageList = MyMinMax(System.Convert.Tolong(Kdex / (double)2), 1, Kdex);    // The current location of this name 
            Jdex = MyMinMax(System.Convert.Tolong(FindInSortedLanguageList / (double)2), 1, Kdex);    // How much to move up or down the list

            // This is to avoid a repeat search of the same thing. Os I check and save the last one that was found, and reuse it again
            if (MyUniverse.MyCheatSheet.LastLanguageTable == MyTable)
            {
                if (MyUniverse.MyCheatSheet.LastLanguageString == WhatToFind)
                {
                    FindInSortedLanguageList = MyUniverse.MyCheatSheet.LastLanguageIndex;
                    if (FindInSortedLanguageList > Information.UBound(MyArray))
                    {
                        Abug(141, "Index outside the boundries Array ", FindInSortedLanguageList, Information.UBound(MyArray));
                        FindInSortedLanguageList = Information.UBound(MyArray);
                    }
                    // A I N F O 2 (16)
                    return FindInSortedLanguageList;
                }
            }


            while (MyErrors > 0) // just to avoid a loop forever
            {
                MyErrors -= 1; // Can only loop X number of times.
                FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList, 1, Kdex);
                MaxDex = MyMinMax(FindInSortedLanguageList + 1, 1, Kdex);
                MinDex = MyMinMax(FindInSortedLanguageList, 1, Kdex);
                FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList, 1, Kdex); // 2020 09 25

                // If MinDex = MaxDex Then
                // BUG min and max get set to be the same
                // End If
                switch (MyCompared3(MyArray[MinDex], WhatToFind, MyArray[MaxDex]))
                {
                    case -5 // -5 A is not <= than C (A>C) Error
                        :
                    {
                        Abug(142, "FindInSortedLanguageList()", "Sorting bug somewhere else", FindInSortedLanguageList);
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, MinDex));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, FindInSortedLanguageList));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, MaxDex));
                        FindInSortedLanguageList = constantMyErrorCode;
                        if (FindInSortedLanguageList > Information.UBound(MyArray))
                        {
                            Abug(143, "Index outside the boundries Array ", FindInSortedLanguageList, Information.UBound(MyArray));
                            FindInSortedLanguageList = Information.UBound(MyArray);
                        }
                        // A I N F O 2 (17)
                        return FindInSortedLanguageList;
                    }

                    case -4 // -4 A = start Of list (So Lowest)
                        :
                    {
                        if (Jdex == 1)
                        {
                            FindInSortedLanguageList = Kdex;
                            break;
                        }
                        if (MinDex == MaxDex & FindInSortedLanguageList > 1)
                            FindInSortedLanguageList -= 2;// hack // hack
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + 1, 1, Kdex);
                        break;
                    }

                    case -3 // -3 A is higher than B  
                        :
                    {
                        if (FindInSortedLanguageList == 1)
                        {
                            // ? Why the end of the list instead of the beggining of the list, 
                            // because A > B, so we should return 1 or not found
                            FindInSortedLanguageList = Kdex;
                            break; // In case what we want is before the beggining
                        }
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - Jdex, 1, Kdex);
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case -2 // -2 B is higher than C ' So you have to look forwards 
                        :
                    {
                        if (FindInSortedLanguageList >= Kdex & Jdex == 1)
                            break;// This is then at the end of the list
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + Jdex, 1, Kdex);
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case -1  // -1 is equal to A and 0 is between A and C
                        :
                    {
                        MyUniverse.MyCheatSheet.LastLanguageTable = MyTable;
                        MyUniverse.MyCheatSheet.LastLanguageString = WhatToFind;
                        MyUniverse.MyCheatSheet.LastLanguageIndex = FindInSortedLanguageList;
                        if (FindInSortedLanguageList > Information.UBound(MyArray))
                        {
                            Abug(144, "Index outside the boundries Array ", FindInSortedLanguageList, Information.UBound(MyArray));
                            FindInSortedLanguageList = Information.UBound(MyArray);
                        }
                        // A I N F O 2 (-18)
                        return FindInSortedLanguageList;
                    }

                    case 0 // test 2 & 10 A and C = nothing or A<b<C should be between these two
                        :
                    {
                        // resetting it to tray again
                        if (MinDex == MaxDex)
                        {
                            if (MinDex == MaxDex)
                            {
                                if (MinDex == 1)
                                {
                                    if (MyArray[MinDex] == null)
                                        // A I N F O 2 (-42)
                                        return constantMyErrorCode;// start of the list, it should have return this already
                                    if (MyArray[MaxDex] == null)
                                    {
                                        AInfo(607, "error can not find in search " + MinDex + " : " + HighLight(MyArray[MinDex]) + HighLight(WhatToFind) + MaxDex + " : " + HighLight(MyArray[MaxDex]), "", "");
                                        return constantMyErrorCode;
                                    }
                                }
                                if (MyArray[MinDex] > WhatToFind)
                                    // Abug(145, "error can not find in search " & MinDex & " : " & HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & MaxDex & " : " & HighLight(MyArray(MaxDex)), "", "")
                                    return constantMyErrorCode;
                                if (MaxDex == MinDex)
                                {
                                    if (MyArray[MaxDex] <= WhatToFind)
                                        // A I N F O 2 (46)
                                        return 4;// This is past the end of the file.
                                                 // Abug(146, "error can not find in search " & MinDex & " : " & HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & MaxDex & " : " & HighLight(MyArray(MaxDex)), MinDex & vbCrLf & WhatToFind & vbCrLf & MaxDex, "")
                                    return constantMyErrorCode;
                                }
                                else
                                {
                                    // if the min and max is differnet then they must be between them , or else something else, so lets find out
                                    if (MinDex > MaxDex)
                                    {
                                        Abug(147, "The search is faulty " + MyTable + " is out of order Report internal bug 7", MinDex, MaxDex);
                                        return constantMyErrorCode;
                                    }
                                    if (MyArray[MinDex] >= MyArray[MaxDex])
                                    {
                                        Abug(148, "The list " + MyTable + " is out of order and needs to be sorted - Internal error 7", MyArray[MinDex], MyArray[MaxDex]);
                                        return constantMyErrorCode;
                                    }
                                }
                            }
                            else
                            {
                                if (MaxDex > 1)
                                {
                                    if (WhatToFind != MyArray[MinDex])
                                        // A I N F O 2 (44)
                                        return -5;// end of the file
                                                  // A I N F O 2 (45)
                                    return -6; // issues'
                                }
                                // ? Is this needed?
                                FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - Jdex, 1, Kdex); // hack
                            }
                        }
                        FindInSortedLanguageList = constantMyErrorCode; // Means that it is not found where it should be at.
                        break;
                        break;
                    }

                    case 1 // 1 B = C
                        :
                    {
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + 1, 1, Kdex); // forward on so that you have what you found the one before' 2020 09 07
                        Jdex = 1;// MyMinMax(cint(Jdex / 2), 1, Kdex) 2020 09 07
                        break;
                    }

                    case 2 // 2 A is lower than B 
                        :
                    {
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList + Jdex, 1, Kdex); // back up one
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case 3 // 3 Or C is higher then B
                        :
                    {
                        FindInSortedLanguageList = MyMinMax(FindInSortedLanguageList - Jdex, 1, Kdex); // back up one
                        Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                        break;
                    }

                    case 4 // 4 C is the end of the list (So Highest) and B > A 
                        :
                    {
                        // 2020 09 07 added if it is the last one in the list
                        // If IsNothing(MyArray(MaxDex)) Then 'extra
                        // If MyArray(MinDex) > WhatToFind Then
                        // Abug(151, "The comparing at the end of a list is wrong", HighLight(MyArray(MinDex)) & HighLight(WhatToFind) & HighLight(MyArray(MaxDex)), "")
                        // End If 'extra
                        // End If 'extra
                        if (MinDex == MaxDex & FindInSortedLanguageList > 2)
                            FindInSortedLanguageList -= 2;// hack // hack
                        if (MyArray[FindInSortedLanguageList] == WhatToFind)
                        {
                            MyUniverse.MyCheatSheet.LastLanguageTable = MyTable;
                            MyUniverse.MyCheatSheet.LastLanguageString = WhatToFind;
                            MyUniverse.MyCheatSheet.LastLanguageIndex = FindInSortedLanguageList;
                            if (FindInSortedLanguageList > Information.UBound(MyArray))
                            {
                                Abug(152, "Index outside the boundries Array ", FindInSortedLanguageList, Information.UBound(MyArray));
                                FindInSortedLanguageList = Information.UBound(MyArray);
                            }
                            return FindInSortedLanguageList;
                        }
                        FindInSortedLanguageList += 1; // To point the the end of the list
                        break; // Insert it at the end if "Add"
                        break;
                    }

                    case 5 // 5 Error (unknown relationship)
                        :
                    {
                        if (Information.IsNothing(WhatToFind))
                            break;
                        if (Strings.Trim(WhatToFind) == "")
                            break;
                        if (WhatToFind == FD)
                            break;
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, MinDex));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, FindInSortedLanguageList));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, MaxDex));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, Information.UBound(MyArray) - 2));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, Information.UBound(MyArray) - 1));
                        ShowSorts("LanguagekeyWord", ReSortLanguagekeyWord("LanguagekeyWord", ref MyArray, Information.UBound(MyArray)));
                        FindInSortedLanguageList = Information.UBound(MyArray);
                        if (FindInSortedLanguageList > Information.UBound(MyArray))
                        {
                            Abug(153, "Index outside the boundries Array ", FindInSortedLanguageList, Information.UBound(MyArray));
                            FindInSortedLanguageList = Information.UBound(MyArray);
                        }
                        // A I N F O 2 (21)
                        return FindInSortedLanguageList;
                    }
                }
            }
        }



        // *******************************************
        // Gives the Indexes to the index of the iSAM 
        long FindIndexIniSAMTable(string MyTable, string MyFunction, long MyArrayLong[], long iSAM[], long WhatToFind)
        {
            // ************************* This needs to be changed to a binary search instead of a=going through all of the list
            long Index, J, Kdex;


            Kdex = MyMinMax(TopOfFile(MyTable), 1, TopOfFile(MyTable)); // 3/15/19 Removed +1  to the index
            Index = MyMinMax(Index, 1, Kdex);
            J = System.Convert.Tolong(Index / (double)2);
            if (Information.IsNothing(MyArrayLong[1]))
            {
            }
            else
            {

                // This does no good if I do not set them on finding a match last time
                if (MyUniverse.MyCheatSheet.LastiSAMNumberTable == MyTable)
                {
                    if (MyCompared1(MyUniverse.MyCheatSheet.LastiSAMNumberNumber, WhatToFind) == 0)
                    {
                        if (MyUniverse.MyCheatSheet.LastiSAMNumberIndex <= Kdex)
                        {
                            if (MyArrayLong[iSAM[MyUniverse.MyCheatSheet.LastiSAMNumberIndex]] == WhatToFind)
                                // A I N F O 2 (49)
                                return iSAM[MyUniverse.MyCheatSheet.LastiSAMNumberIndex];
                        }
                    }
                }
                while (1 == 1) // Forever loop
                {
                    mydoevents();
                    if (MyCompared2(ref MyArrayLong, ref iSAM, Index - 1, Index) == 1 & MyCompared2(ref MyArrayLong, ref iSAM, Index, Index + 1) == -1)
                    {
                        // The MyArrayLong is not in the correct order
                        CheckForAnySortNeeded("", 144); // hack
                        ShowSorts(MyTable, MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, MyMinMax(Index - 1, 1, Kdex)));
                        ShowSorts(MyTable, MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, MyMinMax(Index, 1, Kdex)));
                        ShowSorts(MyTable, MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, MyMinMax(Index + 1, 1, Kdex)));
                        CheckForAnySortNeeded("", 145); // hack
                    }

                    if (MyCompared1(MyArrayLong[iSAM[Index]], WhatToFind) < 0 & MyCompared1(MyArrayLong[iSAM[Index + 1]], WhatToFind) > 0)
                        // FindIndexIniSAMTable = Index
                        break;

                    switch (MyCompared1(MyArrayLong[iSAM[Index]], WhatToFind))
                    {
                    case -3:
                    {
                        Index += J;
                        break;
                    }

                    case -2:
                    {
                        Index += J;
                        break;
                    }

                    case -1:
                    {
                        Index += J;
                        break;
                    }

                    case 0 // Match so return
                        :
                    {
                        while (Index > 0 & MyArrayLong[Index] == WhatToFind)
                            Index -= 1;
                        // FindIndexIniSAMTable = Index
                        MyUniverse.MyCheatSheet.LastiSAMNumberTable = MyTable;
                        MyUniverse.MyCheatSheet.LastiSAMNumberNumber = WhatToFind;
                        MyUniverse.MyCheatSheet.LastiSAMNumberIndex = Index;
                        // A I N F O 2 (50)
                        return iSAM[MyUniverse.MyCheatSheet.LastiSAMNumberIndex];
                    }

                    case 1:
                    {
                        Index -= J;
                        break;
                    }

                    case 2:
                    {
                        Index -= J;
                        break;
                    }

                    case 3:
                    {
                        Index -= J;
                        break;
                    }

                    default:
                    {
                        Index += J;
                        break;
                    }
                    }
                    if (Index > Kdex & J == 1)
                        // J = 0
                        break;

                    // This return the negitive if between
                    if (Index < 1)
                    {
                        if (MyCompared1(MyArrayLong[iSAM[1]], WhatToFind) == 1)
                        {
                            // J = 0
                            Index = -Index;
                            break;
                        }
                    }
                    Index = MyMinMax(Index, 1, Kdex);
                    if (Index == 1)
                    {
                        if (MyCompared1(MyArrayLong[iSAM[1]], WhatToFind) == 1)
                        {
                            Index = constantMyErrorCode;
                            break;
                        }
                    }
                    if (iSAM[Index] != 0)
                    {
                        if (J == 1)
                        {
                            if (MyCompared1(MyArrayLong[iSAM[Index]], WhatToFind) == -1)
                            {
                                if (MyCompared1(MyArrayLong[iSAM[MyMinMax(Index + 1, 1, Kdex)]], WhatToFind) >= 1)
                                    // J = 0
                                    break;
                            }
                        }
                    }
                    J = MyMinMax(System.Convert.Tolong(J / (double)2), 1, Kdex);
                }
            }

            if (Strings.LCase(MyFunction) == "add")
            {
                FindingMyBugs(10); // hace Least amount of checking here
                // ******* hack becase I still have a bug keeping the MyArray sorted.
                // Last attempt to find be3cause I've got a bug
                for (Index = 1; Index <= Information.UBound(MyArrayLong); Index++)
                {
                    if (MyCompared1(MyArrayLong[Index], WhatToFind) == 0)
                    {
                        MyMsgCtr(1215, "FindIndexIniSAMTable", MyArrayLong[Index].ToString(), WhatToFind.ToString(), "", "", "", "", "", "", "");
                        SortALLiSAM(); // Resort everything 
                        FindingMyBugs(10); // hace Least amount of checking here
                        // A I N F O 2 (22)
                        return Index;
                    }
                }
                // If the above fails then try a SLOW loop of everything
                // ******** End of hack 

                Index = TopOfFile(MyTable);
                if (Information.IsNothing(MyArrayLong[Index]))
                {
                }
                else
                    Index += 1;


                FindingMyBugs(10); // hace Least amount of checking here
                MyArrayLong[Index] = WhatToFind;
                FindIndexIniSAMTable = Index;
                iSAM[Index] = Index;
                CheckForAnySortNeeded("", 148); // hack
                ShowSorts(MyTable, MyReSort(MyTable, ref MyArrayLong, ref iSAM, Index));
                CheckForAnySortNeeded("", 149); // hack
            }
            else
                FindIndexIniSAMTable = Index - 1;
            FindingMyBugs(10); // hace Least amount of checking here
            // A I N F O 2 (47)
            return FindIndexIniSAMTable;
        }


        long FindIndex1(long ISAM[])
        {
            long I;
            for (I = 1; I <= Information.UBound(ISAM) - 1; I++)
            {
                if (ISAM[I] == 1)
                    return I;// First in the list
            }
            Abug(154, "This ISAM has no beginning", "", "");
            return constantMyErrorCode;
        }


        bool IsmYDigit(string A)
        {
            if (Strings.Left(A, 1) >= "0" & Strings.Left(A, 1) <= "9")
                return true;
            return false;
        }

        // todo needs to save the key in the registery
        string SecurityKey(string X)
        {
            string[] xxx = new string[17];
            string Security0;
            string BadSecurity;
            string K;
            long I, j;

            const long LowestFixedNumber = 3;



            Security0 = "N" + "N" + "N" + "N" + "0" + "0" + "N" + "N" + "N" + "N" + "N" + "N" + "N" + "N" + "N" + "N";
            BadSecurity = Security0; // This is done to avoid overwritting a constant.

            // rules for security key
            // 1 must be 16 digits long
            if (Strings.Len(X) != 16)
                // A I N F O 2 (53)
                return BadSecurity;

            // 2 They must all be digits.
            for (i = 1; i <= 16; i++)
            {
                if (IsmYDigit(Strings.Mid(X, I, 1)) == false)
                    // A I N F O 2 (52)
                    return BadSecurity;
            }

            // 3 digits they must add up to 9
            for (I = 1; I <= 14; I += 3)
            {
                K = Strings.Mid(X, I, 1) + Strings.Mid(X, I + 1, 1) + Strings.Mid(X, I + 2, 1);
                j = PopValue(ref K);
                if (Conversion.Int(j / (double)3) * 3 != j)
                    // A I N F O 2 (54)
                    return BadSecurity;
            }

            // 4 digits 15 and 12 can not be zero, because they tell the professional level of the user
            K = Strings.Mid(X, 15, 1);
            if (PopValue(ref K) < 1)
                // A I N F O 2 (55)
                return BadSecurity;
            K = Strings.Mid(X, 12, 1);
            if (PopValue(ref K) < 1)
                // A I N F O 2 (56)
                return BadSecurity;
            ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'mid(BadSecurity, 1, 1)' at character 330486
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:


            'byte 1 means they do something (dissallow this program from running (just in case), disable all buttons (except maybe the select a computer language? may be not )
            mid(BadSecurity, 1, 1) = "Y"

 */
 // Byte 2 means not demo, they can input or output
            K = Strings.Mid(X, 13, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 2, 1)' at character 330665
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 2, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 2, 1)' at character 330727
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 2, 1) = "N"

 */

 // byte 3 means read only, they can not make changes to anything. (Or save anything?)
            K = Strings.Mid(X, 16, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 3, 1)' at character 330960
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 3, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 3, 1)' at character 331022
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 3, 1) = "N"

 */


 // byte 4 means student they can make changes to the symbol. )Or save symbols?
            K = Strings.Mid(X, 4, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 4, 1)' at character 331248
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 4, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 4, 1)' at character 331310
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 4, 1) = "N"

 */

 // byte 5 is the level they are allowed (A-Z)
            K = Strings.Mid(X, 3, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 5, 1)' at character 331502
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 5, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 5, 1)' at character 331564
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 5, 1) = "N"

 */

 // byte 6 is the level they are at. (A-Z)
 // This should be keep in the key registery
            K = Strings.Mid(X, 8, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 6, 1)' at character 331807
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 6, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 6, 1)' at character 331869
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 6, 1) = "N"

 */

            K = Strings.Mid(X, 1, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 7, 1)' at character 332005
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 7, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 7, 1)' at character 332067
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 7, 1) = "N"

 */

            K = Strings.Mid(X, 2, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 8, 1)' at character 332203
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 8, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 8, 1)' at character 332265
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 8, 1) = "N"

 */

            K = Strings.Mid(X, 5, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 9, 1)' at character 332401
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 9, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 9, 1)' at character 332463
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 9, 1) = "N"

 */

            K = Strings.Mid(X, 6, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 10, 1)' at character 332599
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 10, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 10, 1)' at character 332662
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 10, 1) = "N"

 */

            K = Strings.Mid(X, 7, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 11, 1)' at character 332799
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 11, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 11, 1)' at character 332862
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 11, 1) = "N"

 */

            K = Strings.Mid(X, 9, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 12, 1)' at character 332999
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 12, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 12, 1)' at character 333062
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 12, 1) = "N"

 */

            K = Strings.Mid(X, 10, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 13, 1)' at character 333200
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 13, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 13, 1)' at character 333263
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 13, 1) = "N"

 */

            K = Strings.Mid(X, 11, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 14, 1)' at character 333401
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 14, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 14, 1)' at character 333464
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 14, 1) = "N"

 */

            K = Strings.Mid(X, 12, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 15, 1)' at character 333602
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 15, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 15, 1)' at character 333665
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 15, 1) = "N"

 */

            K = Strings.Mid(X, 14, 1); if (PopValue(ref K) > LowestFixedNumber)
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 16, 1)' at character 333803
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 16, 1) = "Y"

 */
            else
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(BadSecurity, 16, 1)' at character 333866
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(BadSecurity, 16, 1) = "N"

 */

            return BadSecurity;
        }


        long SecurityOption(long Level)
        {
            string MyLevel;
            // This will return if this option is on(1) or off (0) or the level of this option (student, begginner, etc)
            MyLevel = Strings.Mid(MyUniverse.Security, Level, 1);
            switch (MyLevel)
            {
            case "N":
            case "n":
            {
                // A I N F O 2 (57)
                return 0;
            }

            case "Y":
            case "y":
            {
                // ' A I N F O 2 (58)
                return 1;
            }

            default:
            {
                // A I N F O 2 (59)
                if (MyLevel >= "A" & MyLevel <= "Z")
                    return Strings.Asc(MyLevel) - 64;
                if (MyLevel >= "a" & MyLevel <= "z")
                    return Strings.Asc(MyLevel) - 96;
                if (MyLevel >= "1" & MyLevel <= "9")
                    return Strings.Asc(MyLevel) - 48; // zeros return false
                return 0; // This is not a valie key, so they can do nothing
            }
            }
        }



        // This return the security level from saved keys in the registery
        // byte 1 means they do something (dissallow this program from running (just in case), disable all buttons (except maybe the select a computer language? may be not )
        // Byte 2 means not demo, they can input or output
        // byte 3 means read only, they can not make changes to anything. (Or save anything?)
        // byte 4 means student they can make changes to the symbol. )Or save symbols?
        // byte 5 is the level they are allowed (A-Z)
        // byte 6 is the level they are at. (A-Z)

        // The  string is a list of the items that can be done.
        string SetSecurityOption()
        {
            string X;


            SetSecurityOption = "AAAAAAAA";
            MyUniverse.PaidFor.FCRName = My.Application.Info.ProductName.ToString;
            MyUniverse.PaidFor.FCRVersion = My.Application.Info.Version.ToString;
            MyUniverse.PaidFor.FCRCPUid = CPUID(); // For now it is junk (Maybe the username, or some such junk

            MyUniverse.PaidFor.FCRKey = System.Convert.ToString(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\\Software\\FlowChart", "Key", "Needs FlowChart To Be Registered"));
            MyUniverse.PaidFor.FCRUserProfession = System.Convert.ToString(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\\Software\\FlowChart", "TopLevel", "Needs FlowChart To Be Registered"));
            MyUniverse.PaidFor.FCRUserLevel = System.Convert.ToString(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\\Software\\FlowChart", "AtLevel", "Needs FlowChart To Be Registered"));

            if (Strings.Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1) >= "A" & Strings.Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1) <= "Z")
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(SetSecurityOption, 7, 1)' at character 336654
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(SetSecurityOption, 7, 1) = Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1)

 */

            if (Strings.Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1) >= "A" & Strings.Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1) <= "Z")
                ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(SetSecurityOption, 7, 1)' at character 336893
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                Mid(SetSecurityOption, 7, 1) = Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1)

 */
            if (MyUniverse.PaidFor.FCRName != System.Convert.ToString(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\\Software\\FlowChart", "Name", "Needs FlowChart To Be Registered")))
            {
                X = Interaction.InputBox("This copy of Flow Chart has not been registered for this machine", "Enter User Code", "Student");
                // bug I never save this so it always comes here
                // todo save this into the register
                if (X == "Student")
                    return "YNNNAA";// not allowed to do anything
                return SecurityKey(X); // hack
            }
        }


        // returns the index to the path/variable name (or adds one, and returns that index)
        long FindIndex_In_TableNetLinks(long IndexFlowChart) // Return the Net Link Index
        {
            long I;
            string PathName;
            // todo a /use record could be connected to this path should be tested ?????
            if (FlowChart_TableCode(IndexFlowChart) == "/use")
                return constantMyErrorCode; // paths are automaticlly connected to any symbol no matter what the name

            PathName = FlowChart_TablePath_Name(IndexFlowChart);
            if (MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex == IndexFlowChart)
            {
                if (MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName == PathName)
                    return MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound;
            }

            // ainfo2(11)
            if (FlowChart_TableCode(IndexFlowChart) != "/path")
            {
                MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -1;
                MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = null;
                MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = IndexFlowChart;
                return constantMyErrorCode;
            }
            // This should be in the findingmybugs test's
            for (I = Information.LBound(Net_FileLinks); I <= Information.UBound(Net_FileLinks); I++)
            {
                if (Strings.InStr(Net_TableLinks(I), FD + IndexFlowChart + FD) > 0)
                {
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = I;
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = PathName;
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = IndexFlowChart;
                    // AInfo1( 991, "FindIndex Integer the NetLinks ShortCut ", LastFound.ToString & LastPathName.ToString & LastPathName, "")
                    return I;
                }
                if (Net_TableNames(I) == PathName)
                {
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = I;
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = PathName;
                    MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = IndexFlowChart;
                    Net_TableLinks(I, Net_TableLinks(I) + FD + IndexFlowChart + FD);
                    // AInfo1( 990, "FindIndex Integer the NetLinks ShortCut ", LastFound.ToString & LastPathName.ToString & LastPathName, "")
                    return I;
                }
            }
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -1;
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = null;
            MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex = -2;
            // AInfo1( 990, "FindIndex Integer the NetLinks ShortCut ", MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex & ":" & MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound & ":" & MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName, "")
            return 0; // not in this list anywhere
        }



        long UseNetLinksNumber(long IndexFlowChart)
        {
            long I;
            I = FindIndex_In_TableNetLinks(IndexFlowChart);
            if (I > 0)
                return I;
            return constantMyErrorCode;
        }


        // returns the index of this index, and puts in this name as a pathname
        long MakeNew_NetLinks(long IndexFlowChart, string PathName) // 
        {
            long IndexNet;
            if (Strings.Len(PathName) == 0)
            {
                PathName = My_VariableName("BlankVariableName", VBMath.Rnd(10000), VBMath.Rnd(10000));
                Abug(805, "Can not make a path from a blank path name", "", "");
            }
            PathName = CheckThisPathName(PathName, IndexFlowChart);

            IndexNet = UseNetLinksNumber(IndexFlowChart);
            if (IndexNet > 0)
            {
                ainfo2(12);
                return IndexNet;
            }

            for (IndexNet = Information.LBound(Net_FileNames); IndexNet <= Information.UBound(Net_FileNames); IndexNet++)
            {
                if (PathName == Net_FileNames[IndexNet])
                    return IndexNet;
            }

            DisplayMyStatus("Added New Path Name " + HighLight(PathName));
            var oldNet_FileLinks = Net_FileLinks;
            Net_FileLinks = new string[Information.UBound(Net_FileLinks) + 1 + 1];
            if (oldNet_FileLinks != null)
                Array.Copy(oldNet_FileLinks, Net_FileLinks, Math.Min(Information.UBound(Net_FileLinks) + 1 + 1, oldNet_FileLinks.Length));
            var oldNet_FileNames = Net_FileNames;
            Net_FileNames = new string[Information.UBound(Net_FileNames) + 1 + 1];
            if (oldNet_FileNames != null)
                Array.Copy(oldNet_FileNames, Net_FileNames, Math.Min(Information.UBound(Net_FileNames) + 1 + 1, oldNet_FileNames.Length));
            IndexNet = Information.UBound(Net_FileLinks);
            Net_TableLinks(IndexNet, Net_TableLinks(IndexNet) + FD + IndexFlowChart + FD);
            Net_TableNameS(IndexNet, PathName);
            return IndexNet;
        }


        string MyShowInputOutput(IOTypeStructure Pt)
        {
            return ":>" + Pt.Input + ":<" + Pt.Output + ":<,>" + Pt.Both + ":?" + Pt.Other;
        }

        void AddSymbolUp(MySymbolCountsStructure A)
        {
            AddUp(ref A.Path.NumberOfConnectionsToOtherPaths);
            AddUp(ref A.Path.NumberOfConnectionsToSymbols);
            // A.Path.NumberOfErrors
            A.Path.Total = A.Path.NumberOfConnectionsToOtherPaths.Total + A.Path.NumberOfConnectionsToSymbols.Total + A.Path.NumberOfErrors;


            AddUp(ref A.Symbol.NumberOfLines);
            AddUp(ref A.Symbol.NumberOfOther);
            AddUp(ref A.Symbol.NumberOfPoints);
            A.Symbol.Total = A.Symbol.NumberOfLines.Total + A.Symbol.NumberOfOther.Total + A.Symbol.NumberOfPoints.Total;

            A.Total = A.Path.Total + A.Symbol.Total;
        }


        void AddUp(PointTypeStructure A)
        {
            A.Data.Total = A.Data.Both + A.Data.Input + A.Data.Output + A.Data.Other;
            A.Logic.Total = A.Logic.Both + A.Logic.Input + A.Logic.Output + A.Logic.Other;
            A.Total = A.Data.Total + A.Logic.Total;
        }

        void makezero(PointTypeStructure A)
        {
            A.Data.Both = 0;
            A.Data.Input = 0;
            A.Data.Output = 0;
            A.Data.Other = 0;
            A.Data.Total = 0;
            A.Logic.Both = 0;
            A.Logic.Input = 0;
            A.Logic.Output = 0;
            A.Logic.Other = 0;
            A.Logic.Total = 0;
            A.Total = 0;
        }



        // counts the type of the number of points in an existing symbol
        void NumberOfGraphicsInASymbol(long IndexSymbol, long IndexFlowChart)
        {
            long Idex, Jdex;
            string SymbolName;

            SymbolName = Symbol_TableSymbolName(IndexSymbol);

            makezero(ref MyUniverse.SymbolAndPath.Symbol.NumberOfLines);
            makezero(ref MyUniverse.SymbolAndPath.Symbol.NumberOfOther);
            makezero(ref MyUniverse.SymbolAndPath.Symbol.NumberOfPoints);
            makezero(ref MyUniverse.SymbolAndPath.Symbol.NumberOfPoints);

            makezero(ref MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths);
            makezero(ref MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther);
            makezero(ref MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines);
            makezero(ref MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints);

            MyUniverse.SymbolAndPath.Symbol.Total = 0;
            MyUniverse.SymbolAndPath.Path.Total = 0;
            MyUniverse.SymbolAndPath.Uses.Total = 0;
            MyUniverse.SymbolAndPath.Total = 0;

            AddSymbolUp(MyUniverse.SymbolAndPath);

            Idex = IndexSymbol + 1;
            if (IndexSymbol >= 1)
            {
                for (Idex = IndexSymbol + 1; Idex <= TopOfFile("Symbol"); Idex++)
                {
                    switch (PrintAbleNull(Symbol_TableCoded_String(Idex).ToString()))
                    {
                        case "/name" // Start of the next symbol
                            :
                        {
                            return;
                        }

                        case "/point":
                        {
                            while (MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total + 1 > SymbolScreen.ComboBoxPointNameList.Items.Count)
                                SymbolScreen.ComboBoxPointNameList.Items.Add("VariableName" + System.Convert.ToString(SymbolScreen.ComboBoxPointNameList.Items.Count));
                            SymbolScreen.ComboBoxPointNameList.Items.Item(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total) = System.Convert.ToString(Symbol_Table_NameOfPoint(Idex).ToString());
                            MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total += 1;
                            Symbol_Table_NameOfPoint(Idex).ToString();

                            switch (Strings.LCase(Symbol_Table_DataType(Idex)))
                            {
                            case "logic":
                            {
                                switch (Strings.LCase(Symbol_Table_InputOutput(Idex)))
                                {
                                case "input":
                                case "optionalinput":
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input += 1;
                                    break;
                                }

                                case "output":
                                case "optionaloutput":
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output += 1;
                                    break;
                                }

                                case "both":
                                case "optionalboth":
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both += 1;
                                    break;
                                }

                                case null:
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other += 1;
                                    break;
                                }

                                default:
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other += 1;
                                    break;
                                }
                                }

                                break;
                            }

                            default:
                            {
                                switch (Strings.LCase(Symbol_Table_InputOutput(Idex)))
                                {
                                case "input":
                                case "optionalinput":
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input += 1;
                                    break;
                                }

                                case "output":
                                case "optionaloutput":
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output += 1;
                                    break;
                                }

                                case "both":
                                case "optionalboth":
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both += 1;
                                    break;
                                }

                                case null:
                                {
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other += 1; // error of come kind
                                    break;
                                }

                                default:
                                {
                                    Abug(155, "Unknow input output code", Idex.ToString(), Symbol_Table_InputOutput(Idex));
                                    MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other += 1;
                                    break;
                                }
                                }

                                break;
                            }
                            }

                            break;
                        }

                        case "/line":
                        {
                            if (MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total > SymbolScreen.ComboBoxLineNameList.Items.Count)
                                SymbolScreen.ComboBoxLineNameList.Items.Add("Line Color" + System.Convert.ToString(SymbolScreen.ComboBoxLineNameList.Items.Count));
                            MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other += 1;
                            SymbolScreen.ComboBoxLineNameList.Items.Add(Symbol_Table_NameOfPoint(Idex) + " : " + Symbol_TableSymbolName(Idex));
                            break;
                        }

                        case "/error":
                        {
                            MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1; // just counting the number of error records found in the table
                            break;
                        }

                        case "/unknown":
                        {
                            break;
                        }

                        case "/delete" // do not count these 
                            :
                        {
                            break;
                        }

                        default:
                        {
                            MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1; // just counting the number of error records found in the table
                            Abug(156, "unknown code ", Symbol_TableCoded_String(Idex), MyShowSymbolGraphic(Idex));
                            MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1; // just count other things (not accountied for)
                            break;
                        }
                    }
                    AddSymbolUp(MyUniverse.SymbolAndPath);
                }
            }

            if (IndexFlowChart >= 1)
            {
                // count path and use
                for (Idex = 1; Idex <= TopOfFile("FlowChart"); Idex++)
                {
                    if (FlowChart_TableCode(Idex) == "/path")
                    {
                        for (Jdex = 1; Jdex <= TopOfFile("FlowChart"); Jdex++)
                        {
                            if (FlowChart_TableCode(Jdex) == "/path")
                            {
                                if (Idex != Jdex)
                                {
                                    if (FlowChart_TablePathName(Idex) == FlowChart_TablePathName(Jdex))
                                        Abug(157, "There are two enteries for the name ", FlowChart_TablePathName(Idex) + " : " + FlowChart_TablePathName(Jdex), FindIndex_In_TableNetLinks(Idex) + " : " + FindIndex_In_TableNetLinks(Jdex));
                                }
                            }
                        }
                    }
                }
            }
            AddSymbolUp(MyUniverse.SymbolAndPath);
        }
        /// <summary>   
        ///         '''<param name="FromWhat" Fromwhat ="From"> This is the old Symbol Name</param>
        ///         '''<param name="ToWhat" ToWhat = "To" >This is the the new symbol name</param>
        ///         '''<para> Function MyRenameSymbol  This will rename the symbol and all of the use
        ///         '''<!-- returns the number of times it change the symbol name (one for the symbol, and the rest in the flowchart.-->
        ///         '''if thier is not a symbol with this name already. </para>
        ///         '''<remarks>The symbol name can not be changed to be nothing.</remarks>
        ///         '''</summary>
        long MyRenameSymbol(string FromWhat, string ToWhat) // Returns the number of names changed, or <0 if there is an error during the process of changing the name
        {
            long Indexs, Kounter;
            if (FromWhat == ToWhat)
                return 0;// Equal
            if (PrintAbleNull(ToWhat) == "_")
                return 0;
            AInfo(611, "Rename symbol from/to ", FromWhat, ToWhat);
            // First need to check that there is no old name
            if (FindInNamedList(ToWhat) > 0)
                return -2;// Symbol name alread exist
            if (FindInSymbolList(ref ToWhat) > 0)
                return -3;// symbol graphics already exist

            if (FindInNamedList(FromWhat) < 0)
                return -4;// the old name does not exist
            if (FindInSymbolList(ref FromWhat) < 0)
                return -5;// There is no graphic records.

            Kounter = 0;
            // First go throuth the symbols
            for (Indexs = 1; Indexs <= TopOfFile("Symbol"); Indexs++)
            {
                if (Symbol_TableCoded_String(Indexs) == "/name")
                {
                    if (Symbol_TableSymbolName(Indexs) == FromWhat)
                    {
                        Symbol_TableSymbolName(Indexs, ToWhat); // Rename what it uses.
                        Kounter += 1;
                    }
                }
            }

            // then go through the name (controld of the symbols)
            for (Indexs = 1; Indexs <= TopOfFile("Symbol"); Indexs++)
            {
                if (Named_TableSymbolName(Indexs) == FromWhat)
                {
                    Named_TableSymbolName(Indexs, ToWhat); // update the name
                    Kounter += 1;
                }
            }

            // then go through the flowchart and rename all of the /use
            for (Indexs = 1; Indexs <= TopOfFile("FlowChart"); Indexs++)
            {
                if (FlowChart_TableCode(Indexs) == "/use")
                {
                    if (FlowChart_TableSymbol_Name(Indexs) == FromWhat)
                    {
                        FlowChart_TablePathSymbolName(Indexs, ToWhat); // update the name
                        Kounter += 1;
                    }
                }
            }
            AInfo(612, "Change the symbol name " + FromWhat + " to " + ToWhat, Kounter + " times", "");
            // A I N F O 2 (82)
            return Kounter;
        }

        long FindInNamedList(string WhatToFind)
        {
            long IndexNamed;
            // Cheat first now
            if (WhatToFind == "")
                // A I N F O 2 (83)
                return constantMyErrorCode;
            FindingMyBugs(100);
            if (MyUniverse.MyCheatSheet.Last_UnSortedStringTable == "named")
            {
                if (MyUniverse.MyCheatSheet.Last_UnSortedStringString == WhatToFind)
                    // A I N F O 2 (84)
                    return MyUniverse.MyCheatSheet.Last_UnSortedStringIndex;
            }
            IndexNamed = FindIndexIniSAMTable("Named", "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, WhatToFind);
            FindingMyBugs(10); // hack Least amount of checking here
            if (IndexNamed <= 0)
                // A I N F O 2 (85)
                return CheckNotInList("named", ref "Do Not Add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref WhatToFind);
            else
                // A I N F O 2 (86)
                return IndexNamed;
        }





        // rewrote 20200711
        // Gets the index in symbol from just the name (looks it up in named first)
        long FindInSymbolList(string WhatToFind) // Gets the index in symbol from just the name (looks it up in named first)
        {
            string Temp;
            long IndexNamed, IndexSymbol;            // MyArray() As String,  is always symbol file anem
            // Cheat first now
            if (MyUniverse.MyCheatSheet.Last_UnSortedStringTable == "symbol")
            {
                if (MyUniverse.MyCheatSheet.Last_UnSortedStringString == WhatToFind)
                    // A I N F O 2 (87)
                    return MyUniverse.MyCheatSheet.Last_UnSortedStringIndex;
            }

            // FindingMyBugs(30) 'hace Least amount of checking here

            if (WhatToFind == "")
                // A I N F O 2 (90)
                return constantMyErrorCode;

            IndexNamed = FindIndexIniSAMTable("Named", "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, WhatToFind);
            if (IndexNamed <= 0)
                IndexNamed = CheckNotInList("named", ref "Do Not Add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref WhatToFind);
            if (IndexNamed <= 0)
                IndexNamed = IndexNamed; // hack
            else
            {
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed);
                if (IndexSymbol <= 0)
                {
                    // FindingMyBugs(80) 'hack Least amount of checking here
                    IndexSymbol = GetSelfCorrectingIndexes(WhatToFind); // At least fix this Indexes
                    // in the name table, but not in the symbol table
                    if (IndexSymbol < 0)
                        return constantMyErrorCode;                        // not a valid symbol name in the symbol table
                    else if (IndexSymbol > 0)
                    {
                        Named_TableSymbolIndexes(IndexNamed, IndexSymbol); // update the missing Indexes
                        return IndexSymbol; // return the new index number that is found and updated
                    }
                    else
                        Abug(158, "The indexsymbol = " + IndexSymbol, WhatToFind, IndexNamed);
                }
                else
                {
                    // FindingMyBugs(50) 'hack Least amount of checking here
                    Temp = Symbol_TableSymbolName(IndexSymbol);
                    if (MyCompared1_a(WhatToFind, Temp) == 0)
                        // FindingMyBugs(40) 'hack Least amount of checking here
                        // A I N F O 2 (-90)
                        return IndexSymbol;
                    else
                    {
                        IndexSymbol = GetSelfCorrectingIndexes(WhatToFind); // The Indexess are off so fix them if possible

                        // So Do We need to search it again"
                        // ?IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' See if it is corrected
                        Abug(159, "Fixing named and symbol for " + WhatToFind, IndexNamed + " : " + Named_TableSymbolName(IndexNamed), IndexSymbol + " : " + Symbol_TableSymbolName(IndexSymbol));
                    }
                }
            }
            // Failed above so we have to do this the hard way.
            // And assume that it is an unsorted list now
            for (IndexSymbol = 1; IndexSymbol <= TopOfFile("Symbol"); IndexSymbol++)
            {
                Temp = Symbol_TableSymbolName(IndexSymbol);
                // Finds the first one, not the /name one
                if (MyCompared1_a(WhatToFind, Temp) == 0)
                {
                    if (Symbol_TableCoded_String(IndexSymbol) == "/name")
                    {
                        Abug(161, "We had to find a symbol name match the hard way! Program data error", IndexSymbol, WhatToFind + " : " + Temp);
                        GetSelfCorrectingIndexes(WhatToFind);
                        MyUniverse.MyCheatSheet.Last_UnSortedStringTable = "symbol";
                        MyUniverse.MyCheatSheet.Last_UnSortedStringString = WhatToFind;
                        FindingMyBugsCheckForErrors(0, IndexNamed, IndexSymbol);
                        return IndexSymbol; // If we find it this way then there is a issues' some where
                    }
                    else
                    {
                        Abug(162, "The Symbols must be out of order, because the first one found was not a /name code at " + IndexSymbol, WhatToFind, Temp);
                        GetSelfCorrectingIndexes(WhatToFind);
                    }
                }
            }
            // failed to find it the hard way so it's not there
            // A I N F O 2 (-92)
            return constantMyErrorCode;
        }



        long AddInTable(string MyTable, string MyFunction, string MyArray[], long iSAM[], string WhatToFind, long IndexPassed)
        {
            long index;

            MyMakeArraySizesBigger();

            // AddInTable = IndexPassed
            CheckForAnySortNeeded("", 150); // hack
            ShowSorts(MyTable, MyReSort(MyTable, ref MyArray, ref iSAM, 1));
            CheckForAnySortNeeded("", 151); // hack
            ShowSorts(MyTable, MyReSort(MyTable, ref MyArray, ref iSAM, IndexPassed));
            CheckForAnySortNeeded("", 152); // hack
            // Not in the list so add it, or not
            if (Strings.LCase(Strings.Trim(MyFunction)) == "add")
            {
                FindingMyBugs(10); // hace Least amount of checking here
                // Last attempt to find because I've got a bug
                for (index = 1; index <= TopOfFile(MyTable); index++)
                {
                    CheckThisStringArray(10, ref MyArray, ref iSAM, index);
                    if (MyCompared1_a(MyArray[index], WhatToFind) == 0)
                    {
                        MyMsgCtr(1270, "AddInTable", MyArray[index], WhatToFind, "", "", "", "", "", "", "");
                        return index;
                    }
                    FindingMyBugs(10); // hace Least amount of checking here
                }

                MyMakeArraySizesBigger(); // ? Do I need This
                index = TopOfFile(MyTable);
                AddInTable = index;
                MyArray[index] = WhatToFind;
                iSAM[index] = index;
                MyUniverse.MyCheatSheet.LastString = WhatToFind;
                MyUniverse.MyCheatSheet.LastIndex = AddInTable;
                CheckThisStringArray(11, ref MyArray, ref iSAM, index);
                CheckForAnySortNeeded("", 153); // hack
                QuickCheckSort(ref MyArray, ref iSAM, index); // hack                trying to find any problems here. 
                CheckForAnySortNeeded("", 154); // hack
            }
            else
                AddInTable = IndexPassed;
            CheckForAnySortNeeded("AddInTable", 10);
            FindingMyBugs(10); // hace Least amount of checking here
        }



        int FindMessageNumber(int Level)
        {
            long Idex, Jdex, Kdex;
            string X;
            long Zdex;
            long ErrorKounter;

            FindMessageNumber = My_KeyConstError;
            ErrorKounter = -16;

            Kdex = OptionScreen.ComboBoxDebug.Items.Count - 1;
            if (Kdex < 4)
                // A I N F O 2 (93)
                return default(Integer);
            Idex = MyMinMax(System.Convert.Tolong(Kdex / (double)2), 0, Kdex);
            Jdex = MyMinMax(System.Convert.Tolong(Idex / (double)2), 1, Kdex);
            while (1 == 1)
            {
                mydoevents();
                ErrorKounter += 1;
                if (ErrorKounter > OptionScreen.ComboBoxDebug.Items.Count)
                {
                    Abug(163, ErrorKounter, "No Messages in the buffer yet", "Message # " + Level); // just not found, but need to excape
                    // Tried to many times must be a issues' (most likely not found in a sorted list
                    return 0; // default to the first message, what ever it might be.
                }
                X = OptionScreen.ComboBoxDebug.Items.Item(Idex).ToString;
                Zdex = PopValue(ref X);
                if (Zdex > Level)
                {
                    Idex = MyMinMax(Idex - Jdex, 0, Kdex);
                    Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Idex);
                }
                else if (Zdex < Level)
                {
                    Idex = MyMinMax(Idex + Jdex, 0, Kdex);
                    Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Idex);
                }
                else if (Zdex == Level)
                    // A I N F O 2 (-94)
                    return Idex;
            }
            FindMessageNumber = 0; // default to the first message, what ever it might be.
        }


        // Routine Just gets the size of the circle or path width 
        long FindMySize(string DataTypeName, string ColorName)
        {
            long IndexDataType, IndexColor;

            CheckForAnySortNeeded("", 155);
            IndexColor = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, Strings.Trim(ColorName));
            IndexDataType = FindIndexIniSAMTable("DataType", "DoNotAdd", ref DataType_FileName, ref DataType_Name_iSAM, Strings.Trim(DataTypeName));
            CheckForAnySortNeeded("", 156);
            if (IndexDataType == constantMyErrorCode)
            {
                if (IndexColor == constantMyErrorCode)
                    // MyMsgCtr(1291, "FindMySize", DataTypeName, ColorName, IndexDataType.ToString, IndexColor.ToString, "", "", "", "", "")
                    return constantMyErrorCode;
                else
                    return MyUniverse.SysGen.Constants.constantMinPenSize;
            }
            else
                // A I N F O 2 (96)
                return MyMinMax(DataType_TableWidth(IndexDataType), MyUniverse.SysGen.Constants.constantMinPenSize, MyUniverse.SysGen.Constants.constantMaxPenSize);
            // A I N F O 2 (97)
            return MyUniverse.SysGen.Constants.constantMinPenSize;
        }


        // Routine This is called to draw the inside symbol lines 
        void MyDrawLineXY_XY(string Where, MyLineStructure Xy, string ColorName)
        {
            My_Draw_Line_Or_Path(Where, ref Xy, ColorName, 10);
        }


        // This is called to draw the inside symbol lines with a width of 1
        void MyDrawLineWithIndex(string Where, long IndexSymbol, MyPointStructure XYOffSet, string RotationName)
        {
            MyLineStructure MyLine;
            string MyColor;
            // ' Cheat and use the path to draw the line
            MyLine = MyLine1(MyRotated_1(IndexSymbol, XYOffSet, RotationName), MyRotated_2(IndexSymbol, XYOffSet, RotationName));
            if (Symbol_TableCoded_String(IndexSymbol) == "/line")
                MyColor = Symbol_Table_NameOfPoint(IndexSymbol);
            else
                MyColor = FindColorFromDataType(Symbol_Table_DataType(IndexSymbol));
            if (Strings.Len(MyColor) < 1)
                Abug(479, "Invalid data type pointer ", MyShowSymbolRecords(IndexSymbol), "");

            My_Draw_Line_Or_Path(Where, ref MyLine, MyColor, 1);
        }
        // MyDrawLineWithIndex(Where, IndexSymbol, XYOffSet, RotationName)
        // Routine This is used to draw the paths between the symbol points (with a min width of 3
        void MyDrawPath(string Where, MyLineStructure XY, string DataTypeName)
        {
            string ColorName;
            long IndexDataTypeOrColor;
            long Width;

            MyMakeArraySizesBigger();

            // ColorName = "Black" ' default color if any errors
            // CheckForAnySortNeeded("", 157)
            IndexDataTypeOrColor = FindIndexIniSAMTable("DataType", "DoNotAdd", ref DataType_FileName, ref DataType_Name_iSAM, PrintAbleNull(DataTypeName));
            if (IndexDataTypeOrColor == constantMyErrorCode)
            {
                IndexDataTypeOrColor = FindColor(DataTypeName);
                if (IndexDataTypeOrColor == constantMyErrorCode)
                {
                    Abug(165, "Error : ALSO Invalid Datatype or Color ", DataTypeName, "");
                    IndexDataTypeOrColor = FindColor("Black");
                    if (IndexDataTypeOrColor == constantMyErrorCode)
                    {
                        Abug(166, "ERROR: Invalid Color/Code for black : " + DataTypeName, IndexDataTypeOrColor, "Made into " + Color_TableName(1));
                        IndexDataTypeOrColor = 1;
                        ColorName = MyUniverse.ProgramOptions.SelectedColor;
                    }
                    else
                    {
                        ColorName = Color_TableName(IndexDataTypeOrColor); // For color black
                        Width = 1; // default width for all non datatypes
                    }
                }
                else
                {
                    ColorName = Color_TableName(IndexDataTypeOrColor);
                    Width = 1; // default width for all non datatypes
                }
            }
            else
            {
                // Found a DataType
                ColorName = Color_TableName(Color_Name_iSAM[DataType_TableColorIndex(IndexDataTypeOrColor)]);
                Width = MyMinMax(DataType_TableWidth(IndexDataTypeOrColor), MyUniverse.SysGen.Constants.constantMinPenSize, MyUniverse.SysGen.Constants.constantMaxPenSize);
            }
            if (ColorName == "" | Information.IsNothing(ColorName))
            {
                DataType_TableColorIndex(IndexDataTypeOrColor, FindColor(MyUniverse.ProgramOptions.SelectedColor));
                Abug(167, "the color name gets set to black because of the invalid color name.", DataTypeName, ColorName);
                ColorName = "Black";
            }
            My_Draw_Line_Or_Path(Where, ref XY, ColorName, Width);
        }


        long InsertFlowChartRecord(long IndexFlowChart, string SymbolName, string CodedString, MyPointStructure xy1, MyPointStructure xy2, string DataType_Color)
        {
            MyMakeArraySizesBigger();
            IndexFlowChart = NewTopOfFile("Flowchart");
            FlowChart_TableCode(IndexFlowChart, MyKeyword_2_Byte(CodedString).ToString());
            FlowChart_TablePathSymbolName(IndexFlowChart, SymbolName);
            FlowChart_Table_DataType(IndexFlowChart, DataType_Color);
            FlowChart_TableX1(IndexFlowChart, xy1.Xx);
            FlowChart_TableY1(IndexFlowChart, xy1.Yy);
            FlowChart_TableX2(IndexFlowChart, xy2.Xx);
            FlowChart_TableY2(IndexFlowChart, xy2.Yy);
            InsertFlowChartRecord = IndexFlowChart;
            ShowSorts("FlowChart", SortFlowChart());
            PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart, IndexFlowChart);
        }


        // need to make sure that this error message is not already in the list.
        void MakeErrorAt(string Where, MyPointStructure myXY, string ErrorMessage)
        {
            long Idex;
            long IndexSymbol;

            switch (Where.Parent.Name)
            {
            case "FlowChartScreen":
            {
                // Idex = MyFindPoint(Where, myXY) 'Find the closest point
                // Need to find the closest if this error is already in the FlowChart file, other wise it will go on forever building errors
                for (Idex = 1; Idex <= TopOfFile("FlowChart"); Idex++)
                {
                    if (FlowChart_TableCode(Idex) == "/error")
                    {
                        if (myXY.Xx == FlowChart_TableX1(Idex))
                        {
                            if (myXY.Yy == FlowChart_TableY1(Idex))
                            {
                                // Do not put errors ontop of the same errors
                                if (ErrorMessage == FlowChart_TableSymbol_Name(Idex))
                                    return;// not at the same message?
                            }
                        }
                    }
                }
                InsertFlowChartRecord(NewTopOfFile("FlowChart"), ErrorMessage, "/error", myXY, ZeroZero, "red"); // color??
                break;
            }

            case "SymbolScreen":
            {
                if (MyUniverse.ProgramOptions.SelectedSymbolName != "")
                {
                    Idex = FindInSymbolList(ref MyUniverse.ProgramOptions.SelectedSymbolName);
                    IndexSymbol = Idex + 1;
                    while (IndexSymbol < TopOfFile("Symbol") & Symbol_TableCoded_String(IndexSymbol) != "/name")
                    {
                        if (Symbol_TableCoded_String(IndexSymbol) == "/error")
                        {
                            if (myXY.Xx == Symbol_FileX1[IndexSymbol])
                            {
                                if (myXY.Yy == Symbol_FileY1[IndexSymbol])
                                    return;// It is already in the symbol
                            }
                        }
                        IndexSymbol += 1;
                    }

                    // Will insert multiply of this right now
                    MyInsertSymbolLineRecord(Idex, MyUniverse.ProgramOptions.SelectedSymbolName, "/error", MyLine1(myXY.Xx, myXY.Yy, 0, 0), ErrorMessage);
                    Abug(168, Idex + " : " + MyUniverse.ProgramOptions.SelectedSymbolName, "Error (" + System.Convert.ToString(myXY.Xx) + FD + System.Convert.ToString(myXY.Yy) + ")", ErrorMessage);
                }

                break;
            }
            }
        }


        // Routine This draws all text on the screen
        void MyDrawText(string Where, MyPointStructure xy, string MyString, long BrushOptionNumber)
        {
            Point XY1;
            Font MyFonts;
            Brush MyBrushes;
            Rectangle XYXY;


            if (Strings.Len(MyString) == 0)
                return;
            if (MyOptionTest(BrushOptionNumber) == false)
                return;

            XY1 = ConvertPoint2MyPointStruct(Copy2ScreenXY(Where, xy));
            MyFonts = SystemFonts.DefaultFont;

            // todo ned to be able to set another size for the text (lok into aq defination for each of the fonts.)
            if (MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis == false)
                MyBrushes = Brushes.White;
            else
                MyBrushes = MyUniverse.OptionDisplay[BrushOptionNumber].ColorBrush;
            // Where.CreateGraphics.DrawString(BrushOptionNumber.ToString & " : " & MyString, MyFonts, MyBrushes, XY1)
            XYXY.X = XY1.X + 4;
            XYXY.Y = XY1.Y + 4;
            XYXY.Height = MyUniverse.OptionDisplay[BrushOptionNumber].Textwidth;
            XYXY.Width = MyUniverse.OptionDisplay[BrushOptionNumber].Textheight;
            if (MyOptionTest(BrushOptionNumber) == true)
                Where.CreateGraphics.DrawString(BrushOptionNumber.ToString() + " : " + MyString, MyFonts, MyBrushes, XYXY);
            else
                Where.CreateGraphics.DrawString(MyString, MyFonts, MyBrushes, XYXY);
        }

        // Routine This is the actuall routine that write out text , called by everything else

        void MyDrawLineS_PathS(string Where, long IndexFlowChart)
        {
            MyLineStructure MyLine;
            string MyColor;
            long MyWidth;

            MyLine = MyLine1(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), MyPoint2XY(FlowChart_TableX2(IndexFlowChart), FlowChart_TableY2(IndexFlowChart)));
            MyColor = FindColorFromDataType(FlowChart_Table_DataType(IndexFlowChart));
            MyWidth = FindWidthFromDataType(FlowChart_Table_DataType(IndexFlowChart));
            My_Draw_Line_Or_Path(Where, ref MyLine, MyColor, MyWidth);
        }




        // color name is not being passed
        void My_Draw_Line_Or_Path(string Where, MyLineStructure XY, string ColorName, long Width)
        {
            Point XY_a, XY_b;
            Pen MinePen;
            long indexColor;

            if (Strings.Len(ColorName) == 0)
            {
                AInfo1(709, "Blank color name used to draw line/path", "At " + MyShowLine(XY), "Width " + Width.ToString());
                MinePen = Pens.Black;
                ColorName = MyUniverse.ProgramOptions.SelectedColor;
            }
            else
            {
                MyGetPen_Static(ColorName, "");
                MinePen = GetMyPen;
            }

            // flow10'      MinePen.Width = MyMinMax(Width, 1, 24)

            XY_a = ConvertPoint2MyPointStruct(Copy2ScreenXY(Where, XY.a));
            XY_b = ConvertPoint2MyPointStruct(Copy2ScreenXY(Where, XY.b));
            // AInfo1(711, "Drawing Lines " & ColorName, MyShowLine(XY), MyShowLine(MyLineXY(XY_b, XY_b)))
            Where.CreateGraphics.DrawLine(MinePen, XY_a, XY_b);
            // If Width <= 1 Then Width = 2 'flow10' This is to force drawing 'ERROR 
            if (Width > 1)
            {
                CheckForAnySortNeeded("", 163);
                indexColor = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, ColorName);
                CheckForAnySortNeeded("", 164);
                if (indexColor > 0)
                {
                    MyDrawCircle(Where, XY.a, Color_TableName(indexColor), "");
                    MyDrawCircle(Where, XY.b, Color_TableName(indexColor), "");
                }
            }
        }


        // Routine This draws a big cross where the symbol is at.
        void MyDrawCross(string Where, MyPointStructure xy, string MyDataType, string MyString)
        {
            Point XY1, XY2;
            long tempsize;

            tempsize = 10;

            XY1 = ConvertPoint2MyPointStruct(Copy2ScreenXY(Where, xy));
            XY2.X += tempsize;
            XY2.Y += tempsize;
            XY1.X -= tempsize;
            XY1.Y -= tempsize;
            Where.CreateGraphics.DrawLine(Pens.Black, XY1, XY2);


            XY1 = ConvertPoint2MyPointStruct(Copy2ScreenXY(Where, xy));
            XY2.X -= tempsize;
            XY2.Y += tempsize;
            XY1.X += tempsize;
            XY1.Y -= tempsize;
            Where.CreateGraphics.DrawLine(Pens.Black, XY1, XY2);
        }

        long MyDistancePath(MyLineStructure XY1, MyLineStructure XY2) // Find The Distance From XY1  to XY2
        {
            long T1, T2, T3, T4;

            T1 = MyABS(XY1.a.Xx - XY2.a.Xx) + MyABS(XY1.a.Yy - XY2.a.Yy); // 1A to 2A
            T2 = MyABS(XY1.b.Xx - XY2.a.Xx) + MyABS(XY1.b.Yy - XY2.a.Yy); // 1B to 2A
            T3 = MyABS(XY1.a.Xx - XY2.b.Xx) + MyABS(XY1.a.Yy - XY2.b.Yy); // 1A to 2B
            T4 = MyABS(XY1.b.Xx - XY2.b.Xx) + MyABS(XY1.b.Yy - XY2.b.Yy); // 1b to 2B
            MyDistancePath = MyMiN(T1, T2); // Between t1 & t2
            MyDistancePath = MyMiN(MyDistancePath, T3); // Between t1 & t2
            MyDistancePath = MyMiN(MyDistancePath, T4); // Between t1 & t2
        }



        // routine to see the distance between two points (OK, so I didn't square amounts and take the root
        long MyDistance(MyPointStructure A, MyPointStructure B)
        {
            MyDistance = Math.Sqrt(Math.Pow(MyABS(A.Xx - B.Xx), 2) + Math.Pow(MyABS(A.Yy - B.Yy), 2));
        }


        // Routine This routine returns a 16 unit clock of the direction of the second point from the first point
        byte MyDirection(MyPointStructure XY1, MyPointStructure XY2)
        {
            // Dim TDist as long
            long dX, dY;

            // This should return the following 'clock' of the direction of the second from the centered first points
            // TDist = myuniverse.SysGen.constants.constantSymbolCenter * 2
            // 14 15 16 01 02
            // 13 /  |   / 03
            // 12 ---0-----04
            // 11 /  |   / 05
            // 10 09 08 07 06
            // 
            // Just to make it simple
            dX = XY2.Xx - XY1.Xx;
            dY = XY2.Yy - XY1.Yy;

            if (dX == 0 & dY == 0)
                return 0;

            if (dX == 0)
            {
                if (dY < 0)
                    return 16;
                else
                    return 8;
            }

            if (dY == 0)
            {
                if (dX > 0)
                    return 4;
                else
                    return 12;
            }


            if (dX > 0)
            {
                if (dY > 0)
                {
                    if (MyABS(dX) == MyABS(dY))
                        return 6;
                    if (MyABS(dX) > MyABS(dY))
                        return 5;
                    else
                        return 7;
                }
                else
                {
                    if (MyABS(dX) == MyABS(dY))
                        return 2;
                    if (MyABS(dX) > MyABS(dY))
                        return 3;
                    else
                        return 1;
                }
            }
            else if (dY > 0)
            {
                if (MyABS(dX) == MyABS(dY))
                    return 10;
                if (MyABS(dX) > MyABS(dY))
                    return 11;
                else
                    return 9;
            }
            else
            {
                if (MyABS(dX) == MyABS(dY))
                    return 14;
                if (MyABS(dX) > MyABS(dY))
                    return 13;
                else
                    return 15;
            }
            return 0;
        }




        // Routine This draws the input/output arrows at each point
        void MyDrawPointArrow(string Where, MyPointStructure CenterXY, MyPointStructure ArrowXY, string DataTypeName, string DirectionString, long InputOrOutPut)
        {
            // Dim MineXY1 As MyLineStructure
            ThisArrow MyArrow;
            MyArrow.IO_SizeModifier = new int[17];

            // todo This is bombing out  string to integer
            MyArrow.Temp = MyUnEnum(InputOrOutPut, SymbolScreen.ToolStripDropDownInputOutput, 1);
            MyArrow.Input_Output_Both_Direction = PopValue(ref MyArrow.Temp);
            // This changes the size based on the direction of the arrow.

            MyArrow.IO_SizeModifier[0] = 1;
            MyArrow.IO_SizeModifier[1] = 3;            // input
            MyArrow.IO_SizeModifier[2] = -3;            // output
            MyArrow.IO_SizeModifier[3] = 4;            // both
            MyArrow.IO_SizeModifier[4] = 4;            // Optionalinput
            MyArrow.IO_SizeModifier[5] = -2;            // optional output
            MyArrow.IO_SizeModifier[6] = 2;           // optional both
            MyArrow.IO_SizeModifier[7] = 1;            // anything else
            MyArrow.IO_SizeModifier[8] = 1;            // anything else
            MyArrow.IO_SizeModifier[9] = 1; // Future
            MyArrow.IO_SizeModifier[10] = 1; // Future
            MyArrow.IO_SizeModifier[11] = 1; // Future
            MyArrow.IO_SizeModifier[12] = 1; // Future
            MyArrow.IO_SizeModifier[13] = 1; // Future
            MyArrow.IO_SizeModifier[14] = 1; // Future
            MyArrow.IO_SizeModifier[15] = 1; // Future
            MyArrow.IO_SizeModifier[16] = 1; // Future

            MyArrow.ArrowFactor = 1;
            if (Strings.Len(DataTypeName) == 0)
            {
                Abug(171, "MyDrawPointArrow", "No datatypename passed", DataTypeName);
                DataTypeName = "Errored";
            }
            MyArrow.IndexDataType = FindIndexIniSAMTable("DataType", "DoNotAdd", ref DataType_FileName, ref DataType_Name_iSAM, DataTypeName); // Add this datatype 
            if (MyArrow.IndexDataType == constantMyErrorCode)
            {
                Abug(172, "This Datatype Is Not In the datatype table", HighLight(MyArrow.IndexDataType.ToString()), HighLight(DataTypeName));
                // todo need to catch where this datatype is not being set when adding points to the symbol
                MyArrow.clrName = Color_TableName(FindColorIndexFromName("Black"));
            }
            else
                MyArrow.clrName = Color_TableName(DataType_TableColorIndex(MyArrow.IndexDataType));
            MyMakeArraySizesBigger();                                           // Make sure we are not over flowing the MyArrays'
            MyArrow.clrName = FindColorFromDataType(DataType_TableName(MyArrow.IndexDataType));
            // myarrow.clrName = DataType_TableColor(myarrow.IndexDataType)

            if (Information.IsNothing(MyArrow.clrName))
            {
                if (Information.IsNothing(DataType_TableColorIndex(MyArrow.IndexDataType)))
                    DataType_TableColorIndex(MyArrow.IndexDataType, FindColor("Red"));
                MyArrow.clrName = "Red";
            }
            MyArrow.TempPenWidthSize = 1; // MyMinMax(FindMySize(Where, Trim(DataTypeName)), 1, 550) ' Already set between 10 and 250 


            // Get this pen color
            MyGetPen_Static(Strings.Trim(MyArrow.clrName), "");
            MyArrow.MinePen = GetMyPen;
            // myarrow.MinePen.Width = MyMinMax(ScaledSize(myarrow.TempPenWidthSize), 1, 250) '?
            if (ScaledSize(MyArrow.TempPenWidthSize) < 1)
            {
            }
            else if (ScaledSize(MyArrow.TempPenWidthSize) > 250)
                MyArrow.MinePen.Width = 250;
            else
            {
            }
            // MyXYCenter.X = myuniverse.SysGen.constants.constantSymbolCenter
            // MyXYCenter.Y = myuniverse.SysGen.constants.constantSymbolCenter

            MyArrow.DirectionIs = MyDirection(ZeroZero, ArrowXY);


            switch (Where.Parent.Name)
            {
            case "SymbolScreen":
            {
                MyArrow.MyXY1 = CenterXY;                  // Save the center of where we should show
                MyArrow.MyXY1.Yy -= MyUniverse.OptionDisplay[10].X; // Display Input/output text
                MyDrawText(Where, MyArrow.MyXY1, SymbolScreen.ToolStripDropDownInputOutput.DropDownItems(MyMinMax(MyArrow.IO_SizeModifier[MyArrow.DirectionIs], 1, SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Count - 1)).ToString, 10);
                break;
            }

            case "FlowChartScreen":
            {
                // For Direction, for the second part of the line
                MyArrow.MyXY1 = CenterXY;
                MyArrow.MyXY2 = CenterXY; // Save the center of where we should show

                MyArrow.MyXY2.Xx += System.Convert.Tolong(MyDirections[MyArrow.DirectionIs, 1, 1] * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier[MyMinMax(MyArrow.IO_SizeModifier[MyArrow.DirectionIs], 0, 8)] / (double)MyArrow.ArrowFactor);
                MyArrow.MyXY2.Yy += System.Convert.Tolong(MyDirections[MyArrow.DirectionIs, 1, 2] * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier[MyMinMax(MyArrow.IO_SizeModifier[MyArrow.DirectionIs], 0, 8)] / (double)MyArrow.ArrowFactor);
                MyArrow.XY1 = Copy2ScreenXY(Where, MyArrow.MyXY1); MyArrow.XY2 = Copy2ScreenXY(Where, MyArrow.MyXY2);

                Where.CreateGraphics.DrawLine(MyArrow.MinePen, ConvertPoint2MyPointStruct(MyArrow.XY1), ConvertPoint2MyPointStruct(MyArrow.XY2));

                MyArrow.MyXY1 = CenterXY; MyArrow.MyXY2 = CenterXY; // Save the center of where we should show
                MyArrow.MyXY2.Xx += System.Convert.Tolong(MyDirections[MyArrow.DirectionIs, 2, 1] * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier[MyMinMax(MyArrow.IO_SizeModifier[MyArrow.DirectionIs], 0, 8)] / (double)MyArrow.ArrowFactor);
                MyArrow.MyXY2.Yy += System.Convert.Tolong(MyDirections[MyArrow.DirectionIs, 2, 2] * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier[MyMinMax(MyArrow.IO_SizeModifier[MyArrow.DirectionIs], 0, 8)] / (double)MyArrow.ArrowFactor);
                MyArrow.XY1 = Copy2ScreenXY(Where, MyArrow.MyXY1); MyArrow.XY2 = Copy2ScreenXY(Where, MyArrow.MyXY2);
                // This is only for output or both
                Where.CreateGraphics.DrawLine(MyArrow.MinePen, ConvertPoint2MyPointStruct(MyArrow.XY1), ConvertPoint2MyPointStruct(MyArrow.XY2)); // Second part of the Indexes (v, or ^ or < or > )
                break;
            }
            }
        }


        // Routine The draws a circle where each point is
        void MyDrawCircle(string Where, MyPointStructure XY, string MyColorName, string DataTypeName)
        {
            Rectangle MyRec;
            long TempSize;
            MyPointStructure ScreenPoint;
            long IndexColor;
            long IndexDataType;
            Pen MinePen;
            string ColorNameIs;

            ColorNameIs = MyColorName;

            if (Information.IsNothing(ColorNameIs))
                ColorNameIs = "Red";
            else if (ColorNameIs == "")
                ColorNameIs = "Red";
            else if (FindColor(ColorNameIs) == constantMyErrorCode)
                ColorNameIs = "Black";
            // ColorNameIs = "Red"

            CheckForAnySortNeeded("", 170);
            IndexColor = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, ColorNameIs);


            if (IndexColor == constantMyErrorCode & IndexDataType == constantMyErrorCode)
            {
                Abug(173, "Neither Color name or Datatype name is valid", HighLight(ColorNameIs) + HighLight(DataTypeName), MyShowPoint(XY));
                return;
            }


            if (IndexColor < 0)
            {
                IndexDataType = FindDataTypeIndex(DataTypeName);
                if (IndexDataType > 0)
                {
                    IndexColor = DataType_TableColorIndex(IndexDataType);
                    if (IndexColor > 0)
                        ColorNameIs = Color_TableName(IndexColor);
                    else
                        ColorNameIs = "Black";
                }
                else
                    ColorNameIs = "Red";
            }
            else if (IndexColor > 0)
                // TempSize = 2
                ColorNameIs = MyColorName;

            TempSize = FindMySize(DataTypeName, ColorNameIs); // size is only valid for datatypes
            MyGetPen_Static(ColorNameIs, "");
            MinePen = GetMyPen;

            ScreenPoint = Copy2ScreenXY(Where, XY);
            MyRec.X = ScreenPoint.Xx - System.Convert.Tolong(TempSize / (double)2);
            MyRec.Y = ScreenPoint.Yy - System.Convert.Tolong(TempSize / (double)2);
            MyRec.Width = TempSize;
            MyRec.Height = TempSize;
            Where.CreateGraphics.DrawEllipse(MinePen, MyRec);
        }


        // Routine this draws a circle where each error is 
        // bug 'todo clrname is being passed the name of the point
        void MyDrawCircle_At(string Where, MyPointStructure xy, string TextString, string clrName)
        {
            long IndexColor;
            string MyColorName;

            // Just to make sure we have a valid color (Do I need this?)
            CheckForAnySortNeeded("", 176);
            IndexColor = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, clrName);
            CheckForAnySortNeeded("", 177);
            if (IndexColor == constantMyErrorCode)
            {
                MyColorName = MyUniverse.ProgramOptions.SelectedColor;
                IndexColor = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, MyColorName);
                if (IndexColor == constantMyErrorCode)
                    MyColorName = clrName;
            }
            else
                MyColorName = clrName;

            MyDrawCircle(Where, xy, MyColorName, ""); // Color, not datatype

            // Display Point Names **** This acuallty dispklayed symbol name
            // MyDrawText(Where, MyOffset(xy, CStr(MyUniverse.OptionDisplay(1).X), CStr(MyUniverse.OptionDisplay(1).Y)), TextString, 20)
            MyDrawText(Where, MyOffset(xy, System.Convert.ToString(MyUniverse.OptionDisplay[1].X), System.Convert.ToString(MyUniverse.OptionDisplay[1].Y)), clrName, 20);
        }



        void Clear_Screen_Only(string Where)
        {
            Where.Image = null; // Clear the screen only (And Not RePaint
            MyDoEvents();
            MyDoEvents();
            MyDoEvents();
        }


        // Routine This will clear the screen and then redraw everything

        void Clear_Screen(string Where)
        {
            // Dim Temp As long
            if (IsNothing(Where.Parent))
                return;

            switch (Where.Parent.Name)
            {
            case "FlowChartScreen":
            {
                if (Where.Parent.Visible == false)
                    return;
                Clear_Screen_Only(Where);
                SetScreenArea();
                MyUniverse.SysGen.ReSize = 987;
                if (FlowChartScreen.PictureBox1.Width == FlowChartScreen.Width - FlowChartScreen.VScrollBar1.Width - 10)
                    MyUniverse.SysGen.ReSize = 0;
                else
                {
                    MyUniverse.SysGen.ReSize = 987; // Flag to not let resize call it's self
                    FlowChartScreen.PictureBox1.Width = FlowChartScreen.Width - FlowChartScreen.VScrollBar1.Width - 10;
                }
                PaintAll(FlowChartScreen.PictureBox1, 1, TopOfFile("FlowChart"));
                break;
            }

            case "SymbolScreen":
            {
                if (Where.Visible == false)
                    return;
                Clear_Screen_Only(Where);

                // Temp = MyUniverse.SysGen.Constants.constantSymbolCenter
                if (MyUniverse.ProgramOptions.SelectedSymbolName != "")
                    // PaintEach(SymbolScreen.PictureBox1, MyPoint1XY(Temp, Temp), MyUniverse.ProgramOptions.SelectedSymbolName, "Default")
                    PaintEach(SymbolScreen.PictureBox1, ZeroZero, MyUniverse.ProgramOptions.SelectedSymbolName, "Default");
                break;
            }
            }
        }




        // Routine this keeps track of where the working area is located, 
        void SetScreenArea()
        {
            MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx = MyUniverse.MyStaticData.MinXY.Xx - ScaledSize(100);
            MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy = MyUniverse.MyStaticData.MinXY.Yy - ScaledSize(100);
            MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx = MyUniverse.MyStaticData.MaxXY.Xx + ScaledSize(100);
            MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy = MyUniverse.MyStaticData.MaxXY.Yy + ScaledSize(100);
        }




        long FindSymbol_StartIndex(string SymbolName)
        {
            long IndexNamed;
            CheckForAnySortNeeded("", 180); // hack
            FindSymbol_StartIndex = FindInSymbolList(ref SymbolName);
            CheckForAnySortNeeded("", 181); // hack
            if (FindSymbol_StartIndex == constantMyErrorCode)
            {
                Abug(174, "Not able To find symbol name ", SymbolName, 0);
                return FindSymbol_StartIndex; // not named symbol
            }
            if (Strings.LCase(Symbol_TableSymbolName(FindSymbol_StartIndex)) == Strings.LCase(SymbolName))
                // A I N F O 2 (99)
                return FindSymbol_StartIndex;// Indexes is to the right place

            // wrong Indexes here, so fix if possible, otherwise change Indexes back to a 0 to search every time(yuck)
            for (IndexNamed = 1; IndexNamed <= TopOfFile("named"); IndexNamed++)
            {
                FindSymbol_StartIndex = Named_TableSymbolIndexes(IndexNamed);
                if (Symbol_TableCoded_String(FindSymbol_StartIndex) == "/name")
                {
                    if (Strings.LCase(Symbol_TableSymbolName(FindSymbol_StartIndex)) == Strings.LCase(SymbolName))
                    {
                        Named_TableSymbolIndexes(IndexNamed); // short cut
                        // A I N F O 2 (100)
                        return FindSymbol_StartIndex;
                    }
                    else
                        Named_TableSymbolIndexes(FindSymbol_StartIndex, 0);// Lost the Indexes
                }
                else
                    Named_TableSymbolIndexes(FindSymbol_StartIndex, 0);// Lost the Indexes
            }
            Named_TableSymbolIndexes(FindSymbol_StartIndex, 0); // Fix wrong point, and not able to find it anyway.
            Abug(175, "Unable To find this symbol name. ", SymbolName, 0);
            return constantMyErrorCode; // not findable
        }

        // Routine 
        void DisplayOBject(string Where, MyPointStructure XYOffsets, string symbolName, string RotationName)
        {
            PaintEach(Where, XYOffsets, symbolName, RotationName);
        }

        long MyFindSymbolPoint(MyPointStructure MyXY, string SymbolName)
        {
            long IndexSymbol;
            long IndexStart;
            long Dist1, Dist3;

            Dist1 = 10000000; // biggest number possible
            Dist3 = Dist1;

            IndexStart = FindSymbol_StartIndex(SymbolName);

            MyFindSymbolPoint = constantMyErrorCode;
            if (IndexStart == constantMyErrorCode)
            {
                Abug(176, "Can Not find the symbol name ", SymbolName, 0);
                return constantMyErrorCode;
            }
            IndexStart += 1;
            for (IndexSymbol = IndexStart; IndexSymbol <= TopOfFile("Symbol"); IndexSymbol++)
            {
                switch (Symbol_TableCoded_String(IndexSymbol))
                {
                    case "/name"  // Next name so skip it
                        :
                    {
                        break;
                        break;
                    }

                    case "/point":
                    {
                        Dist1 = MyDistance(MyXY, MyRotated_1(IndexSymbol, ZeroZero, "Default"));
                        if (Dist1 < Dist3)
                        {
                            MyFindSymbolPoint = IndexSymbol;
                            Dist3 = Dist1;
                        }

                        break;
                    }

                    case "/line":
                    {
                        // Dist1 = MyABS(MyXY.xx - Symbol_TableX1(Index)) + MyABS(Myxy.yy - Symbol_TableY1(Index))
                        Dist1 = MyDistance(MyXY, MyRotated_1(IndexSymbol, ZeroZero, "Default"));
                        if (Dist1 < Dist3)
                        {
                            MyFindSymbolPoint = IndexSymbol;
                            Dist3 = Dist1;
                        }
                        Dist1 = MyDistance(MyXY, MyRotated_2(IndexSymbol, ZeroZero, "Default"));
                        if (Dist1 < Dist3)
                        {
                            MyFindSymbolPoint = IndexSymbol;
                            Dist3 = Dist1;
                        }

                        break;
                    }

                    default:
                    {
                        break;
                    }
                }
            }
        }


        // finds the closest symbol center, each end of the paths, 
        // Does not search itself FromIndex
        long MyFindPoint(string Where, MyPointStructure MyXY, long FromIndexFlowChart) // Find the Symbol/Path/point/Line closest to X & Y
        {
            long IndexFlowChart, IndexNamed;
            long StartIndexNamedAt;
            long Idex;
            long Dist1, Dist3;

            MyFindPoint = constantMyErrorCode;
            Dist1 = 10000000; // biggest number possible
            Dist3 = Dist1;
            switch (Where.Parent.Name)
            {
            case "FlowChartScreen":
            {
                MyFindPoint = constantMyErrorCode;
                for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
                {
                    if (IndexFlowChart != FromIndexFlowChart)
                    {
                        switch (Strings.LCase(Strings.Trim(FlowChart_TableCode(IndexFlowChart))))
                        {
                        case "/use":
                        {
                            Dist1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart));
                            if (Dist1 < Dist3)
                            {
                                MyFindPoint = IndexFlowChart;
                                Dist3 = Dist1;
                            }

                            break;
                        }

                        case "/path":
                        {
                            Dist1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart));
                            if (Dist1 < Dist3)
                            {
                                MyFindPoint = IndexFlowChart;
                                Dist3 = Dist1;
                            }
                            // Dist1 = MyABS(MyXY.xx - FlowChart_TableX2(IndexFlowChart  )) + MyABS(Myxy.yy - FlowChart_TableY2(IndexFlowChart  ))
                            Dist1 = MyDistance(MyXY, MyPoint2_2XY(IndexFlowChart));
                            if (Dist1 < Dist3)
                            {
                                MyFindPoint = IndexFlowChart;
                                Dist3 = Dist1;
                            }

                            break;
                        }

                        case "/constant":
                        {
                            // Dist1 = MyABS(MyXY.xx - FlowChart_TableX1(IndexNamed)) + MyABS(Myxy.yy - FlowChart_TableY1(IndexNamed))
                            Dist1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart));
                            if (Dist1 < Dist3)
                            {
                                MyFindPoint = IndexFlowChart;
                                Dist3 = Dist1;
                            }

                            break;
                        }

                        case "/unknown":
                        {
                            break;
                        }

                        case "/delete":
                        {
                            break;
                        }

                        case "/error":
                        {
                            break;
                        }

                        default:
                        {
                            Abug(177, "Ignore flowchart TypeOf ", "", MyShowFlowChartRecord(IndexFlowChart));
                            break;
                        }
                        }
                    } // skip searching for yourself
                }

                break;
            }

            case "SymbolScreen" // Find the active point for the selected symbol table
                :
            {
                CheckForAnySortNeeded("", 182);
                StartIndexNamedAt = FindIndexIniSAMTable("Named", "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, MyUniverse.ProgramOptions.SelectedSymbolName);
                CheckForAnySortNeeded("", 183);
                if (StartIndexNamedAt != constantMyErrorCode)
                    // Bug This is wrong because the selected item is a string, and the p() requires a number
                    // 'hack  If I stop here then find and fix the issues'
                    StartIndexNamedAt = Named_TableSymbolIndexes(My_INT(MyUniverse.ProgramOptions.SelectedSymbolName)); // , IndexNamed) ' Shortcut
                else
                    // Abug(178, StartIndexNamedAt, MyXY.Xx, MyXY.Yy)
                    StartIndexNamedAt = 1;

                if (Strings.LCase(Symbol_TableSymbolName(StartIndexNamedAt)) != "/name")
                {
                    Named_TableSymbolIndexes(StartIndexNamedAt, 1);
                    StartIndexNamedAt = 1;
                }


                for (IndexNamed = StartIndexNamedAt; IndexNamed <= TopOfFile("Symbol"); IndexNamed++)
                {
                    if (Symbol_TableCoded_String(IndexNamed) == "/name")
                    {
                        // 
                        if (Strings.LCase(Strings.Trim(Symbol_TableSymbolName(IndexNamed))) == Strings.LCase(Strings.Trim(MyUniverse.ProgramOptions.SelectedSymbolName)))
                        {
                            Idex = IndexNamed;
                            while (Idex < TopOfFile("Symbol") - 1)
                            {
                                FindingMyBugs(10); // hace Least amount of checking here
                                                   // MyMsgCtr(1038, "MyFindPoint", Symbol_TableCoded_String(Idex), Idex.ToString, MyXY.Xx.ToString, MyXY.Yy.ToString, "", "", "", "", "")
                                Idex += 1;
                                switch (Symbol_TableCoded_String(Idex))
                                {
                                case "/name":
                                    case "/constant"  // Added constant incase we are at the end
                                        :
                                    {
                                        // A I N F O 2 (146)
                                        return;
                                    }

                                    case "/point":
                                    {
                                        // Dist1 = MyABS(MyXY.xx - Symbol_TableX1(Idex)) + MyABS(Myxy.yy - Symbol_TableY1(Idex))
                                        Dist1 = MyDistance(MyXY, MyPoint1XY(Idex));
                                        if (Dist1 < Dist3)
                                        {
                                            MyFindPoint = Idex;
                                            Dist3 = Dist1;
                                        }

                                        break;
                                    }

                                    case "/line":
                                    {
                                        // Dist1 = MyABS(MyXY.xx - Symbol_TableX1(Idex)) + MyABS(Myxy.yy - Symbol_TableY1(Idex))
                                        Dist1 = MyDistance(MyXY, MyPoint1XY(Idex));
                                        if (Dist1 < Dist3)
                                        {
                                            MyFindPoint = Idex;
                                            Dist3 = Dist1;
                                        }
                                        // Dist1 = MyABS(MyXY.xx - Symbol_TableX2_io(index)) + MyABS(Myxy.yy - Symbol_TableY2_dt(index))
                                        Dist1 = MyDistance(MyXY, MyPoint2_2XY(Idex));
                                        if (Dist1 < Dist3)
                                        {
                                            MyFindPoint = Idex;
                                            Dist3 = Dist1;
                                        }

                                        break;
                                    }

                                    default:
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                break;
            }

            case "OptionScreen" // Never happen
                :
            {
                FindingMyBugs(10);// hace Least amount of checking here
                break;
            }

            case "FileIOScreen":
            {
                FindingMyBugs(10);// hace Least amount of checking here
                break;
            }

            case "StatusScreen":
            {
                FindingMyBugs(10); // hace Least amount of checking here
                break;
            }

            default:
            {
                FindingMyBugs(10); // hace Least amount of checking here
                break;
            }
            }
        }



        // Routine this finds where to start everything at
        long Find_Start(string Where)
        {
            long Index;

            MyMsgCtr(1090, "Find_Start", "", "", "", "", "", "", "", "", "");
            // This sets up to run the interactive
            for (Index = 1; Index <= TopOfFile("FlowChart"); Index++)
            {
                if (Strings.LCase(Strings.Trim(FlowChart_TableCode(Index))) == "/use")
                {
                    if (Strings.UCase(FlowChart_TableSymbol_Name(Index)) == "START" | Strings.UCase(FlowChart_TableSymbol_Name(Index)) == "MAIN")
                    {
                        MyUniverse.ProgramOptions.SelectedObject = Index;
                        Find_Start = Index;
                        ReSetScrollBars(Index);
                        Clear_Screen(Where);
                        // A I N F O 2 (147)
                        return;
                    }
                }
            }
            // MyMsgCtr(1214, "Find_Start", "", "", "", "", "", "", "", "", "")
            Find_Start = constantMyErrorCode;
            FindingMyBugs(10); // hace Least amount of checking here
        }


        // Routine while getpoint is 1 (true) then getting the next point
        MyPointStructure GetPoint(long IndexFlowChart, MyPointStructure atXY, long CountOfPoints)  // Get the closest Point to X & Y 
        {
            long IndexSymbol;

            CheckForAnySortNeeded("", 184); // hack
            IndexSymbol = FindInSymbolList(ref FlowChart_TableSymbol_Name(IndexFlowChart));
            CheckForAnySortNeeded("", 185); // hack
            if (IndexSymbol == constantMyErrorCode)
            {
                Abug(179, CountOfPoints, FlowChart_TableSymbol_Name(IndexFlowChart), TopOfFile("Symbol"));
                GetPoint = ZeroZero; // failed to get this point number (because the symbol doesn't exist)
                // A I N F O 2 (148)
                return;
            }

            IndexSymbol += 1; // Jump over the name of this symbol

            // Count down till we have the point number
            FindingMyBugs(10); // hace Least amount of checking here
            while (CountOfPoints > 1 & IndexSymbol < TopOfFile("Symbol") - 1)
            {
                // MyMsgCtr(1028, "GetPoint", Symbol_TableCoded_String(IndexSymbol), IndexSymbol.ToString, "", "", "", "", "", "", "")
                switch (Symbol_TableCoded_String(IndexSymbol))
                {
                    case "/name"         // Next symbol
                        :
                    {
                        GetPoint = ZeroZero;    // No more points in the symbol table
                                                // A I N F O 2 (149)
                        return;
                    }

                    case "/point":
                    {
                        if (CountOfPoints < 0)
                        {
                            GetPoint = ZeroZero;    // No more points in the symbol table
                                                    // A I N F O 2 (150)
                            return;
                        }
                        if (CountOfPoints == 0)
                        {
                            atXY = MyRotated(IndexSymbol, IndexFlowChart);
                            GetPoint = atXY;     // We have the count of points into the sumbol
                                                 // A I N F O 2 (151)
                            return;
                        }
                        CountOfPoints -= 1; // CountOfPoints = CountOfPoints -1 ' get the next one
                        break;
                    }

                    default:
                    {
                        Abug(181, "GetPoint unknown code", Symbol_TableCoded_String(IndexSymbol), "");
                        break;
                    }
                }
            }
            FindingMyBugs(10); // hace Least amount of checking here
            GetPoint = ZeroZero;    // Should never get here 
        }



        // Routine Testing for two points inside the screen
        bool InSideMyScreen(string Where, MyPointStructure RealWorld1, MyPointStructure RealWorld2)
        {
            MyPointStructure WhereAt1XY;
            MyPointStructure WhereAt2XY;
            WhereAt1XY = Copy2ScreenXY(Where, RealWorld1);
            WhereAt2XY = Copy2ScreenXY(Where, RealWorld2);

            // All Left of my screen
            if (WhereAt1XY.Xx < MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx & WhereAt2XY.Xx < MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx)
                // A I N F O 2 (159)
                return false;
            // All Right of my screen
            if (WhereAt1XY.XX > MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx & WhereAt2XY.XX > MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx)
                // A I N F O 2 (160)
                return false;
            // All abobe my screen
            if (WhereAt1XY.Yy < MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy & WhereAt2XY.Yy < MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy)
                // A I N F O 2 (161)
                return false;
            if (WhereAt1XY.Yy > MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy & WhereAt2XY.Yy > MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy)
                // A I N F O 2 (162)
                return false;
            // Else It miight be true, 

            // A I N F O 2 (163)
            return true;
        }


        // Routine Texting for single point inside the screen
        bool InSideMyScreen(string Where, MyPointStructure RealWorld)
        {
            MyPointStructure WhereAt1XY;
            if (MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx == 0)
            {
                if (MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy == 0)
                {
                    if (MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx == 0)
                    {
                        if (MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy == 0)
                            // A I N F O 2 (-164)
                            return true;// cause we dont know yet how big the screen is , so everthing i sconsidered inside
                    }
                }
            }
            return true;

            WhereAt1XY = Copy2ScreenXY(Where, RealWorld);

            // All Left of my screen
            if (WhereAt1XY.xX < MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx)
            {
                // MyMsgCtr(1260, "InSideMyscreen", MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy.ToString, "", "", "", "", "")
                InSideMyScreen = false;
                return;
            }
            // All Right of my screen
            if (WhereAt1XY.Xx > MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx)
            {
                // MyMsgCtr(1260, "InSideMyscreen", MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy.ToString, "", "", "", "", "")
                InSideMyScreen = false;
                return;
            }
            // All abobe my screen
            if (WhereAt1XY.Yy < MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy)
            {
                // MyMsgCtr(1260, "InSideMyscreen", MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy.ToString, "", "", "", "", "")
                InSideMyScreen = false;
                return;
            }
            if (WhereAt1XY.Yy > MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy)
            {
                // MyMsgCtr(1260, "InSideMyscreen", MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx.ToString, MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy.ToString, "", "", "", "", "")
                InSideMyScreen = false;
                return;
            }
            // Else It miight be true, 

            InSideMyScreen = true;
            return;
        }

        // test of it is all ouside of the other
        bool IsBetween(MyLineStructure A, MyLineStructure B)
        {
            if (A.b.Xx < B.a.Xx)
                return false; // a left of b
            if (A.a.Xx > B.b.Xx)
                return false; // a right of b
            if (A.b.Yy < B.a.Yy)
                return false; // a below b
            if (A.a.Yy > B.b.Yy)
                return false; // a above b
            // A I N F O 2 (102)
            return true;
        }

        // ************************************************************************************************************
        // Between the first value and the third value, this compares where the second (middle) value belongs at.
        // Test #	Results	Testing A, b, C
        // 1   5	        b=nothing
        // 2   0  	    A And C = nothing
        // 3   -1	        A=b
        // 4   1  	    b=C
        // 5   -4 	    A=nothing And b< C
        // 6   4	        C=nothing And b > A
        // 7   -4 	    A=Nothing
        // 8   4	        C = nothing
        // 9   -5 	    A > C 'Unsorted List
        // 10  0	        A<b<C 'not in the list but should go between these
        // 11  -3	        A>b
        // 12  -2 	    b > C
        // 13  3	        b < C
        // 14  2  	    A < b
        // 15  5	        default fails everything above (Should never happen)


        byte MyCompared3(string StringA, string StringB, string StringC)
        {
            string A, B, C;
            // Test #	Results	Testing A, b, C
            // 1   5	    b=nothing (So you are at the end of the list (Assume that B > a or A = nothing)
            // 2   0  	A And C = nothing (No Items in the list , empty list)
            // 3   -1	    A=b
            // 4   1  	b=C
            // 5   -4 	A=nothing And b< C
            // 6   4	    C=nothing And b > A
            // 7   -4 	A=Nothing
            // 8   4	    C = nothing
            // 9   -5 	A > C 'Unsorted List
            // 10  0	    A<b<C 'not in the list but should go between these
            // 11  -3	    A>b
            // 12  -2 	b > C
            // 13  3	    b < C
            // 14  2  	A < b
            // 15  5	    default fails everything above (Should never happen)
            A = Strings.LCase(MyTrim(StringA));
            B = Strings.LCase(MyTrim(StringB));
            C = Strings.LCase(MyTrim(StringC));

            // 2020-12-12 Added test to make sure that A is not null (or nothing)
            if (!(Information.IsNothing(StringA) | A == "") & (Information.IsNothing(StringB) | B == ""))
                // A I N F O 2 (103)
                return 5;// End of the list (and not the beggining of the list
            // First One in the List is between them 
            if (IsNullOrNothing(A) & IsNullOrNothing(C) & !Information.IsNothing(StringB))
                // A I N F O 2 (-104)
                return 0;// First item in the list
            // -1 A = B
            if (A == B)
                // ' A I N F O 2 (105)
                return -1;
            // 1 B = C
            if (B == C)
                // ' A I N F O 2 (106)
                return 1;
            // -4 A = start Of list (So Lowest)
            if (IsNullOrNothing(A) & B < C)
                // A I N F O 2 (-107)
                return -4;// Start of the list (See below also)
            // 4 C is the end of the list (So Highest)
            if (IsNullOrNothing(C) & B > A)
                // ' A I N F O 2 (108)
                return 4;// end of the list (See below also)

            // 2020 07 31 'special case if there is a sortedd list at the top or bottom
            if (A == C & B < C)
                // A I N F O 2 (-109)
                return -4;// Start of the list (See below also)' Or ELSE you have A and B the same (index array item)
            // 4 C is the end of the list (So Highest)
            if (A == C & B > A)
                // ' A I N F O 2 (110)
                return 4;// end of the list (See below also)

            if (IsNullOrNothing(A))
                // A I N F O 2 (-111)
                return -4;// Start of the list?
            if (IsNullOrNothing(C) & A > B)
                // A I N F O 2 (-112)
                return -3;// Added 2021/01/07
            // 4 C is the end of the list (So Highest)
            if (IsNullOrNothing(C))
                // A I N F O 2 (113)
                return 4;// end of the list (Also)?
            // -5 A is not <= than C (A>C) Error
            if (A > C)
                // A I N F O 2 (-114)
                return -5;
            // 0 B is between A and C
            if ((A < B) & (B < C))
                // ' A I N F O 2 (115)
                return 0;
            // -3 A is higher than B  
            if (A > B)
                // ' A I N F O 2 (116)
                return -3;
            // -2 B is higher than C
            if (B > C)
                // ' A I N F O 2 (117)
                return -2;
            // 3 C is higher then B
            if (B < C)
                // A I N F O 2 (118)
                return 3;
            // 2 A is lower than B 
            if (A < B)
                // A I N F O 2 (119)
                return 2;
            // 5 Error
            Abug(183, A, B, C);
            // A I N F O 2 (120)
            return 5; // default error
        }

        // *******************************************************************
        // This is used for checking if the indexes are valid or not
        long MyCompared2(string MyArray[], long iSAM[], long A, long B)
        {
            if (InvalidIndex(A, ref MyArray, ref iSAM))
                return -5;
            if (InvalidIndex(B, ref MyArray, ref iSAM))
                return -5;
            if (InvalidIndex(iSAM[A], ref MyArray, ref iSAM))
                return -5;
            if (InvalidIndex(iSAM[B], ref MyArray, ref iSAM))
                return -5;
            MyCompared2 = MyCompared1_a(MyArray[iSAM[A]], MyArray[iSAM[B]]);
        }


        int MyCompared2(long MyArrayLong[], long iSAM[], long A, long B)
        {
            if (InvalidIndex(A, Myarraylong, ref iSAM))
            {
                MyCompared2 = -5;
                return;
            }
            if (InvalidIndex(B, Myarraylong, ref iSAM))
            {
                MyCompared2 = -5;
                return;
            }
            if (InvalidIndex(iSAM[A], Myarraylong, ref iSAM))
            {
                MyCompared2 = -5;
                return;
            }
            if (InvalidIndex(iSAM[B], Myarraylong, ref iSAM))
            {
                MyCompared2 = -5;
                return;
            }
            MyCompared2 = MyCompared1(Myarraylong[iSAM[A]], Myarraylong[iSAM[B]]);
        }



        int MyCompared1(long A, long B)
        {
            // -2 A = start Of list (So Lowest)
            // -1 A is lower than B (Default if nothing else)
            // 0 A and B match 
            // 1 A is higher than B
            // 2 B is the end of the list (So Highest)

            if (A == B)
                // A I N F O 2 (128)
                return 0;
            // If the first Is nothing then it is considered the largest
            if (Information.IsNothing(A))
                // A I N F O 2 (129)
                return -2;// Nothing or null is always the highest
            // If the second is nothing then 
            if (Information.IsNothing(B))
                // A I N F O 2 (130)
                return 2;// You are always searching for something less than nothing or a null

            // Now we can actually test the two string
            if (A > B)
                // A I N F O 2 (131)
                return 1;
            // The default is A < B and anything else is false
            if (B > A)
                // A I N F O 2 (132)
                return -1;
            // Al conditions should have been meet
            Abug(184, "A And B Is Not comparable ", A, B);
            return -5; // Error
        }

        // ***************************************************************************************
        // -2=(start), -1=(A<B), 0=(A=B),1=(A>B),2=(B=End)
        // Compare two strings to see the order they should be in
        // -2 A = start Of list (So Lowest)
        // -1 A is lower than B (Default if nothing else)
        // 0 A and B match 
        // 1 A is higher than B
        // 2 B is the end of the list (So Highest)


        int MyCompared1_a(string StringA, string StringB)
        {
            string A, B;

            // -2 A = start Of list (So Lowest)
            // -1 A is lower than B (Default if nothing else)
            // 0 A and B match 
            // 1 A is higher than B
            // 2 B is the end of the list (So Highest)

            A = Strings.LCase(MyTrim(StringA));
            B = Strings.LCase(MyTrim(StringB));
            if (A == B)
                return 0;
            // If the first Is nothing then it is considered the largest
            if (A == "_" | A == "" | Information.IsNothing(A))
                return -2;// Nothing or null is always the highest
            // If the second is nothing then 
            if (B == "_" | B == "" | Information.IsNothing(B))
                return 2;// You are always searching for something less than nothing or a null

            // Now we can actually test the two string
            if (A > B)
                return 1;
            // The default is A < B and anything else is false
            if (B > A)
                return -1;
            // Al conditions should have been meet
            Abug(185, "A And B Is Not comparable ", A, B);
            return -5; // Error
        }

        string ComputerFileNamesAre()
        {
            ComputerFileNamesAre = MyUniverse.ProgramOptions.C_L_LanguageClassName;
            ComputerFileNamesAre = ComputerFileNamesAre + " (*." + MyUniverse.ProgramOptions.C_L_Extention + ")" + "|*." + MyUniverse.ProgramOptions.C_L_Extention + "|";
            ComputerFileNamesAre += "all files (*.*)|*.*";
        }


        // CHeck if this name is used, and then return one that is not used.
        string MakeNextName(string SymbolName)
        {
            MakeNextName = SymbolName;
            while (FindInNamedList(MakeNextName) > 1)
                MakeNextName = MakeNextName + VBMath.Rnd(10);
        }






        string FindSymbolName(long IndexSymbol) // Finds tha name of the symbol from the index in the graphic symbols
        {
            long Idex;
            Idex = IndexSymbol;
            while (Idex > 0 & Symbol_TableCoded_String(Idex) != "/name")
                Idex -= 1;
            // A I N F O 2 (121)
            return Symbol_TableSymbolName(Idex);
        }

        string My_VariableName(string CodeLine, long NumberOfTheVariable, long LineNumber) // This should return the name of the variabl
        {
            // ERROR this is not getting the correct variable name
            string[] MyArray = new string[2];
            long Idex;
            string Temp1, Temp2;

            PathNames = MyParse(ref MyArray, CodeLine);

            Temp1 = PathNames;
            for (Idex = 1; Idex <= NumberOfTheVariable; Idex++)
            {
                Temp2 = Pop(ref Temp1, FD);
                if (Idex == NumberOfTheVariable)
                {
                    Temp1 = PathNames; // hack debug only 
                    Temp2 = NoFD(Temp2);
                    if (Strings.Len(Temp2) < 1)
                    {
                        Abug(480, "Check the variable numbered " + Constants.vbCrLf + HighLight(Temp1) + Constants.vbCrLf + HighLight(Temp2), NumberOfTheVariable, Temp1);
                        My_VariableName = MakePathName("vV_" + Strings.Right(My_INT(VBMath.Rnd() * 100000000 + 100000000).ToString(), 6));
                        PathNames += My_VariableName + FD;
                        return NameOfPointOnly(My_VariableName);
                    }
                    return NameOfPointOnly(Temp2);
                }
            }


            Idex = Information.UBound(MyArray);
            if (NumberOfTheVariable > Idex)
            {
                AInfo1(713, "The number of points is greater then the number of items parsed", Idex, NumberOfTheVariable);
                return NoWhiteSpaceS(CodeLine) + "___" + NumberOfTheVariable + "___" + Idex;
            }
            // My_VariableName = "_" & NoWhiteSpaceS(MyArray(NumberOfTheVariable)) & "_" & NumberOfTheVariable & "_" & MyUniverse.MySS.Inputs.LineNumberIn ' This Should Never Be used
            My_VariableName = "V_PathName_";
            for (Idex = 1; Idex <= Information.UBound(MyArray); Idex++)
            {
                switch (No_FieldDelimiter(ThisIsAWhat(MyArray[Idex])))
                {
                case "C_L_MultiLine":
                {
                    break;
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine // These requires a point on the symbol 2020 08 26
                    :
                {
                    if (NumberOfTheVariable == Idex)
                        return MyArray[Idex];// +1))
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                {
                    if (NumberOfTheVariable == Idex)
                        return MyArray[Idex];// +1) )
                    break;
                }

                case "C_L_Comment":
                {
                    break;
                }

                case "C_L_Extention":
                {
                    break;
                }

                case "C_L_VarChars":
                {
                    break;
                }

                case "number" // missing 2020 09 28
                    :
                {
                    My_VariableName += "0";
                    if (NumberOfTheVariable == Idex)
                        return MyArray[Idex] + "_" + NumberOfTheVariable;
                    break;
                }

                case "alpha" // missing  2020 09 28
                    :
                {
                    My_VariableName += "A";
                    if (NumberOfTheVariable == Idex)
                        // A I N F O 2 (134)
                        return MyArray[Idex];// & "_" & NumberOfTheVariable ' took back out 2020 08 20
                    break;
                }

                case "Variable":
                {
                    My_VariableName += "V";
                    if (NumberOfTheVariable == Idex)
                        return MyArray[Idex];
                    break;
                }

                case "Quote":
                {
                    // Need to change this to make a Quote a /constant and the name of the point Quote_LineNumber
                    // My_VariableName = MyArray(Idex) '& "_" & NumberOfTheVariable ' took back out 2020 08 20
                    My_VariableName += "Q";
                    if (NumberOfTheVariable == Idex)
                    {
                        ainfo2(114);
                        return "Quote_" + LineNumber;
                    }

                    break;
                }

                case "Keyword":
                case "Operator":
                    case "Function" // Ignore these keyWord types' Added 2021/01/05                        '
                        :
                    {
                        My_VariableName += MyArray[Idex];
                        break;
                    }

                    case null:
                    case "FieldDelimiter":
                    {
                        My_VariableName += "";
                        break;
                    }

                    case "SpecialCharacter":
                    {
                        My_VariableName += "_";
                        break;
                    }

                    default:
                    {
                        if (ThisIsAVariableName(MyArray[Idex]) == true)
                        {
                            My_VariableName += "v";
                            if (NumberOfTheVariable == Idex)
                                // return just the name of this
                                return Strings.Mid(MyArray[Idex], Strings.Len(MyUniverse.SysGen.Constants.RMStart) + 1, Strings.InStr(MyArray[Idex], ".") - Strings.Len(MyUniverse.SysGen.Constants.RMStart) - 1);
                        }
                        else
                            Abug(186, "Unknown Syntax key " + HighLight(ThisIsAWhat(MyArray[Idex])) + " In My_Variable Name at " + Idex, HighLight(MyArray[Idex]), HighLight(CodeLine));
                        break;
                    }
                }
            }
            return MakeNextName(My_VariableName);
        }



        string keyWordForCodeLine(string codeline)
        {
            string[] Temp = new string[2];
            long I;


            keyWordForCodeLine = "";
            PathNames = MyParse(ref Temp, codeline); // Parse the code line then
            for (I = 1; I <= Information.UBound(Temp); I++)
            {
                switch (ThisIsAWhat(Temp[I]))
                {
                case "variable":
                {
                    keyWordForCodeLine += "V";
                    break;
                }

                case "KeyWord":
                case "Function":
                {
                    keyWordForCodeLine += Temp[I];
                    break;
                }

                case "CameFromLine" // Ignore for a name
                    :
                {
                    keyWordForCodeLine += "1";
                    break;
                }

                case "GotoNextLine" // Ignore for a name
                    :
                {
                    keyWordForCodeLine += "2";
                    break;
                }

                case "Operator":
                {
                    keyWordForCodeLine += Temp[I];
                    break;
                }

                case "SpecialCharacter":
                {
                    keyWordForCodeLine += "_";
                    break;
                }

                case "Quote":
                {
                    keyWordForCodeLine += "Q";
                    break;
                }

                case "MultiLine":
                {
                    keyWordForCodeLine += "Multiline not allowed right now";
                    break;
                }

                case null:
                case "FieldDelimiter":
                case FD:
                {
                    // AInfo1( 9 9 9 ,  "Nothing, comma", ThisIsAWhat(Temp(I)), "")
                    keyWordForCodeLine += "";
                    break;
                }

                case "C_L_Comment":
                {
                    break;
                }

                case "C_L_Extention":
                {
                    break;
                }

                case "C_L_MultiLine":
                {
                    keyWordForCodeLine += ":";
                    break;
                }

                case "C_L_VarChars":
                {
                    break;
                }

                default:
                {
                    keyWordForCodeLine += ThisIsAWhat(Temp[I]);
                    break;
                }
                }
            }
        }

        string MakeNewName(string StartOfName, long LineNumber, string Codeline)
        {
            MyMakeArraySizesBigger();
            if (MyUniverse.SysGen.HighestSymbolNumber < 100)
                MyUniverse.SysGen.HighestSymbolNumber = PopValue(ref Strings.Mid(DateTime.TimeString, 7, 2) + Strings.Mid(DateTime.TimeString, 4, 2) + Strings.Mid(DateTime.TimeString, 1, 2));
            MyUniverse.SysGen.HighestSymbolNumber += 1;

            // MakeNewName = StartOfName & "_" & MyUniverse.MySS.Inputs.LineNumberIn & "_" & MyUniverse.SysGen.HighestSymbolNumber & "_" & keyWordForCodeLine()
            MakeNewName = StartOfName + MyUniverse.MySS.Inputs.LineNumberIn + "_" + keyWordForCodeLine(Codeline);
            return MakeNextName(MakeNewName);
        }


        // This inserts all new records after the end of the /name, instead of at the end of the list after name (before the next /name)
        long AddNEWFlowChartRecordPath(string SymbolName, string Coded, long X1, long Y1, string X2_io, string Y2_dt, string MyDataType, long LineNumber)
        {
            MyMakeArraySizesBigger();
            // AddNEWFlowChartRecordPath = NewTopOfFile("FlowChart")
            AddNEWFlowChartRecordPath = AddFlowChartRecordOther(SymbolName, Coded, X1, Y1, My_INT(X2_io), My_INT(Y2_dt), MyDataType.ToString(), "", LineNumber);
            ConnectPath(AddNEWFlowChartRecordPath);
        }
        long AddNEWFlowChartRecordUse(string SymbolName, string Coded, long X1, long Y1, string X2_io, string Y2_dt, string MyDataType, long LineNumber)
        {
            MyMakeArraySizesBigger();
            // AddNEWFlowChartRecordUse = NewTopOfFile("FlowChart")
            AddNEWFlowChartRecordUse = AddFlowChartRecordOther(SymbolName, Coded, X1, Y1, My_INT(X2_io), My_INT(Y2_dt), MyDataType.ToString(), "", LineNumber);
        }


        void AddNEWSymbolLineRecord(string SymbolName, string Coded, long X1, long Y1, long X2, long Y2, string MyName_Of_Point, long LineNumber)
        {
            long IndexSymbol, IndexNamed;
            string PointName;

            // FindingMyBugs(90) 'hack Least amount of checking here
            PointName = MyName_Of_Point;
            PointName = Pop(ref PointName, MyUniverse.SysGen.Constants.ConstantDelimeters); // make sure that it is only one word
            MakeItTheBiggestSymbolNumber(ref PointName);
            MyMakeArraySizesBigger();

            IndexNamed = FindIndexIniSAMTable("named", "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            if (IndexNamed == constantMyErrorCode)
            {
                IndexNamed = CheckNotInList("named", ref "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref SymbolName);
                if (IndexNamed == constantMyErrorCode)
                {
                    IndexNamed = AddNewNamedRecord(SymbolName, "Missing", "Opcode", "Added Named that was missing", CreateFileNameFromSintax(Coded + MyName_Of_Point, LineNumber), MyUniverse.ProgramOptions.C_L_LanguageClassName, "Auto", "Version", "", "");
                    if (IndexNamed == constantMyErrorCode)
                        Abug(188, "Trying to add symbol graphics to a symbol that has not been created yet", HighLight(SymbolName), "Unable to add this record");
                    ReSortStringArray("named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM);
                    ReSortStringArray("named", ref Named_FileSintax, ref Named_FileSintax_Isam);
                }
            }
            // The following is not return correctly
            IndexSymbol = FindInSymbolList(ref SymbolName); // Search the named 
            // FindingMyBugs(80) 'hack Least amount of checking here
            if (IndexSymbol > 0)
            {
                IndexSymbol += 1; // move to one after the name
                // FindingMyBugs(20) 'hack Least amount of checking here
                MyInsertSymbolLineRecord(IndexSymbol, SymbolName, Coded, MyLine1(X1, Y1, X2, Y2), PointName);
                MyMakeArraySizesBigger();
            }
            else
            {
                // New name and record so add name if not already there (which its not) and then this record
                IndexSymbol = NewTopOfFile("Symbol");
                // AddFlowChartRecord() the record to the end after a New name record cause there is no name record now.
                if (Strings.LCase(Coded) == "/name")
                {
                    UpdateSymbollineRecordAt(IndexSymbol, SymbolName, Coded, X1, Y1, X2, Y2, PointName);
                    FindingMyBugs(50); // hack Least amount of checking here 2020 08 06
                    return;
                }
                else
                {
                    IndexSymbol += 1; // To one after the end of the end of the file 2020 08 06
                    FindingMyBugs(40); // hack Least amount of checking here 2020 08 04
                    MyInsertSymbolLineRecord(IndexSymbol, SymbolName, Coded, MyLine1(X1, Y1, X2, Y2), PointName);
                    FindingMyBugs(30); // hack Least amount of checking here 2020 08 04
                }
            }
            ReSortSymbolList();
            // FindingMyBugs(10) 'hack Least amount of checking here 2020 08 04
            TopOfFile("Symbol"); // This is to update the top of the file counter
        }




        // This inserts all new records after the end of the /name, instead of at the end of the list after name (before the next /name)
        void AddNEWSymbolpointRecord(string SymbolName, string Coded, long X1, long Y1, string IO, string DT, string MyName_Of_Point, long LineNumber)
        {
            long IndexSymbol, IndexNamed;
            string PointName;
            // FindingMyBugs(80) 'hack Least amount of checking here
            PointName = MyName_Of_Point;
            PointName = Pop(ref PointName, MyUniverse.SysGen.Constants.ConstantDelimeters); // make sure that it is only one word
            MakeItTheBiggestSymbolNumber(ref PointName);
            MyMakeArraySizesBigger();

            IndexNamed = FindIndexIniSAMTable("named", "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            if (IndexNamed == constantMyErrorCode)
            {
                IndexNamed = CheckNotInList("named", ref "donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref SymbolName);
                if (IndexNamed == constantMyErrorCode)
                {
                    // IndexNamed =
                    AddNewNamedRecord(SymbolName, "Missing", "Opcode", "Added Named that was missing", CreateFileNameFromSintax(Coded + MyName_Of_Point, LineNumber), MyUniverse.ProgramOptions.C_L_LanguageClassName, "Auto", "Version", "", "");
                    ReSortStringArray("named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM);
                    ReSortStringArray("named", ref Named_FileSintax, ref Named_FileSintax_Isam);
                }
            }
            // The following is not return correctly
            IndexSymbol = FindInSymbolList(ref SymbolName); // Search the named 
            if (IndexSymbol > 0)
            {
                // FindingMyBugs(10) 'hack Least amount of checking here
                IndexSymbol += 1; // move to one after the name
                // FindingMyBugs(10) 'hack Least amount of checking here
                if (Strings.LCase(Coded) != "/name")
                {
                    // FindingMyBugs(80) 'hack Least amount of checking here 2020 08 04
                    MyInsertSymbolPointRecord(IndexSymbol, SymbolName, Coded, X1, Y1, IO, DT, PointName);
                    MyMakeArraySizesBigger();
                }
                else
                {
                }
            }
            else
            {
                // New name and record so add name if not already there (which its not) and then this record
                IndexSymbol = NewTopOfFile("Symbol");
                // AddFlowChartRecord() the record to the end after a New name record cause there is no name record now.
                if (Strings.LCase(Coded) == "/name")
                {
                    // FindingMyBugs(20) 'hack Least amount of checking here 2020 08 04
                    // We have to have a sumbol name first
                    UpdateSymbolPointRecordAt(IndexSymbol, SymbolName, Coded, X1, Y1, IO, DT, PointName);
                    // FindingMyBugs(20) 'hack Least amount of checking here 2020 08 06
                    return;
                }
                else
                {
                    // We are not updating /name records ever here
                    // UpdateSymbolRecordAt(IndexSymbol, SymbolName, "/name", 0, 0, "both", "Default", "Default")
                    // set the record after 
                    IndexSymbol += 1; // To one after the end of the end of the file 2020 08 06
                    // FindingMyBugs(50) 'hack Least amount of checking here 2020 08 04
                    MyInsertSymbolPointRecord(IndexSymbol, SymbolName, Coded, X1, Y1, IO, DT, PointName);
                }
            }
            ReSortSymbolList();
            // FindingMyBugs(70) 'hack Least amount of checking here 2020 08 04
            TopOfFile("Symbol"); // This is to update the top of the file counter
        }


        // *******************************************************
        // Make a new symbol, or get the data from an old symbol
        // based on the name in the symbol text box
        // 
        // Updates the text boxes on the symbol screen and redraw.

        void MyUpdateSymbolRecordFromSymbolScreen(string What) // undone needs to update the toolstrip symbol selection on both the symbol and flowchart
        {
            long Temp; // max size of a symbol
            long IndexNamed, IndexSymbol;
            SymbolScreen.ComboBoxPointNameList.Text = "";
            SymbolScreen.ComboBoxLineNameList.Text = "";
            Clear_Screen(SymbolScreen.PictureBox1);
            // Me.PictureBox1.Image = Nothing

            mydoevents();
            Temp = MyUniverse.SysGen.Constants.constantSymbolCenter * 2;
            // 
            // PaintEach(SymbolScreen.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the symbol
            IndexNamed = FindiSAM_IN_Table("named", "AddressOf", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, What); // Get where it is in the symbols

            if (IndexNamed == -1)
            {
                // it as a new symbol
                IndexNamed = FindiSAM_IN_Table("named", "Add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, What);
                if (IndexNamed > 0)
                {
                    SymbolScreen.TextBoxNamedProgramText.Text = "";
                    mydoevents();
                    SymbolScreen.TextBoxNamedNameOfFile.Text = What;
                    SymbolScreen.TextBoxNamedNotes.Text = "";
                    SymbolScreen.TextBoxNamedOpCode.Text = "";
                    SymbolScreen.TextBoxNamedStroke.Text = "";
                    mydoevents();
                    MyUniverse.ProgramOptions.SelectedSymbolName = "";
                    SymbolScreen.ComboBoxPointNameList.Text = ""; SymbolScreen.ComboBoxPointNameList.Items.Clear();
                    SymbolScreen.ComboBoxLineNameList.Text = ""; SymbolScreen.ComboBoxLineNameList.Items.Clear();
                    SymbolScreen.TextBoxSymbolVersionAuthor.Text = "";
                    GetSelfCorrectingIndexes(What);
                    mydoevents();
                    PaintEach(SymbolScreen.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default"); // redraw the symbol
                    return;
                }
            }
            else
            {
                mydoevents();
                IndexNamed = Named_FileSymbolName_iSAM[IndexNamed];
                if (IndexNamed <= 0)
                {
                    PaintEach(SymbolScreen.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default"); // redraw the symbol
                    return;
                }
                Named_TableMicroCodeText(IndexNamed, SymbolScreen.TextBoxNamedProgramText.Text);
                Named_TableNameOfFile(IndexNamed, SymbolScreen.TextBoxNamedNameOfFile.Text);
                Named_TableNotes(IndexNamed, SymbolScreen.TextBoxNamedNotes.Text);
                Named_TableOpCode(IndexNamed, SymbolScreen.TextBoxNamedOpCode.Text);
                Named_TableStroke(IndexNamed, SymbolScreen.TextBoxNamedStroke.Text);
                Named_TableSymbolName(IndexNamed, MyUniverse.ProgramOptions.SelectedSymbolName);
                // todo make sure that the verssion and author is formated right (What ever right happends to end up being.)
                Named_TableVersion(IndexNamed, SymbolScreen.TextBoxSymbolVersionAuthor.Text);
                SymbolScreen.ComboBoxPointNameList.Text = "";
                mydoevents();
                // Updating the chint quick Indexes to the symbol
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed);
                if (IndexSymbol > 0)
                {
                    FindingMyBugsCheckForErrors(0, IndexNamed, IndexSymbol);
                    if (Named_TableSymbolName(IndexNamed) == Symbol_TableSymbolName(IndexSymbol))
                    {
                        if (Symbol_TableCoded_String(IndexSymbol) == "/name")
                        {
                            IndexSymbol += 1;
                            while (Symbol_TableCoded_String(IndexSymbol) != "/name" & IndexSymbol < TopOfFile("Symbol"))
                            {
                                if (Symbol_TableCoded_String(IndexSymbol) == "/point")
                                {
                                    SymbolScreen.ComboBoxPointNameList.Text = SymbolScreen.ComboBoxPointNameList.Text + ", " + Symbol_Table_NameOfPoint(IndexSymbol);
                                    mydoevents();
                                }
                                IndexSymbol += 1;
                            }
                        }
                        else
                            GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                    }
                    else
                        GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
                }
                else
                    GetSelfCorrectingIndexes(MyUniverse.ProgramOptions.SelectedSymbolName);
            }
            PaintEach(SymbolScreen.PictureBox1, MyPoint1XY(Temp, Temp), What, "Default"); // redraw the symbol
        }


        void UpdateSymbollineRecordAt(long Idex, string SymbolName, string Coded, long X1, long Y1, long X2, long Y2, string NameOfPoint)
        {
            TopOfFile("Symbol"); // This is to reset the top of file counter only
            FindingMyBugs(10); // hace Least amount of checking here
            if (InvalidIndex(Idex, Symbol_FileSymbolName))
                // Abug(191, "UpdatesymbolRecordAt has an index issue", Idex, " So can Not update Name=" & SymbolName & " code= " & Coded)
                return;
            Symbol_FileCoded[Idex] = MyKeyword_2_Byte(Coded); // I think that I forgot this one.
            Symbol_FileSymbolName[Idex] = SymbolName;
            Symbol_TableX1(Idex, X1);
            Symbol_TableY1(Idex, Y1);
            Symbol_TableX2(Idex, X2); // these have to check for x2 or a io-name
            Symbol_TableY2(Idex, Y2); // these have to check for y2 or a datatype-name
            Symbol_Table_NameOfPoint(Idex, NameOfPoint);
            FindingMyBugs(10); // hack Least amount of checking here ' 2020 07 22
            ReSortSymbolList();
        }




        void UpdateSymbolPointRecordAt(long Idex, string SymbolName, string Coded, long X1, long Y1, string X2_io, string Y2_dt, string NameOfPoint)
        {
            TopOfFile("Symbol"); // This is to reset the top of file counter only
            // FindingMyBugs(80) 'hace Least amount of checking here
            if (InvalidIndex(Idex, Symbol_FileSymbolName))
            {
                Abug(192, "UpdatesymbolRecordAt has an index issue", Idex, " So can Not update Name=" + SymbolName + " code= " + Coded);
                return;
            }
            Symbol_FileCoded[Idex] = MyKeyword_2_Byte(Coded); // I think that I forgot this one.
            Symbol_FileSymbolName[Idex] = SymbolName;
            Symbol_TableX1(Idex, X1);
            Symbol_TableY1(Idex, Y1);
            Symbol_Table_InputOutput(Idex, X2_io); // these have to check for x2 or a io-name
            Symbol_Table_DataType(Idex, Y2_dt); // these have to check for y2 or a datatype-name
            Symbol_Table_NameOfPoint(Idex, NameOfPoint);
            // FindingMyBugs(10) 'hack Least amount of checking here ' 2020 07 22
            ReSortSymbolList();
        }


        long AddNewNamedRecord(string SymbolName, string Mytext, string opcode, string notes, string filename, string language, string author, string version, string stroke, string sintax)
        {
            // 2020/6/22 change to return the record numberinstead of passing it.
            // Bugs:
            // Does not check if this name is already there. 

            MyMakeArraySizesBigger();
            AddNewNamedRecord = FindIndexIniSAMTable("named", "Donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            if (AddNewNamedRecord > 0)
                return;
            AddNewNamedRecord = NewTopOfFile("named");
            Named_FileSymbolName_iSAM[AddNewNamedRecord] = AddNewNamedRecord;
            Named_FileSintax_Isam[AddNewNamedRecord] = AddNewNamedRecord;
            Named_FileSymbolName[AddNewNamedRecord] = SymbolName;

            Named_TableSymbolName(AddNewNamedRecord, SymbolName); // Name of the symbol
            Named_TableSymbolIndexes(AddNewNamedRecord, GetSelfCorrectingIndexes(SymbolName)); // A Indexes to this symbol in the Symbol Graphics Table
            // todo need to always make the text into macro code text (replace the variable name with " & MyUniverse.SysGen.Constants.RMStart & "variablename.Path" & MyUniverse.SysGen.Constants.RMEnd & "
            Named_TableMicroCodeText(AddNewNamedRecord, Mytext); // The actural program code to be 'fixed'
            Named_TableOpCode(AddNewNamedRecord, opcode); // The Machine code of this assemble symbol
            Named_TableNotes(AddNewNamedRecord, notes); // Notes for this symbol

            Named_FileNameOfFile[AddNewNamedRecord] = filename; // *******'*' This is to avoid index checking not having anything
            Named_TableNameOfFile(AddNewNamedRecord, filename);  // The device:/path/Filename where this came from 

            // Named_TableLanguage(AddNewNamedRecord, language) 'The computer language this applies to
            Named_TableAuthor(AddNewNamedRecord, author); // Who wrote or responsable for this symbol
            Named_TableVersion(AddNewNamedRecord, version); // the date of the latest update
            Named_TableStroke(AddNewNamedRecord, stroke); // The movement of the mouse that id's this symbol
            Named_TableSintax(AddNewNamedRecord, sintax); // The Syntax for this
            Named_FileSintax_Isam[AddNewNamedRecord] = AddNewNamedRecord;

            ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, AddNewNamedRecord));
            ShowSorts("named", MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, AddNewNamedRecord));
            GetSelfCorrectingIndexes(SymbolName);
            ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, AddNewNamedRecord));
            TopOfFile("named"); // This is to update the top of file, and make the array bigger
        }

        long AddANewFlowChartRecord()
        {
            // 2020/6/22 change to return the record numberinstead of passing it.

            MyMakeArraySizesBigger();
            AddANewFlowChartRecord = NewTopOfFile("FlowChart");
            if (FlowChart_iSAM_Name[AddANewFlowChartRecord] != 0)
            {
                if (FlowChart_iSAM_Name[AddANewFlowChartRecord] != AddANewFlowChartRecord())
                    // MyMsgCtr(1018, "AddFlowChartRecord", MyShowFlowChartRecord(AddANewFlowChartRecord), "", "", "", "", "", "", "", "")
                    AddANewFlowChartRecord = AddANewFlowChartRecord;
            }

            MyMakeArraySizesBigger();
            if (QuickCheckSort(ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, AddANewFlowChartRecord) < 0)
            {
                FindingMyBugs(10); // hack Least amount of checking here
                return;
            }
            FlowChart_iSAM_Name[AddANewFlowChartRecord] = AddANewFlowChartRecord;

            if (QuickCheckSort(ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, AddANewFlowChartRecord) < 0)
            {
                FindingMyBugs(10); // hack Least amount of checking here
                return;
            }
            FlowChart_iSAM_Name[AddANewFlowChartRecord] = AddANewFlowChartRecord;
            FlowChart_iSAM_X1[AddANewFlowChartRecord] = AddANewFlowChartRecord;
            FlowChart_iSAM_Y1[AddANewFlowChartRecord] = AddANewFlowChartRecord;
            FlowChart_iSAM_X2[AddANewFlowChartRecord] = AddANewFlowChartRecord;
            FlowChart_iSAM_Y2[AddANewFlowChartRecord] = AddANewFlowChartRecord;
        }

        long AddFlowChartRecordPath(string named, string coded, long x1, long y1, long x2, long y2, string MyDataType, string Links, long LineNumber)
        {
            MyMakeArraySizesBigger();
            if (coded != "/path")
                Abug(193, "Adding a " + coded + " and not a path", named, MyDataType);
            AddFlowChartRecordPath = NewTopOfFile("FlowChart");
            FlowChart_iSAM_Name[AddFlowChartRecordPath] = AddFlowChartRecordPath;
            FlowChart_iSAM_X1[AddFlowChartRecordPath] = AddFlowChartRecordPath;
            FlowChart_iSAM_Y1[AddFlowChartRecordPath] = AddFlowChartRecordPath;
            FlowChart_iSAM_X2[AddFlowChartRecordPath] = AddFlowChartRecordPath;
            FlowChart_iSAM_Y2[AddFlowChartRecordPath] = AddFlowChartRecordPath;
            FlowChart_TablePathSymbolName(AddFlowChartRecordPath, NameOfPointOnly(named));
            FlowChart_TableCode(AddFlowChartRecordPath, MyKeyword_2_Byte(coded).ToString());
            FlowChart_TableX1(AddFlowChartRecordPath, x1);
            FlowChart_TableY1(AddFlowChartRecordPath, y1);
            FlowChart_TableX2(AddFlowChartRecordPath, x2);
            FlowChart_TableY2(AddFlowChartRecordPath, y2);

            FlowChart_Table_DataType(AddFlowChartRecordPath, MyDataType); // The datatype for /Path /constant
            if (FindIndex_In_TableNetLinks(AddFlowChartRecordPath) < 1)
                makeNew_NetLinks(AddFlowChartRecordPath, named);
            AInfo(616, "Added New Flow Chart Record", MyShowFlowChartRecord(AddFlowChartRecordPath), MyShowNetLnks(FindIndex_In_TableNetLinks(AddFlowChartRecordPath)));
            ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordPath));
            FindingMyBugs(40); // hack Least amount of checking here
            TopOfFile("FlowChart"); // This is to update the top of file, and make the array bigger
            // AInfo(617, " updated links FLow Chart record()", MyShowFlowChartRecord(AddFlowChartRecordPath), MyShowNetLnks(FindIndex_In_TableNetLinks(AddFlowChartRecordPath)))
            // FindingMyBUgXY(AddFlowChartRecordPath)
            return AddFlowChartRecordPath;
        }

        long AddFlowChartRecordUse(string named, string coded, long x1, long y1, string Rotation, string MyOptions, string MyDataType, string Links, long LineNumber)
        {
            MyMakeArraySizesBigger();
            if (coded != "/use")
                Abug(194, "Adding a " + coded + " and not a use", named, MyDataType);
            AddFlowChartRecordUse = NewTopOfFile("FlowChart");
            FlowChart_iSAM_Name[AddFlowChartRecordUse] = AddFlowChartRecordUse;
            FlowChart_iSAM_X1[AddFlowChartRecordUse] = AddFlowChartRecordUse;
            FlowChart_iSAM_Y1[AddFlowChartRecordUse] = AddFlowChartRecordUse;
            FlowChart_iSAM_X2[AddFlowChartRecordUse] = AddFlowChartRecordUse;
            FlowChart_iSAM_Y2[AddFlowChartRecordUse] = AddFlowChartRecordUse;
            FlowChart_TableCode(AddFlowChartRecordUse, MyKeyword_2_Byte(coded).ToString());

            // FlowChart_FilePathSymbolName(AddFlowChartRecordUse) = named
            FlowChart_TablePathSymbolName(AddFlowChartRecordUse, named);


            FlowChart_TableX1(AddFlowChartRecordUse, x1);
            FlowChart_TableY1(AddFlowChartRecordUse, y1);
            FlowChart_Table_Rotation(AddFlowChartRecordUse, Rotation);
            // FlowChart_Table_DataType(AddFlowChartRecordUse, datatype)
            FlowChart_Table_DataType(AddFlowChartRecordUse, MyDataType); // The datatype for /Path /constant
            ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordUse));
            TopOfFile("FlowChart"); // This is to update the top of file, and make the array bigger
            return AddFlowChartRecordUse;
        }



        long AddFlowChartRecordOther(string named, string coded, long x1, long y1, long x2, long y2, string MyDataType, string Links, long LineNumber)
        {
            MyMakeArraySizesBigger();
            AddFlowChartRecordOther = NewTopOfFile("FlowChart");
            FlowChart_iSAM_Name[AddFlowChartRecordOther] = AddFlowChartRecordOther;
            FlowChart_iSAM_X1[AddFlowChartRecordOther] = AddFlowChartRecordOther;
            FlowChart_iSAM_Y1[AddFlowChartRecordOther] = AddFlowChartRecordOther;
            FlowChart_iSAM_X2[AddFlowChartRecordOther] = AddFlowChartRecordOther;
            FlowChart_iSAM_Y2[AddFlowChartRecordOther] = AddFlowChartRecordOther;

            FlowChart_TableCode(AddFlowChartRecordOther, MyKeyword_2_Byte(coded).ToString());
            // FlowChart_FilePathSymbolName(AddFlowChartRecordOther) = named
            FlowChart_TablePathSymbolName(AddFlowChartRecordOther, named);

            FlowChart_TableX1(AddFlowChartRecordOther, x1);
            FlowChart_TableY1(AddFlowChartRecordOther, y1);
            FlowChart_TableX2(AddFlowChartRecordOther, x2);
            FlowChart_TableY2(AddFlowChartRecordOther, y2);
            FlowChart_Table_DataType(AddFlowChartRecordOther, MyDataType); // The datatype for /Path /constant
            // AInfo(619, "Added New Flow Chart Record", MyShowFlowChartRecord(AddFlowChartRecordOther), "")
            ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordOther));
            // FindingMyBugs(70) 'hack Least amount of checking here
            TopOfFile("FlowChart"); // This is to update the top of file, and make the array bigger
            if (FindIndex_In_TableNetLinks(AddFlowChartRecordOther) < 1)
                MakeNew_NetLinks(AddFlowChartRecordOther, FlowChart_TablePath_Name(AddFlowChartRecordOther));
            return AddFlowChartRecordOther;
        }



        long ReSortFlowChart(long Index)
        {
            // 03/12/19 changed to only resort the top added item
            ReSortFlowChart = MyReSort("FlowChart", ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, Index);
            ReSortFlowChart += MyReSort("FlowChart", ref FlowChart_FileX1, ref FlowChart_iSAM_X1, Index);
            ReSortFlowChart += MyReSort("FlowChart", ref FlowChart_FileY1, ref FlowChart_iSAM_Y1, Index);
            ReSortFlowChart += MyReSort("FlowChart", ref FlowChart_File_X2_Rotation, ref FlowChart_iSAM_X2, Index);
            ReSortFlowChart += MyReSort("FlowChart", ref FlowChart_File_Y2_Option, ref FlowChart_iSAM_Y2, Index);

            CheckThisStringArray(12, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, Index); // hack
        }


        long MyReSortAll_long(string MyTable, long MyArrayLong[], long iSAM[])
        {
            long iDex;
            MyReSortAll_long = 0;
            for (iDex = 1; iDex <= TopOfFile(MyTable); iDex++)
                MyReSortAll_long += (MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, iDex));
            FindingMyBugs(10); // hack Least amount of checking here
        }

        long MyReSort_long(string MyTable, long MyArrayLong[], long iSAM[], long Index)
        {
            MyReSort_long = 0;
            if (InvalidIndex(Index, MyArrayLong, ref iSAM))
                return;
            if (iSAM[Index] != 0)
            {
                if (iSAM[Index - 1] > 0)
                {
                    if (MyArrayLong[iSAM[Index - 1]] > MyArrayLong[iSAM[Index]])
                    {
                        MySwapNn(MyTable, MyArrayLong, ref iSAM, Index - 1, Index);
                        MyReSort_long += 1;
                        MyReSort_long += (MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, Index - 1));
                        MyReSort_long += (MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, Index + 1));
                        MyReSort_long += (MyReSort_long(MyTable, ref MyArrayLong, ref iSAM, Index));
                    }
                }
            }
            FindingMyBugs(10); // hack Least amount of checking here
        }

        // *******************************************************************
        // This is used to resort the array at the indexinput (Recursive if change is needed)
        // This needs to be changed to an insert sort (Faster)
        long MyReSort(string MyTable, string MyArray[], long iSAM[], long IndexInput)
        {
            long TopMost;
            long Idex, Jdex;
            long IdexTemp;
            long ErrorCount;
            string DebugWatch1, DebugWatch2;
            MyReSort = 0;

            TopMost = TopOfFile(MyTable);
            Idex = IndexInput;

            if (IndexInput > Information.UBound(MyArray))
                return; // 2020 09 25
            if (IndexInput > TopMost)
                return; // 2020 09 25

            ErrorCount = 1024;


            while (ErrorCount > 0)
            {
                ErrorCount -= 1;
                // ainfo2(15)
                Idex = MyMinMax(Idex, 1, Information.UBound(MyArray) - 1); // 2020 09 25
                DebugWatch1 = MyArray[iSAM[Idex - 1]];
                DebugWatch2 = MyArray[iSAM[Idex + 1]];
                switch (MyCompared3(MyArray[iSAM[Idex - 1]], MyArray[iSAM[Idex]], MyArray[iSAM[Idex + 1]]))
                {
                case 5:
                {
                    if (PrintAbleNull(MyArray[iSAM[Idex - 1]]) == "_")
                        return 5;
                    if (PrintAbleNull(MyArray[iSAM[Idex]]) == "_")
                        return 5;
                    if (PrintAbleNull(MyArray[iSAM[Idex + 1]]) == "_")
                        return 5;
                    // 15            5 if none of the below (Error in logic)"
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    FindingMyBugs(100); // hack Least amount of checking here
                    break;
                    break;
                }

                case 4:
                {
                    // 6            4 if  C = Null And C > A
                    // 8            4 if C = ''
                    if (Idex == MyMinMax(Idex, 1, TopMost))
                    {
                        IdexTemp = Idex;
                        // C is null but is A > B then we...
                        while (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1)
                        {
                            MySwapN(MyTable, ref MyArray, ref iSAM, Idex - 1, Idex);
                            MyReSort += 1;
                            Idex = MyMinMax(Idex - 1, 1, TopMost);
                        }
                        if (MyReSort > 0)
                        {
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                            Idex = IdexTemp;
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        }
                    }
                    return;
                }

                case 3 // So that we swap every thing up and down from here
                    :
                {
                    // 13            3 if B < C
                    Idex = IdexTemp;
                    while (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) < 0)
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex, Idex + 1);
                        MyReSort += 1;
                        Idex = MyMinMax(Idex + 1, 1, TopMost);
                    }
                    if (MyReSort > 0)
                    {
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        Idex = IdexTemp;
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    }
                    FindingMyBugs(100);// hack Least amount of checking here
                    break;
                }

                case 2:
                {
                    // 14            2 if A > B
                    if (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) >= 0)
                    {
                        // If MyArray(iSAM(Idex - 1)) > MyArray(iSAM(Idex)) Then 'hack
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex - 1, Idex);
                        MyReSort += 1;
                        FindingMyBugs(100); // hack Least amount of checking here
                    }
                    else
                    {
                        Idex = MyMinMax(Idex, 1, TopMost); // hack
                        FindingMyBugs(10); // hack Least amount of checking here
                    } // hack
                    if (MyReSort > 0)
                    {
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        Idex = IdexTemp;
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    }

                    break;
                }

                case 1 // Duplication' check to make sure it is not out of order at the beggining of the dup's
                    :
                {
                    if (Idex <= 1)
                        return;
                    if (MyArray[iSAM[Idex - 1]] == MyArray[iSAM[Idex]] & MyArray[iSAM[Idex]] == MyArray[iSAM[Idex + 1]])
                        return;
                    Idex -= 1;
                    break;
                }

                case 0 // This should never happen but when it does, we should do nothing
                    :
                {
                    // 1            0 if the middle Is null
                    // 2            0 if first = third are null
                    // 10            0 if A < B & B < C
                    Idex = IndexInput;
                    while (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1)
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex - 1, Idex);
                        Idex = MyMinMax(Idex - 1, 1, TopMost);
                    }
                    while (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 1) // MyCompared(MyArray(iSAM(Idex)), MyArray(iSAM(Idex + 1))) = 1
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex, Idex + 1);
                        Idex = MyMinMax(Idex + 1, 1, TopMost);
                    }
                    if (MyReSort > 0)
                    {
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        Idex = IdexTemp;
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    }
                    return; // Should not swap anything up or down
                }

                case -1 // Duplication
                    :
                {
                    // 3            -1 if A = B
                    Jdex = Idex;
                    while (MyCompared2(ref MyArray, ref iSAM, Jdex, Jdex + 1) > 0)
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Jdex, Jdex + 1);
                        Jdex += 1;
                    }
                    Jdex = Idex;


                    // Find the beggining and cause a sort from there
                    // While MyCompared2(MyArray(iSAM(Idex)), MyArray(iSAM(Idex - 1)) = 0' Same
                    while (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 0)
                        Idex -= 1;
                    while (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 0)
                        // While MyCompared2(MyArray(iSAM(Jdex)), MyArray(iSAM(Jdex + 1)) = 0
                        Jdex += 1;


                    // If MyCompared2(MyArray(iSAM(Idex)), MyArray(iSAM(Idex - 1)) <= 0 Then' 
                    if (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) >= 0)
                    {
                        MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    }

                    if (MyCompared2(ref MyArray, ref iSAM, Jdex, Jdex + 1) > 0)
                    {
                        // If MyCompared2(MyArray(iSAM(Jdex)), MyArray(iSAM(Idex + 1)) > 0 Then
                        MyReSort(MyTable, ref MyArray, ref iSAM, Jdex);
                        MyReSort(MyTable, ref MyArray, ref iSAM, Jdex + 1);
                        MyReSort(MyTable, ref MyArray, ref iSAM, Jdex);
                        MyReSort(MyTable, ref MyArray, ref iSAM, Jdex + 1);
                    }
                    return;
                }

                case -2:
                {
                    // 12            -2 if B > C
                    while (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 1) // MyCompared(MyArray(iSAM(Idex)), MyArray(iSAM(Idex + 1))) = 1 'hack
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex, Idex + 1);
                        MyReSort += 1;
                        Idex = MyMinMax(Idex + 1, 1, TopMost);
                    }

                    break;
                }

                case -3:
                {
                    // 11            -3 if A > B
                    if (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1)
                    {
                        IdexTemp = Idex;
                        while (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1) // MyCompared(MyArray(iSAM(Idex - 1)), MyArray(iSAM(Idex))) = 1
                        {
                            MySwapN(MyTable, ref MyArray, ref iSAM, Idex - 1, Idex);
                            MyReSort += 1;
                            Idex = MyMinMax(Idex - 1, 1, TopMost);
                        }
                        if (MyReSort > 0)
                        {
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                            Idex = IdexTemp;
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        }
                    }
                    if (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 1)
                    {
                        IdexTemp = Idex;
                        while (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 1) // MyCompared(MyArray(iSAM(Idex)), MyArray(iSAM(Idex + 1))) = 1
                        {
                            MySwapN(MyTable, ref MyArray, ref iSAM, Idex, Idex + 1);
                            MyReSort += 1;
                            Idex = MyMinMax(Idex + 1, 1, TopMost);
                        }
                        if (MyReSort > 0)
                        {
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                            Idex = IdexTemp;
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        }
                    }
                    // MyReSort += MyReSort(MyTable, MyArray, iSAM, Idex)
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    Idex = IdexTemp;
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    break;
                }

                case -4:
                {
                    // 5            -4 if A = Null & B < C
                    // 7            -4 if A = ''
                    IdexTemp = Idex;
                    if (Idex > 1)
                    {
                        while (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 1) // MyCompared(MyArray(iSAM(Idex)), MyArray(iSAM(Idex + 1))) = 1
                        {
                            MySwapN(MyTable, ref MyArray, ref iSAM, Idex, Idex + 1);
                            MyReSort += 1;
                            Idex = MyMinMax(Idex + 1, 1, TopMost);
                        }
                        if (MyReSort > 0)
                        {
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                            Idex = IdexTemp;
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                            MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        }
                    }
                    return;
                }

                case -5:
                {
                    // 9            -5 if A > C (error in list)
                    MySwapN(MyTable, ref MyArray, ref iSAM, Idex - 1, Idex + 1); // swap A & C which is being wrong

                    while (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 1) // MyCompared(MyArray(iSAM(Idex)), MyArray(iSAM(Idex + 1))) = 1
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex, Idex + 1);
                        MyReSort += 1;
                        Idex = MyMinMax(Idex + 1, 1, TopMost);
                    }
                    while (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1) // MyCompared(MyArray(iSAM(Idex - 1)), MyArray(iSAM(Idex))) = 1
                    {
                        MySwapN(MyTable, ref MyArray, ref iSAM, Idex - 1, Idex);
                        MyReSort += 1;
                        Idex = MyMinMax(Idex - 1, 1, TopMost);
                    }
                    if (MyReSort > 0)
                    {
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                        Idex = IdexTemp;
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                    }
                    // maybe below we should just exit?
                    if (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1)
                    {
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        return;
                    }
                    if (MyCompared2(ref MyArray, ref iSAM, Idex, Idex + 1) == 0)
                    {
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                        MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                        return;
                    }

                    break;
                }

                default:
                {
                    if (MyReSort != 0)
                        DisplayMyStatus(MyTable + " = " + MyReSort);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                    Idex = IdexTemp;
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    MyReSort += MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                    return;
                }
                }
            }
        }


        // Only sort the last inserted NOT the whole MyArray
        long MyReSort(string MyTable, long MyArrayLong[], long iSAM[], long IndexInput)
        {
            long TopMost, Idex;
            bool Flag;
            MyReSort = 0;
            TopMost = TopOfFile(MyTable);
            if (IndexInput != MyMinMax(IndexInput, 1, Information.UBound(iSAM)))
                return;

            if (InvalidIndex(IndexInput, MyArrayLong, ref iSAM))
                return;

            if (InvalidIndex(IndexInput - 1, MyArrayLong, ref iSAM))
            {
            }
            else
            {
                Idex = IndexInput;
                Flag = false;
                while ((Idex > 0 & InvalidIndex(Idex, MyArrayLong, ref iSAM) == false & InvalidIndex(Idex - 1, MyArrayLong, ref iSAM) == false & MyArrayLong[iSAM[Idex]] < MyArrayLong[iSAM[Idex - 1]]))
                {
                    MySwapNn(MyTable, MyArrayLong, ref iSAM, Idex - 1, Idex);
                    Flag = true;
                    MyReSort += 1;
                    Idex -= 1;
                }
                if (Flag == true)
                {
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, Idex - 1);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, IndexInput - 1);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, IndexInput);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, IndexInput + 1);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, Idex + 1);
                }
            }

            if (InvalidIndex(Idex + 1, MyArrayLong, ref iSAM))
            {
            }
            else
            {
                Idex = IndexInput;
                Flag = false;
                while (Idex > 0 & InvalidIndex(Idex, MyArrayLong, ref iSAM) == false & InvalidIndex(Idex + 1, MyArrayLong, ref iSAM) == false & MyArrayLong[iSAM[Idex + 1]] < MyArrayLong[iSAM[Idex]])
                {
                    MySwapNn(MyTable, MyArrayLong, ref iSAM, Idex, Idex + 1);
                    Flag = true;
                    MyReSort += 1;
                    Idex -= 1;
                    FindingMyBugs(100); // hack Least amount of checking here
                }
                if (Flag == true)
                {
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, Idex - 1);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, IndexInput - 1);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, IndexInput);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, IndexInput + 1);
                    MyReSort += MyReSort(MyTable, ref MyArrayLong, ref iSAM, Idex + 1);
                }
            }
        }

        long SortiSAMs()
        {
            SortiSAMs = 0;
            SortiSAMs += (SortColors());
            SortiSAMs += (SortDataType());
            SortiSAMs += (SortNamed());
            SortiSAMs += (SortFlowChart());
            FindingMyBugs(10); // hack Least amount of checking here
        }

        long SortColors()            // First Sort Color iSAMe (again?)
        {
            SortColors = (MySortStringArray("Color", ref Color_FileName, ref Color_Name_iSAM));
            MyUniverse.MyCheatSheet.ColorsSorted = 0;
        }
        // ***********************************************************************
        // This sorts the datatype array
        long SortDataType()
        {
            SortDataType = (MySortStringArray("DataType", ref DataType_FileName, ref DataType_Name_iSAM));
            MyUniverse.MyCheatSheet.DataTypeSorted = 0;
        }
        // ***********************************************************************
        // sorts the symbol array by the name of the symbol
        long SortNamed()
        {
            SortNamed = MySortStringArray("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM);
            SortNamed += MySortStringArray("named", ref Named_FileSintax, ref Named_FileSintax_Isam); // added 2020 08 12
            MyUniverse.MyCheatSheet.NamedSorted = 0;
        }

        long SortFlowChart()
        {
            SortFlowChart = 0;
            if (TopOfFile("FlowChart") == 1)
                return;
            SortFlowChart += (MySortStringArray("FlowChart", ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name));
            SortFlowChart += (MySortNumberArray("FlowChart", ref FlowChart_FileX1, ref FlowChart_iSAM_X1));
            SortFlowChart += (MySortNumberArray("FlowChart", ref FlowChart_FileY1, ref FlowChart_iSAM_Y1));
            SortFlowChart += (MySortNumberArray("FlowChart", ref FlowChart_File_X2_Rotation, ref FlowChart_iSAM_X2));
            SortFlowChart += (MySortNumberArray("FlowChart", ref FlowChart_File_Y2_Option, ref FlowChart_iSAM_Y2));
            MyUniverse.MyCheatSheet.FlowChartSorted = 0;
        }

        void SortALLiSAM()
        {
            long Index;
            for (Index = 1; Index <= TopOfFile("Color"); Index++)
                Color_Name_iSAM[Index] = Index;
            for (Index = TopOfFile("Color") + 1; Index <= Information.UBound(Color_FileName); Index++)
                Color_Name_iSAM[Index] = 0;

            ShowSorts("Colors", SortColors());

            // MyStatus("Setting Sort . . . DataTypes")
            for (Index = 1; Index <= TopOfFile("DataType"); Index++)
                DataType_Name_iSAM[Index] = Index;
            // For Index = TopOfFile("DataType") + 1 To UBound(DataType_FileName)
            // DataType_Name_iSAM(Index) = 0
            // Next Index

            ShowSorts("DataType", SortDataType());

            // MyStatus("Setting Sort . . . Symbol Names")
            for (Index = 1; Index <= TopOfFile("named"); Index++)
            {
                Named_FileSymbolName_iSAM[Index] = Index;
                Named_FileSintax_Isam[Index] = Index;
            }
            // set unused records to zero
            for (Index = TopOfFile("named") + 1; Index <= Information.UBound(Named_FileSymbolName); Index++)
            {
                Named_FileSymbolName_iSAM[Index] = 0;
                Named_FileSintax_Isam[Index] = 0;
            }

            ShowSorts("Named", SortNamed());

            // MyStatus("Setting Sort . . . FlowChart")
            for (Index = 1; Index <= TopOfFile("FlowChart"); Index++)
            {
                switch (Strings.LCase(Strings.Trim(FlowChart_TableCode(Index))))
                {
                case "/use":
                case "/constant":
                case "/error":
                {
                    FlowChart_iSAM_Name[Index] = Index;
                    FlowChart_iSAM_X1[Index] = Index;
                    FlowChart_iSAM_Y1[Index] = Index;
                    FlowChart_iSAM_X2[Index] = Index; // Rotation
                    FlowChart_iSAM_Y2[Index] = Index;
                    break;
                }

                case "/path":
                case "":
                {
                    FlowChart_iSAM_Name[Index] = Index;
                    FlowChart_iSAM_X1[Index] = Index;
                    FlowChart_iSAM_Y1[Index] = Index;
                    FlowChart_iSAM_X2[Index] = Index;
                    FlowChart_iSAM_Y2[Index] = Index;
                    break;
                }

                default:
                {
                    MyMsgCtr(1375, "SortAlliSAM", "Unknow Code ", ">" + Strings.LCase(Strings.Trim(FlowChart_TableCode(Index))) + "<", "Macro Code Text == >" + MyKeyword_2_Byte(FlowChart_TableCode(Index)) + "<", "(" + FlowChart_TableX1(Index) + FD + FlowChart_TableY1(Index) + ")", "(" + FlowChart_TableX2(Index) + FD + FlowChart_TableY2(Index) + ")", "Links = " + FindIndex_In_TableNetLinks(Index), "Named = " + FlowChart_TableSymbol_Name(Index) + FlowChart_TablePathName(Index), "Datatype = " + FlowChart_Table_DataType(Index), "Index = " + Index);
                    FlowChart_iSAM_Name[Index] = Index;
                    FlowChart_iSAM_X1[Index] = 0;
                    FlowChart_iSAM_Y1[Index] = 0;
                    FlowChart_iSAM_X2[Index] = 0;
                    FlowChart_iSAM_Y2[Index] = 0;
                    break;
                }
                }
            }


            // Hack Why do I set it above and then here set everything to no index??
            for (Index = TopOfFile("FlowChart") + 1; Index <= Information.UBound(FlowChart_FileCoded); Index++)
            {
                FlowChart_iSAM_Name[Index] = 0;
                FlowChart_iSAM_X1[Index] = 0;
                FlowChart_iSAM_Y1[Index] = 0;
                FlowChart_iSAM_X2[Index] = 0;
                FlowChart_iSAM_Y2[Index] = 0;
            }
            ShowSorts("FlowChart", SortFlowChart());
        }


        long MySortNumberArray(string MyTable, long MyArrayLong[], long iSAM[])
        {
            MySortNumberArray = (MyQuickNumbersort(MyTable, MyArrayLong, ref iSAM, 0, 0));
        }
        // ****************************************************************************
        // This is to find the location of where to inset this record in an already sorted List at index
        long InsertReSortLanguagekeyWord(string MyTable, string MyArray[], long Index)
        {
            long Cdex; // Where to insert at
            string SavedItem;
            long I; // loop through and move all of the list one items
            // Finst find where it goes in the sorted list

            if (Information.UBound(MyArray) < Index)
            {
                var oldMyArray = MyArray;
                MyArray = new string[Index + 1];
                if (oldMyArray != null)
                    Array.Copy(oldMyArray, MyArray, Math.Min(Index + 1, oldMyArray.Length));
            }

            InsertReSortLanguagekeyWord = 0; // number of swaps made
            if (Index != MyMinMax(Index, Information.LBound(MyArray), Information.UBound(MyArray)))
                return; // If invalid index then do nothing

            SavedItem = MyArray[Index]; // save the item to be moved

            Cdex = MyMinMax(Index + 1, Information.LBound(MyArray), Information.UBound(MyArray)); // The Next one
            while (MyCompared1_a(MyArray[Index], MyArray[Cdex]) == 1 & Index != Cdex)
                Cdex = MyMinMax(Index + 1, Information.LBound(MyArray), Information.UBound(MyArray));

            while (MyCompared1_a(MyArray[Index], MyArray[Cdex]) == -1 & Index != Cdex)
                Cdex = MyMinMax(Index - 1, Information.LBound(MyArray), Information.UBound(MyArray));



            // Cdex should now be where Index (This insert record goes)
            if (Index < Cdex)
            {
                for (I = Information.UBound(MyArray); I >= Cdex; I += -1)
                    MyArray[I] = MyArray[I - 1];
            }
            else
                for (I = Information.UBound(MyArray); I >= Cdex; I += -1)
                    MyArray[I] = MyArray[I - 1];
            MyArray[Index] = SavedItem;
        }
        // ****************************************************************************
        // Make sure that the language keyWord (and operator key words) are sorted for ordered (binary) search
        long ReSortLanguagekeyWord(string MyTable, string MyArray[], long Index)
        {
            long Adex;
            long Idex;
            long Cdex;
            bool Flag;
            long ResortCount;
            ResortCount = 0;
            ReSortLanguagekeyWord = 0;
            Flag = false;

            // This is here to just test if an insert sort works faster
            // This seems to break sorting ReSortLanguagekeyWord = InsertReSortLanguagekeyWord(MyTable, MyArray, Index)


            if (Index != MyMinMax(Index, Information.LBound(MyArray), Information.UBound(MyArray)))
                return;
            Idex = MyMinMax(Index, Information.LBound(MyArray), Information.UBound(MyArray));
            Cdex = MyMinMax(Idex + 1, Information.LBound(MyArray), Information.UBound(MyArray));
            while (MyCompared1_a(MyArray[Idex], MyArray[Cdex]) == 1 & Idex != Cdex)
            {
                MySwapLanguagekeyWord(MyTable, ref MyArray, Idex, Cdex);
                ResortCount += 1;
                Flag = true;
                ReSortLanguagekeyWord += 1;
                Idex = MyMinMax(Idex + 1, Information.LBound(MyArray), Information.UBound(MyArray) - 1);
                Cdex = MyMinMax(Index + 1, Information.LBound(MyArray), Information.UBound(MyArray));
            }

            // try the other way
            Idex = MyMinMax(Index, Information.LBound(MyArray), Information.UBound(MyArray));
            Adex = MyMinMax(Idex - 1, Information.LBound(MyArray), Information.UBound(MyArray));
            while (MyCompared1_a(MyArray[Adex], MyArray[Idex]) == 1 & Adex != Idex)
            {
                MySwapLanguagekeyWord(MyTable, ref MyArray, Adex, Idex);
                Flag = true;
                Idex = MyMinMax(Idex - 1, Information.LBound(MyArray) + 1, Information.UBound(MyArray));
                Adex = MyMinMax(Idex - 1, Information.LBound(MyArray), Information.UBound(MyArray));
            }


            // Just to see if it does it here (to save recursion)
            Idex = MyMinMax(Index, Information.LBound(MyArray), Information.UBound(MyArray));
            Cdex = MyMinMax(Idex + 1, Information.LBound(MyArray), Information.UBound(MyArray));
            while (MyCompared1_a(MyArray[Idex], MyArray[Cdex]) == 1 & Idex != Cdex)
            {
                Abug(195, "ReSortLanguagekeyWord", MyArray[Idex], MyArray[Cdex]); // we should never beable to do it twice
                MySwapLanguagekeyWord(MyTable, ref MyArray, Idex, Cdex);
                Flag = true;
                Idex = MyMinMax(Idex + 1, Information.LBound(MyArray), Information.UBound(MyArray) - 1);
                Cdex = MyMinMax(Idex + 1, Information.LBound(MyArray), Information.UBound(MyArray));
            }

            // try the other way
            Idex = MyMinMax(Index, Information.LBound(MyArray), Information.UBound(MyArray));
            Adex = MyMinMax(Idex - 1, Information.LBound(MyArray), Information.UBound(MyArray));
            while (MyCompared1_a(MyArray[Adex], MyArray[Idex]) == 1 & Adex != Idex)
            {
                Abug(196, "ResortLanguagekeyWord():", MyArray[Adex], MyArray[Idex]); // we should never beable to do it twice
                MySwapLanguagekeyWord(MyTable, ref MyArray, Idex - 1, Idex);
                Flag = true;
                Idex = MyMinMax(Idex - 1, Information.LBound(MyArray) + 1, Information.UBound(MyArray));
                Adex = MyMinMax(Idex - 1, Information.LBound(MyArray), Information.UBound(MyArray));
            }

            if (Flag == true)
            {
                ResortCount = 0; // This is to see if all (OR ANY) of this checksorting is needed!
                ResortCount += ReSortLanguagekeyWord(MyTable, ref MyArray, Idex - 1);
                ResortCount += +ReSortLanguagekeyWord(MyTable, ref MyArray, Idex + 1); // hack
                ResortCount += +ReSortLanguagekeyWord(MyTable, ref MyArray, Idex);
                // ?Idex = Index 'hack
                ResortCount += +ReSortLanguagekeyWord(MyTable, ref MyArray, Index - 1); // hack
                ResortCount += +ReSortLanguagekeyWord(MyTable, ref MyArray, Index + 1); // hack
                ResortCount += ReSortLanguagekeyWord(MyTable, ref MyArray, Index);
                ReSortLanguagekeyWord += ResortCount;
            }
        }


        long ReSortStringArray(string MyTable, string MyArray[], long iSAM[])
        {
            long TopMost;
            long Index;
            ReSortStringArray = 0;
            // First Try to sort just the top
            TopMost = TopOfFile(MyTable);
            for (Index = 2; Index <= TopMost; Index++)
                ReSortStringArray += MyReSort(MyTable, ref MyArray, ref iSAM, Index);
            ReSortStringArray += MyReSort(MyTable, ref MyArray, ref iSAM, TopMost);
            if (MyIsValidCheckSortAll_String(MyTable, ref MyArray, ref iSAM) == false)
            {
                ReSortStringArray += ReBubbleSortAll(MyTable, ref MyArray, ref iSAM);
                MyIsValidCheckSortAll_String(MyTable, ref MyArray, ref iSAM); // hack so I can see why it's here
            }
        }

        // ***********************************************************************
        // bubble sort the array 
        // Which means sorting the index to the array and never changing the array, so that Indexess/indexs stay the same
        long MySortStringArray(string MyTable, string MyArray[], long iSAM[]) // returns the number sorted
        {
            long Idex;
            long NumberSorted;

            // FindingMyBugs(50) 'hack Least amount of checking here ' Check after sorting
            MySortStringArray = 0;
            // FindingMyBugs(100) 'hack Least amount of checking here no reason to check and get an out of order before sorting
            for (Idex = TopOfFile(MyTable); Idex >= 1; Idex += -1)
            {
                NumberSorted = MyReSort(MyTable, ref MyArray, ref iSAM, Idex); // 20200703'+20200708
                // ainfo2(16)
                MySortStringArray += NumberSorted;
                if (NumberSorted > 0)
                {
                    NumberSorted = MyReSort(MyTable, ref MyArray, ref iSAM, Idex - 1);
                    MySortStringArray += NumberSorted;
                    NumberSorted = MyReSort(MyTable, ref MyArray, ref iSAM, Idex);
                    MySortStringArray += NumberSorted;
                    NumberSorted = MyReSort(MyTable, ref MyArray, ref iSAM, Idex + 1);
                    MySortStringArray += NumberSorted;
                }
            }

            if (MyIsValidCheckSortAll_String(MyTable, ref MyArray, ref iSAM) == false)
                MySortStringArray += (ReBubbleSortAll(MyTable, ref MyArray, ref iSAM));
        }

        void MyInsertSymbolPointRecord(long IndexSymbol, string Symbolname, string Code, long x1, long y1, string IO, string DT, string MyNameOfPoint)
        {
            MyLineStructure MyXY;
            MyXY = default(MyLineStructure);
            if (Code != "/point")
            {
                if (Code != "/name")
                {
                    if (Code != "/error")
                        Abug(197, "Trying to insert a " + Code + " as a /point/name/error ", Symbolname, MyNameOfPoint);
                }
            }
            MyXY.a.Xx = x1;
            MyXY.a.Yy = y1;
            MyXY.b.Xx = FindInputOutputIndex(IO);
            MyXY.b.Yy = FindDataTypeIndex(DT);
            MyInsertSymbolLineRecord(IndexSymbol, Symbolname, Code, MyXY, MyNameOfPoint);
        }

        void MyInsertSymbolLineRecord(long IndexSymbol, string Symbolname, string Code, MyLineStructure XY, string MyNameOfPoint)
        {
            // ,            'Named As String)
            long Index;
            long IndexAt;

            MyMakeArraySizesBigger();
            // FindingMyBugs(90) 'hack Least amount of checking here 'hack make sure that there is no errors first  (Buge before here) 2020 08 04
            // This extra code is because of a bug somewhere else.
            // bug, we should never be trying to inser two name records.
            if (Code == "/name")
            {
                for (Index = 1; Index <= NewTopOfFile("Symbol"); Index++) // hack
                {
                    if (Index != IndexSymbol)
                    {
                        if (Symbol_TableCoded_String(Index) == "/name")
                        {
                            if (Symbol_TableSymbolName(Index) == Symbolname)
                            {
                                Abug(201, "Trying to insert the /name=" + Symbolname, " record again At " + IndexSymbol + " : " + Symbol_TableCoded_Byte(IndexSymbol) + " : " + Symbol_TableCoded_String(IndexSymbol) + " : " + Symbol_TableSymbolName(IndexSymbol), "Is already at=" + Index + " : " + Symbol_TableCoded_Byte(Index) + " : " + Symbol_TableCoded_String(Index) + " : " + Symbol_TableSymbolName(Index)); // hack
                                return; // extra Just ignor the error in the program that is doing this
                            } // hack
                        } // hack
                    } // extra
                } // hack
            } // extra
            // 2021 01 04 removed ReSortSymbolList() 'hack this might change where you are inserting at,  needs to be done at the end, or better yet after finishing all inserting
            CheckForAnySortNeeded("", 127);
            IndexAt = IndexSymbol;
            // 20200629 ShowSorts(mytable,ReSortStringArray("Symbol", Symbol_FileSymbolName, Symbol_iSAM_))
            // 2020 07 18 FindInSymbolList(Symbolname) ' Shortcort to Indexes
            if (IndexAt == constantMyErrorCode)
            {
                MyMakeArraySizesBigger();
                // special case, it goes at the end of the file
                IndexAt = NewTopOfFile("Symbol");
                // hack indexat = FindInSymbolList(Symbolname)+1 'Should this be inserted here to force an insert right after the name
                Symbol_TableSymbolName(IndexAt, Symbolname);
                // Symbol_TableCode(IndexAt, "/name")
                Symbol_TableCode(IndexAt, Code);
                Symbol_TableX1(IndexAt, XY.a.Xx);
                Symbol_TableY1(IndexAt, XY.a.Yy);
                Symbol_TableX2(IndexAt, XY.b.Xx);
                Symbol_TableY2(IndexAt, XY.b.Yy);
                Symbol_Table_NameOfPoint(IndexAt, MyNameOfPoint);
                AInfo(622, "Inserted Symbol record", MyShowSymbolGraphic(IndexAt), "");
                ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, IndexAt));
                IndexAt = FindInSymbolList(ref Symbolname); // Shortcort to Indexes
                ReSortSymbolList();

                if (Strings.LCase(Code) == "/name")
                    return;// so we do not add two name records
            }
            else
            {
            }

            for (Index = NewTopOfFile("Symbol"); Index >= IndexAt; Index += -1)
                // FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 04
                MySwapSymbolList(Index, Index + 1);// Move it one record in the 'sorted file, because it's Import to keep them in 'order'
            // Add this record right after the name  record (I hope)
            // FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 05
            Symbol_TableSymbolName(IndexAt, Symbolname);
            Symbol_TableCode(IndexAt, Code);
            // FindingMyBugs(100) 'hack Least amount of checking here 'hack 2020 08 05
            Symbol_TableX1(IndexAt, XY.a.Xx);
            Symbol_TableY1(IndexAt, XY.a.Yy);
            Symbol_TableX2(IndexAt, XY.b.Xx);
            Symbol_TableY2(IndexAt, XY.b.Yy);
            Symbol_Table_NameOfPoint(IndexAt, MyNameOfPoint);

            ReSortSymbolList();
        }


        // Routine Paint ALL Where is the for, (-) is to erase it
        void PaintEach(string Where, MyPointStructure XYOffSetXY, string SymbolName, string RotationName)
        {
            long IndexNamed;
            long IndexSymbol;
            MyPointStructure RotatedXY;

            if (Information.IsNothing(SymbolName) | SymbolName == "")
                return;// Because this is not a symbol

            LimitScale();
            // TDist = myuniverse.SysGen.constants.constantSymbolCenter - (myuniverse.SysGen.constants.constantSymbolCenter / 10) ' Gives me 9/10 of the distance

            // Display the symbol name in on screen

            MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[2].X), System.Convert.ToString(MyUniverse.OptionDisplay[2].Y)), SymbolName, 2);

            IndexNamed = FindIndexIniSAMTable("Named", "NeverAddWhilePainting", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            if (IndexNamed == constantMyErrorCode)
                // MyMsgCtr(1021, "Paint Each", "Symbol Name Not Found ", HighLight(SymbolName), "", "", "", "", "", "", "")
                return;

            // Never update the Indexes while painting
            IndexNamed = CheckNotInList("Named", ref "NeverAddWhilePainting", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref SymbolName);
            if (IndexNamed == constantMyErrorCode)
                // todo need a bug message here instead
                IndexNamed = IndexNamed; // error cant find'error'hack
            else
            {
                if (MyOptionTest(3) == true)
                    MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[3].X), System.Convert.ToString(MyUniverse.OptionDisplay[3].Y)), Named_TableStroke(IndexNamed), 3);
                if (MyOptionTest(4) == true)
                    MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[4].X), System.Convert.ToString(MyUniverse.OptionDisplay[4].Y)), Named_TableNameofFile(IndexNamed), 4);

                if (MyOptionTest(5) == true)
                {
                    MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[5].X), System.Convert.ToString(MyUniverse.OptionDisplay[5].Y)), Named_TableNotes(IndexNamed), 5);
                    MyDoEvents();
                }

                if (MyOptionTest(6) == true)
                {
                    MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[6].X), System.Convert.ToString(MyUniverse.OptionDisplay[6].Y)), Named_TableOpCode(IndexNamed), 6);
                    MyDoEvents();
                }

                if (MyOptionTest(7) == true)
                {
                    MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[7].X), System.Convert.ToString(MyUniverse.OptionDisplay[7].Y)), Named_TableMicroCodeText(IndexNamed), 7);
                    MyDoEvents();
                }

                if (MyOptionTest(8) == true)
                {
                    if (F_C.InvalidIndex(Named_TableSymbolIndexes(IndexNamed), F_C.Named_FileSymbolName))
                    {
                        MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[8].X), System.Convert.ToString(MyUniverse.OptionDisplay[8].Y)), "?", 8);
                        MyDoEvents();
                    }
                    else
                    {
                        MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[8].X), System.Convert.ToString(MyUniverse.OptionDisplay[8].Y)), Named_TableSymbolIndexes(IndexNamed).ToString(), 8);
                        MyDoEvents();
                    }
                }
                IndexSymbol = GetSelfCorrectingIndexes(SymbolName);
                // IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' GetSelfCorrectingIndexes(SymbolName)
                if (IndexSymbol < 1)
                {
                    Named_TableSymbolIndexes(IndexNamed, GetSelfCorrectingIndexes(SymbolName));
                    IndexSymbol = Named_TableSymbolIndexes(IndexNamed); // GetSelfCorrectingIndexes(SymbolName)
                }

                if (IndexSymbol > constantMyErrorCode)
                {
                    if (IndexSymbol > 0)
                    {
                        if (Symbol_TableCoded_String(IndexSymbol) != "/name" | Symbol_TableSymbolName(IndexSymbol) != SymbolName)
                        {
                            IndexSymbol = FindInSymbolList(ref SymbolName); // 20200711 '20200629   ' Find the actual location in the symbol table
                            if (IndexSymbol <= 0)
                            {
                            }
                            else
                            {
                                Abug(202, SymbolName, RotationName, IndexSymbol);
                                return; // 20200713 because we have no graphics to show
                            }
                        }
                        else
                            IndexSymbol = GetSelfCorrectingIndexes(SymbolName);// not in the named table (so assumed not in the symbol table
                    }
                    else
                    {
                        // This is an named symbol with no graphics, so it's an error if we ever get here. but fix it for next time?
                        IndexSymbol = GetSelfCorrectingIndexes(SymbolName); // not in the named table (so assumed not in the symbol table
                        if (IndexSymbol > 0)
                            Named_TableSymbolIndexes(IndexNamed, IndexSymbol);
                        else
                        {
                            Abug(203, SymbolName, IndexNamed, IndexSymbol);
                            IndexNamed = constantMyErrorCode;                                          // Not in the named table.
                        }
                    }
                }
                else
                    Abug(204, "PaintEach(): Symbol Name Not Found in named_Table", SymbolName, RotationName);// invalid symbol index?
            }


            if (IndexSymbol == constantMyErrorCode)
            {
                Abug(205, "Symbol name not found : " + HighLight(SymbolName), IndexNamed, IndexSymbol);
                return;
            }
            IndexSymbol += 1; // after the MyKeyword_2_string(KeyConstName )  for the rest of the symbol till the next name or end
            FindingMyBugs(10); // hack Least amount of checking here 'hack
            while ((Symbol_TableCoded_String(IndexSymbol) != "/name") & (IndexSymbol < TopOfFile("Symbol")))
            {
                switch (Symbol_TableCoded_String(IndexSymbol))
                {
                    case "/line"  // Line Start
                        :
                    {
                        MyDrawLineWithIndex(Where, IndexSymbol, XYOffSetXY, RotationName);
                        break;
                    }

                    case "/point":
                    {
                        RotatedXY = MyRotated_1(IndexSymbol, ZeroZero, RotationName);
                        // todo This should be passing the datatype or color name for the point color.
                        // MyDrawCircle_At(Where, MyPoint1XY(RotatedXY.Xx + XYOffSetXY.Xx, RotatedXY.Yy + XYOffSetXY.Yy), Symbol_TableSymbolName(IndexSymbol), Symbol_Table_NameOfPoint(IndexSymbol))
                        MyDrawCircle_At(Where, MyPoint1XY(RotatedXY.Xx + XYOffSetXY.Xx, RotatedXY.Yy + XYOffSetXY.Yy), Symbol_Table_NameOfPoint(IndexSymbol), Symbol_Table_DataType(IndexSymbol));
                        // , Symbol_TableSymbolName(IndexSymbol) , 
                        MyDrawPointArrow(Where, MyRotated_1(IndexSymbol, XYOffSetXY, RotationName), MyRotated_1a(IndexSymbol, RotationName), Symbol_Table_DataType(IndexSymbol), RotationName, Symbol_TableX2(IndexSymbol));
                        // MyUnEnum(Symbol_Table_InputOutput(IndexSymbol), SymbolScreen.ToolStripDropDownInputOutput, 1), from above
                        MyDrawText(Where, MyRotated_1(IndexSymbol, MyPoint1XY(XYOffSetXY.Xx + System.Convert.Tolong(MyUniverse.OptionDisplay[1].X), XYOffSetXY.Yy + System.Convert.Tolong(MyUniverse.OptionDisplay[1].X)), RotationName), Symbol_Table_NameOfPoint(IndexSymbol), 21);
                        break;
                    }

                    case "/name":
                    {
                        MyDrawText(Where, MyRotated_1(IndexSymbol, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[2].X), System.Convert.ToString(MyUniverse.OptionDisplay[2].Y)), RotationName), Symbol_TableSymbolName(IndexSymbol), 2);
                        break;
                    }

                    case "/delete":
                    {
                        MyDrawCircle_At(Where, ZeroZero, "red", Strings.LCase(Symbol_Table_NameOfPoint(IndexSymbol)));
                        break;
                    }

                    case "/error":
                    {
                        // Why am I calling (11) this display ?
                        MyDrawText(Where, MyRotated_1(IndexSymbol, MyPoint1XY(XYOffSetXY.Xx + System.Convert.Tolong(MyUniverse.OptionDisplay[11].X), XYOffSetXY.Yy + System.Convert.Tolong(MyUniverse.OptionDisplay[11].Y)), RotationName), Symbol_TableSymbolName(IndexSymbol), 11);
                        MyDrawText(Where, MyOffset(XYOffSetXY, System.Convert.ToString(MyUniverse.OptionDisplay[2].X), System.Convert.ToString(MyUniverse.OptionDisplay[2].Y)), SymbolName, 2);
                        MyDrawCircle_At(Where, XYOffSetXY, "red", Strings.LCase(Symbol_TableSymbolName(IndexSymbol)));
                        MyDrawCircle_At(Where, XYOffSetXY, "red", Strings.LCase(Symbol_Table_NameOfPoint(IndexSymbol)));
                        break;
                    }

                    default:
                    {
                        MyDrawCircle_At(Where, ZeroZero, "red", Symbol_TableCoded_String(IndexSymbol));
                        return;
                    }
                }
                IndexSymbol += 1;
                MyDoEvents();
            }
        }

        void PaintErase(string Where, long Index)
        {
            MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = false;
            switch (Where.Parent.Name)
            {
            case "FlowChartScreen":
            {
                PaintAll(Where, Index, Index);
                break;
            }

            case "SymbolScreen":
            {
                PaintEach(Where, ZeroZero, MyUniverse.ProgramOptions.SelectedSymbolName, "default");
                break;
            }
            }
            MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = true;
        }


        void ReSetScrollBars(long Index)
        {
            long A;
            float T1, T2;
            // Make this symbol/Path the center of the page
            T1 = FlowChart_TableX1(Index) + FlowChartScreen.VScrollBar1.Minimum;
            T2 = FlowChartScreen.VScrollBar1.Maximum - FlowChartScreen.VScrollBar1.Minimum;
            A = System.Convert.Tolong(T1 / (double)T2 * (FlowChartScreen.VScrollBar1.Maximum - FlowChartScreen.VScrollBar1.Minimum) / (double)100);
            FlowChartScreen.VScrollBar1.Value = MyMinMax(A, FlowChartScreen.VScrollBar1.Minimum, FlowChartScreen.VScrollBar1.Maximum);

            T1 = FlowChart_TableY1(Index) + FlowChartScreen.HScrollBar1.Minimum;
            T2 = FlowChartScreen.HScrollBar1.Maximum - FlowChartScreen.HScrollBar1.Minimum;
            A = System.Convert.Tolong(T2 / (double)T1 * (FlowChartScreen.HScrollBar1.Maximum - FlowChartScreen.HScrollBar1.Minimum) / (double)100);
            FlowChartScreen.HScrollBar1.Value = MyMinMax(A, FlowChartScreen.HScrollBar1.Minimum, FlowChartScreen.HScrollBar1.Maximum);
            PaintAll(FlowChartScreen.PictureBox1, 1, TopOfFile("FlowChart"));
        }



        // Routine Paint ALL Where is the for, (-) is to erase it
        void PaintAll(string Where, long Start, long Ending)
        {
            MyPointStructure MyXY;
            long IndexFlowChart;
            string MyRotationName;
            MyXY = default(MyPointStructure);
            // FindingMyBugs(20) 'hack Least amount of checking here
            LimitScale();
            Start = MyMinMax(Start, 1, TopOfFile("FlowChart"));
            Ending = MyMinMax(Ending, 1, TopOfFile("FlowChart"));
            for (IndexFlowChart = Start; IndexFlowChart <= Ending; IndexFlowChart++)
            {
                if (MyABS(Ending - Start) > 10)
                {
                    if (IndexFlowChart == Conversion.Int(IndexFlowChart / (double)1000) * 1000)
                    {
                        DisplayMyStatus(IndexFlowChart.ToString());
                        MyDoEvents();
                    }
                }
                switch (Strings.LCase(FlowChart_TableCode(IndexFlowChart)))
                {
                case "/delete":
                {
                    // deleted Text & error text flag
                    MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), System.Convert.ToString(MyUniverse.OptionDisplay[9].X), System.Convert.ToString(MyUniverse.OptionDisplay[9].Y)), FlowChart_TableOther_Name(IndexFlowChart), 9);
                    break;
                }

                case "/error":
                {
                    // Error Text
                    MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), System.Convert.ToString(MyUniverse.OptionDisplay[1].X), System.Convert.ToString(MyUniverse.OptionDisplay[1].Y)), FlowChart_TableOther_Name(IndexFlowChart), 1);
                    break;
                }

                case "/use":
                {
                    if (InSideMyScreen(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart))))
                    {
                        MyRotationName = FlowChart_Table_Rotation(IndexFlowChart);
                        DisplayOBject(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), FlowChart_TableSymbol_Name(IndexFlowChart), MyRotationName);
                        MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), System.Convert.ToString(MyUniverse.OptionDisplay[2].X), System.Convert.ToString(MyUniverse.OptionDisplay[2].Y)), FlowChart_Table_DataType(IndexFlowChart), 2);
                        // input/output
                        MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), System.Convert.ToString(MyUniverse.OptionDisplay[10].X), System.Convert.ToString(MyUniverse.OptionDisplay[10].Y)), FlowChart_TableSymbol_Name(IndexFlowChart), 10);


                        // Path Data Values
                        if (FindIndex_In_TableNetLinks(IndexFlowChart) > 1)
                            MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), (MyUniverse.SysGen.Constants.constantSymbolCenter * -1).ToString(), (-MyUniverse.SysGen.Constants.constantSymbolCenter).ToString()), Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart)), 17);
                    }

                    break;
                }

                case "/path":
                {
                    // ainfo2(17)
                    MyDrawLineS_PathS(Where, IndexFlowChart);
                    MyDrawLineS_PathS(Where, IndexFlowChart);
                    // ainfo2(18)
                    if (MyOptionTest(1) == true)
                    {
                        MyXY.Xx = System.Convert.Tolong((FlowChart_TableX1(IndexFlowChart) + FlowChart_TableX2(IndexFlowChart)) / (double)2);
                        MyXY.Yy = System.Convert.Tolong((FlowChart_TableY1(IndexFlowChart) + FlowChart_TableY2(IndexFlowChart)) / (double)2);
                        MyXY = MyOffset(MyXY, System.Convert.ToString(MyUniverse.OptionDisplay[12].X), System.Convert.ToString(MyUniverse.OptionDisplay[12].Y));
                        MyDrawText(Where, MyXY, FlowChart_TablePath_Name(IndexFlowChart), 1);
                    }

                    break;
                }

                case "/constant":
                {
                    if (InSideMyScreen(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart))))
                    {
                        MyDrawCross(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), FlowChart_Table_DataType(IndexFlowChart), FlowChart_TablePath_Name(IndexFlowChart));
                        // constants
                        MyDrawText(Where, MyOffset(MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), System.Convert.ToString(MyUniverse.OptionDisplay[13].X), System.Convert.ToString(MyUniverse.OptionDisplay[13].Y)), FlowChart_Table_DataType(IndexFlowChart), 13);
                    }

                    break;
                }

                case "/nothing"// do nothing
                    :
                {
                    break;
                }

                case null:
                {
                    break;
                }

                default:
                {
                    break;
                }
                }
            }
        }

        string AddCameFromLine(string CodeLine)
        {
            return " " + MyUniverse.SysGen.Constants.ConstantCameFromLine + " Address" + (MyUniverse.MySS.Inputs.LineNumberIn - 1).ToString() + " " + MyUniverse.ProgramOptions.C_L_MultiLine + CodeLine;  // make it a variable.
        }

        long InsertCameFromLine(string Keyline, long IndexForInsert, long SubLine) // returns the number of characters it added to the string
        {
            string Temp;
            long K;
            K = Strings.Len(Keyline);
            if (SubLine == 0)
                Temp = " ";
            else
                Temp = "_" + Strings.Trim(Conversion.Str(SubLine)) + " ";
            if (IndexForInsert == 1)
                Keyline = MyUniverse.SysGen.Constants.ConstantCameFromLine + Temp + " " + MyUniverse.ProgramOptions.C_L_MultiLine + " " + " " + Strings.Mid(Keyline, IndexForInsert, Strings.Len(Keyline)); // 2020 08 20 added space between 
            else
                Keyline = Strings.Mid(Keyline, 1, IndexForInsert) + MyUniverse.SysGen.Constants.ConstantCameFromLine + Temp + " " + MyUniverse.ProgramOptions.C_L_MultiLine + " " + " " + Strings.Mid(Keyline, IndexForInsert, Strings.Len(Keyline));
            return Strings.Len(Keyline) - K; // cause we always add something
        }

        string AddGotoNextLine(string Codeline)
        {
            return Codeline + MyUniverse.ProgramOptions.C_L_MultiLine + " " + MyUniverse.SysGen.Constants.ConstantGotoNextLine + " Address" + MyUniverse.MySS.Inputs.LineNumberIn + " ";
        }

        long InsertGotoNextLine(string Keyline, long IndexForInsert, long SubLine) // return the number characters it added to the string
        {
            string Temp;
            long K;
            K = Strings.Len(Keyline);
            if (SubLine == 0)
                Temp = " ";
            else
                Temp = "_" + Strings.Trim(Conversion.Str(SubLine)) + " ";
            if (IndexForInsert >= Strings.Len(Keyline))
                Keyline = Keyline + " " + MyUniverse.ProgramOptions.C_L_MultiLine + " " + MyUniverse.SysGen.Constants.ConstantGotoNextLine + Temp;
            else
                Keyline = Strings.Mid(Keyline, 1, IndexForInsert - 1) + " " + MyUniverse.ProgramOptions.C_L_MultiLine + " " + MyUniverse.SysGen.Constants.ConstantGotoNextLine + Temp + Strings.Mid(Keyline, IndexForInsert, Strings.Len(Keyline));
            return Strings.Len(Keyline) - K;
        }


        string NoWhiteSpaceS(string S) // Remove all white space to return just a character  string (For Filenames etc)
        {
            long I, j;
            string T;
            T = S;
            for (j = 1; j <= Strings.Len(S); j++)
            {
                for (I = 1; I <= Strings.Len(MyUniverse.SysGen.Constants.ConstantDelimeters + MyUniverse.SysGen.Constants.ConstantSpecialCharacters); I++)
                {
                    if (Strings.Mid(S, j, 1) == Strings.Mid(MyUniverse.SysGen.Constants.ConstantDelimeters + MyUniverse.SysGen.Constants.ConstantSpecialCharacters, I, 1))
                        ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(T, j, 1)' at character 530721
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                        Mid(T, j, 1) = " "

 */
                }
            }

            NoWhiteSpaceS = "";
            for (j = 1; j <= Strings.Len(Strings.Trim(T)); j++)
            {
                if (Strings.Mid(T, j, 1) != " ")
                    NoWhiteSpaceS += Strings.Mid(T, j, 1);
            }


            // hack OK, why am I removing the digits again? (Boy itsw hard getting old and forgetful)
            while (ThisIsANumber(Strings.Left(NoWhiteSpaceS + "a", 1)))
                NoWhiteSpaceS = Strings.Mid(NoWhiteSpaceS, 2, Strings.Len(NoWhiteSpaceS));
        }


        string RemoveTheseLetters(string InputString, string CharactersToRemove) // 
        {
            long I, j;
            string T;
            T = InputString;
            for (j = 1; j <= Strings.Len(T); j++)
            {
                for (I = 1; I <= Strings.Len(CharactersToRemove); I++)
                {
                    if (Strings.Mid(T, j, 1) == Strings.Mid(CharactersToRemove, I, 1))
                        ;/* Cannot convert AssignmentStatementSyntax, CONVERSION ERROR: Conversion for MidExpression not implemented, please report this issue in 'Mid(T, j, 1)' at character 531640
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.NodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingNodesVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitMidExpression(MidExpressionSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.VisitAssignmentStatement(AssignmentStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:
                        Mid(T, j, 1) = Chr(127)

 */
                }
            }

            RemoveTheseLetters = "";
            for (j = 1; j <= Strings.Len(T); j++)
            {
                if (Strings.Mid(T, j, 1) != Strings.Chr(127))
                    RemoveTheseLetters += Strings.Mid(T, j, 1);
            }
            return T;
        }





        // ***********************************************************************
        // Routine This returns and removes the till the first 'white' space
        // and returns the  string without the whitespace delimiters
        string Pop(string A, string Delimiters) // Returns the first "word" and never the seperating character(s)
        {
            string X;
            A = Strings.Trim(A);
            X = Strings.Left(A, 1);
            A = Strings.Mid(A, 2, Strings.Len(A));
            // This needs to be changed so that we find where the trim is, and then move the  string only once, becuse this way is VERY slow.
            while (Strings.InStr(Delimiters, Strings.Left(A, 1)) == 0)
            {
                X += Strings.Left(A, 1);
                A = Strings.Mid(A, 2, Strings.Len(A));
            }
            Pop = X;
            A = Strings.Trim(Strings.Mid(A, 2, Strings.Len(A))); // to get rid of the character that stopped the pop
        }

        string PopQuote(string A)
        {
            if (Strings.Left(A, Strings.Len(MyUniverse.SysGen.Constants.ConstantQuotes)) == MyUniverse.SysGen.Constants.ConstantQuotes)
            {
                A = Strings.Mid(A, Strings.Len(MyUniverse.SysGen.Constants.ConstantQuotes) + 1, Strings.Len(A));
                return MyUniverse.SysGen.Constants.ConstantQuote;
            }
            PopQuote = Strings.Left(A, 1); // First quote
            A = Strings.Mid(A, 2, Strings.Len(A));
            while (Strings.Left(A, 1) != Strings.Chr(34) & Strings.Len(A) > 0)
            {
                PopQuote = PopQuote + Strings.Left(A, 1);
                A = Strings.Mid(A, 2, Strings.Len(A));
                if (Strings.InStr(A, Strings.Chr(34)) != 0)
                    return MyUniverse.SysGen.Constants.ConstantQuote;
            }
            // Save The Last Quote also
            PopQuote = PopQuote + Strings.Left(A, 1);
            A = Strings.Mid(A, 2, Strings.Len(A));
            return MyUniverse.SysGen.Constants.ConstantQuote;
        }


        // *******************************************************************
        // Routine This returns and removes the till the first 'white' space
        string Pop1(string A, string Delimiters) // Pop the first parsed "word" or special character (See Pop)
        {
            string X;
            if (ThisIsAMarker(A) != "")
            {
                X = ThisIsAMarker(A);
                A = Strings.Mid(A, Strings.Len(X) + 7, Strings.Len(A));
                return X;
            }

            // This needs to be changed so that we find where the trim is, and then move the  string only once, becuse this way is VERY slow.
            X = "";
            while (Strings.InStr(Delimiters, Strings.Left(A, 1)) == 0)
            {
                X += Strings.Left(A, 1);
                A = Strings.Mid(A, 2, Strings.Len(A));
            }
            if (X != "")
                Pop1 = X;
            else
            {
                X = Strings.Left(A, 1); // first character is a delimiters character
                A = Strings.Mid(A, 2, Strings.Len(A));
                Pop1 = X;
            }
            A = Strings.Trim(A); // Do not get rid of the character that stopped the pop
            if (Strings.Len(Pop1) == 0 & Strings.Len(A) != 0)
            {
                Pop1 = Strings.Left(A, 1);
                A = Strings.Mid(Pop1, 2, Strings.Len(A));
            }
            Pop1 = Strings.Trim(Pop1);
        }

        // ************************************************************************************
        // This seperates the  string into parts.
        // see ThisIsAWhat()
        // Basiclly it is parsed by trying to find 
        // first keyWord, Operator, and other known inputs
        // second then variable name

        string MyParse(string MyArray[], string From_What) // makes array of parsed atoms from the codeline
        {
            string A, B;
            long MyErrors;
            long Kounter;

            if (MyUniverse.MyStaticData.LastParsed.LastCodeLine == From_What)
            {
                MyArray = new string[Information.UBound(MyUniverse.MyStaticData.LastParsed.LastParseArray) + 1 + 1];
                for (Kounter = 1; Kounter <= Information.UBound(MyUniverse.MyStaticData.LastParsed.LastParseArray); Kounter++)
                    MyArray[Kounter] = MyUniverse.MyStaticData.LastParsed.LastParseArray[Kounter];
                return MyUniverse.MyStaticData.LastParsed.LastParsedVariableNames;
            }

            // clean out the array
            MyArray = new string[2]; // UBound(MyArray))
            MyParse = FD; // Collect the variable names 

            A = MyTrim(From_What);
            Kounter = 1; // because I dont use z(zero) anywhere else

            while (Strings.Len(A) > 0)
            {
                MyErrors = 1024;
                if (MyErrors < 1)
                    break;
                while (MyErrors > 1) // so I have an exit point
                {
                    AInfo1(997, " Working on ", A, "");
                    if (Information.UBound(MyArray) - 2 < Kounter)
                    {
                        var oldMyArray = MyArray;
                        MyArray = new string[Kounter + 10 + 1];
                        if (oldMyArray != null)
                            Array.Copy(oldMyArray, MyArray, Math.Min(Kounter + 10 + 1, oldMyArray.Length));
                    }
                    MyErrors -= 1;
                    A = Strings.Trim(A);

                    if (Strings.Len(A) < 1)
                        break;
                    B = A; // so we do not loose anythig in the pop (first special character is lost)
                    B = Pop1(ref B, MyUniverse.SysGen.Constants.ConstantDelimeters + MyUniverse.ProgramOptions.C_L_MultiLine);
                    // Need to get all of a marker
                    switch (No_FieldDelimiter(ThisIsAWhat(B)))
                    {
                    case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                    {
                        MyArray[Kounter] = MyUniverse.SysGen.Constants.ConstantGotoNextLine; // & " " & B
                        A = MyReplace(A, B, "");
                        break;
                    }

                    case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                    {
                        MyArray[Kounter] = MyUniverse.SysGen.Constants.ConstantCameFromLine; // & " " & B
                        A = MyReplace(A, B, "");
                        break;
                    }

                    case "C_L_Comment":
                    {
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                        A = MyUniverse.SysGen.Constants.ConstantGotoNextLine;
                        break;
                    }

                    case "C_L_Extention":
                    {
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                        A = Strings.Mid(A, 2, Strings.Len(ThisIsAWhat(B)));
                        break;
                    }

                    case "C_L_MultiLine":
                    {
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                        A = Strings.Mid(A, Strings.Len(MyUniverse.ProgramOptions.C_L_MultiLine) + 1, Strings.Len(A));
                        break;
                    }

                    case "C_L_VarChars":
                    {
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                        A = Strings.Mid(A, 2, Strings.Len(ThisIsAWhat(B)));
                        break;
                    }

                    case "Quote":
                    {
                        // Save The First Quote
                        MyArray[Kounter] = Strings.Left(A, 1); // First quote
                        A = Strings.Mid(A, 2, Strings.Len(A));
                        while (Strings.Left(A, 1) != Strings.Trim(MyUniverse.SysGen.Constants.ConstantQuote) & Strings.Len(A) > 0)
                        {
                            MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                            A = Strings.Mid(A, 2, Strings.Len(A));
                        }
                        // Save The Last Quote also
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                        A = Strings.Mid(A, 2, Strings.Len(A));
                        MyParse += "String" + FD;
                        break;
                    }

                    case "comment":
                    {
                        MyArray[Kounter] = Strings.Trim(A);
                        // A = "" ' everything afterwards is considered part of the comment
                        A = MyUniverse.SysGen.Constants.ConstantGotoNextLine;// Except that we have to goto the next line 
                        break;
                    }

                    case "KeyWord":
                    case "Operator":
                    case "Function":
                    {
                        A = Strings.Trim(A);
                        // B = Trim(A) ' so we do not loose anythig in the pop (first special character is lost)
                        // B = Pop1(B, MyUniverse.SysGen.Constants.ConstantDelimeters)
                        MyArray[Kounter] = Strings.Trim(B);
                        A = Strings.Trim(Strings.Mid(Strings.Trim(A), Strings.Len(B) + 1, Strings.Len(A))); // remove B From A
                        break;
                    }

                    case "Alpha":
                    {
                        while (ThisIsAnAlpha(A))
                        {
                            MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                            A = Strings.Mid(A, 2, Strings.Len(A));
                        }
                        MyParse += MyArray[Kounter] + FD;
                        break;
                    }

                    case "Number":
                    {
                        while (ThisIsANumber(A))
                        {
                            MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                            A = Strings.Mid(A, 2, Strings.Len(A));
                        }
                        MyParse += MyArray[Kounter] + FD;
                        break;
                    }

                    case "SpecialCharacter":
                    {
                        MyArray[Kounter] = Strings.Left(A, 1);
                        A = Strings.Mid(A, 2, Strings.Len(A));
                        while (ThisIsASpecalCharacter(A) & Strings.Len(A) > 0)
                        {
                            MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                            A = Strings.Mid(A, 2, Strings.Len(A));
                        }

                        break;
                    }

                    case "Variable":
                    {
                        if (ThisIsAnAlpha(A))
                        {
                            while (ThisIsAVariableName(A))
                            {
                                MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                                A = Strings.Mid(A, 2, Strings.Len(A));
                            }
                        }
                        else if (ThisIsANumber(A))
                        {
                            while (ThisIsANumber(A))
                            {
                                MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                                A = Strings.Mid(A, 2, Strings.Len(A));
                            }
                        }
                        MyParse += MyArray[Kounter] + FD;
                        break;
                    }

                    case "FieldDelimiter":
                    {
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, Strings.Len(FD));
                        A = Strings.Mid(A, Strings.Len(FD) + 1, Strings.Len(A));
                        break;
                    }

                    case "Unknown":
                    {
                        Abug(206, "unknown Character Clasifacition", A, ThisIsAWhat(A));
                        MyArray[Kounter] = MyArray[Kounter] + Strings.Left(A, 1);
                        A = Strings.Mid(A, 2, Strings.Len(A));
                        break;
                    }

                    case null:
                    {
                        break;
                    }

                    default:
                    {
                        if (Strings.InStr(B, ".") != 0)
                        {
                            if (Strings.InStr(B, MyUniverse.SysGen.Constants.RMStart) > 0)
                            {
                                if (Strings.InStr(B, MyUniverse.SysGen.Constants.RMEnd) > 0)
                                {
                                    MyArray[Kounter] = MyArray[Kounter] + B;
                                    A = Strings.Mid(A + "   ", Strings.Len(B) + 1, Strings.Len(A) + 5);
                                    MyParse += MyArray[Kounter] + FD;
                                }
                                else
                                    Abug(207, "Variable is missing the End marker " + MyUniverse.SysGen.Constants.RMEnd, " But has the first marker " + MyUniverse.SysGen.Constants.RMStart, " and has the period");
                            }
                            else
                                Abug(208, "Variable is missing the Start marker " + MyUniverse.SysGen.Constants.RMEnd, "", " and has the period");
                        }
                        else
                            Abug(209, "Unknow what this is", HighLight(B), HighLight(ThisIsAWhat(B)));
                        break;
                    }
                    }
                    Kounter += 1;
                    MyErrors -= 1;
                }
            }
            MyUniverse.MyStaticData.LastParsed.LastCodeLine = From_What;
            Kounter = Information.UBound(MyArray);
            while (Kounter > Information.LBound(MyArray))
            {
                if (MyArray[Kounter] != null)
                    break;
                Kounter -= 1;
            }
            MyUniverse.MyStaticData.LastParsed.LastParseArray = new string[Kounter + 1 + 1];
            for (Kounter = 1; Kounter <= Information.UBound(MyUniverse.MyStaticData.LastParsed.LastParseArray) - 1; Kounter++)
                MyUniverse.MyStaticData.LastParsed.LastParseArray[Kounter] = MyArray[Kounter];


            // hack, This is really a foolish hack
            // incase I needed more names (because of some bug somewhere else, I need it
            MyParse += MakePathName("V1_" + Strings.Right(My_INT(VBMath.Rnd() * 100000000 + 100000000).ToString(), 6)) + FD;
            MyParse += MakePathName("V2_" + Strings.Right(My_INT(VBMath.Rnd() * 100000000 + 100000000).ToString(), 6)) + FD;
            MyParse += MakePathName("V3_" + Strings.Right(My_INT(VBMath.Rnd() * 100000000 + 100000000).ToString(), 6)) + FD;
            MyParse += MakePathName("V4_" + Strings.Right(My_INT(VBMath.Rnd() * 100000000 + 100000000).ToString(), 6)) + FD;
            // hack end of the foolish hack!


            MyUniverse.MyStaticData.LastParsed.LastParsedVariableNames = MyParse;
        }

        // ***********************************************************************
        // Test if imbedded mark
        bool ThisIsAGotoNextLine(string CodeLine)
        {
            if (Strings.Left(Strings.Trim(CodeLine), Strings.Len(MyUniverse.SysGen.Constants.ConstantGotoNextLine)) == MyUniverse.SysGen.Constants.ConstantGotoNextLine)
                return true;
            return false;
        }
        // ***********************************************************************
        // Test if imbedded mark
        bool ThisIsACameFromLine(string CodeLine)
        {
            if (Strings.Left(Strings.Trim(CodeLine), Strings.Len(MyUniverse.SysGen.Constants.ConstantCameFromLine)) == MyUniverse.SysGen.Constants.ConstantCameFromLine)
                return true;
            return false;
        }


        void SetNameOfPoint(MyPointStructure XY, string PointName, string SymbolName, string PathName)
        {
            XY.Named.Pointname = PointName;
            XY.Named.SymbolName = SymbolName;
            XY.Named.PathName = PathName;
        }


        string NameOfPointOnly(string A)
        {
            string B;
            long I1, I2, I3, I4;
            B = A;
            I1 = Strings.InStr(B, ".");
            I2 = Strings.InStr(B, MyUniverse.SysGen.Constants.RMStart);
            I3 = Strings.InStr(B, MyUniverse.SysGen.Constants.RMEnd);
            I4 = Strings.Len(MyUniverse.SysGen.Constants.RMStart);

            if (I1 != 0 & I2 != 0 & I3 != 0)
                return Strings.Mid(B, I2 + I4, I1 - I4 - I2);
            return A;
        }


        string NoFD(string A)
        {
            NoFD = A;
            while (Strings.Left(NoFD, Strings.Len(FD)) == FD)
                NoFD = Strings.Mid(NoFD, 2, Strings.Len(NoFD));
        }


        string No_FieldDelimiter(string A)
        {
            No_FieldDelimiter = Strings.Trim(A);
            if (Strings.Left(No_FieldDelimiter, Strings.Len(MyUniverse.SysGen.Constants.RMStart)) == MyUniverse.SysGen.Constants.RMStart)
            {
                No_FieldDelimiter = Strings.Mid(No_FieldDelimiter, 4, Strings.Len(No_FieldDelimiter));
                if (Strings.Right(No_FieldDelimiter, Strings.Len(MyUniverse.SysGen.Constants.RMEnd)) == MyUniverse.SysGen.Constants.RMEnd)
                    return Strings.Mid(No_FieldDelimiter, 1, Strings.Len(No_FieldDelimiter) - 3);
            }
            // A I N F O 2 (-146)
            return A;
        }

        // ***************************************************************
        // This determines what part of the code  string is:
        // A inputed language keyword
        // A inputed language operator
        // A inputed language function name
        // A quote or comment
        // and then a number, an alpha, or a variable name or special namings

        // ie:
        // a=b & "that"  
        // gives the symtax of 
        // variablemarkder specialmarker variablemarkder specialmarker quotemarker

        string ThisIsAWhat(string CodeLine)
        {
            string X, A;
            A = CodeLine;
            if (ThisIsAMarker(A) != "")
            {
                X = ThisIsAMarker(A);
                return X;
            }

            if (Information.IsNothing(CodeLine))
                return null;
            if (CodeLine == "")
                return "Unknown";

            if (ThisIsAGotoNextLine(CodeLine))
                return MyUniverse.SysGen.Constants.ConstantGotoNextLine;
            if (ThisIsACameFromLine(CodeLine))
                return MyUniverse.SysGen.Constants.ConstantCameFromLine;
            if (ThisIsAQuote(CodeLine))
                return "Quote";
            if (ThisIsAComment(CodeLine))
                return "Comment";
            if (ThisIsA_KeyWord(CodeLine))
                return "KeyWord";
            if (ThisIsA_Function(CodeLine))
                return "Function";
            if (ThisIsA_Operator(CodeLine))
                return "Operator";
            if (ThisIsAVariableName(CodeLine))
                return "Variable";
            if (ThisIsANumber(CodeLine))
                return "Number"; // number is alway a variable(Need to add option to over ride, and a mnemonic)
            if (ThisIsAnAlpha(CodeLine))
                return "Alpha"; // Alpha is always a variable (Need to add an option to over ride, and also a mnemonic)

            X = MyUniverse.ProgramOptions.C_L_MultiLine; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return "C_L_MultiLine";
            X = MyUniverse.ProgramOptions.C_L_Comment; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return "C_L_Comment";
            X = MyUniverse.ProgramOptions.C_L_Extention; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return "C_L_Extention";
            X = MyUniverse.SysGen.Constants.ConstantGotoNextLine; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return MyUniverse.SysGen.Constants.ConstantGotoNextLine;

            if (ThisIsAMarker(CodeLine) != "")
                return "variable"; // this will return if it is a  MyUniverse.SysGen.Constants.RMStart & point.name & MyUniverse.SysGen.Constants.RMEnd  format which is a variable
            if (ThisIsAMarker2(CodeLine) != "")
                return "variable";

            if (Strings.Left(CodeLine, Strings.Len(FD)) == FD)
                return "FieldDelimiter";

            if (ThisIsASpecalCharacter(CodeLine))
                return "SpecialCharacter";


            return "Unknown";
        }


        // ***********************************************************************
        // Test if imbedded mark is a start of a comment
        bool ThisIsAComment(string CodeLine)
        {
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantComment)) == MyUniverse.SysGen.Constants.ConstantComment)
                return true;
            if (CodeLine == MyUniverse.ProgramOptions.C_L_Comment)
                return true;
            // If ThisIsAMarker(CodeLine) <> "" Then Return False
            return false;
        }



        // ***********************************************************************
        // Test if the  string is all digits
        bool ThisIsANumber(string CodeLine)
        {
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantNumber)) == MyUniverse.SysGen.Constants.ConstantNumber)
                return true;
            if (ThisIsAMarker(CodeLine) != "")
                return false;
            if (Strings.Left(CodeLine, 1) >= "0" & Strings.Left(CodeLine, 1) <= "9")
                return true;
            return false;
        }

        // ***********************************************************************
        // Test if the  string is all alapha characters
        bool ThisIsAnAlpha(string CodeLine)
        {
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantAlpha)) == MyUniverse.SysGen.Constants.ConstantAlpha)
                return true;
            if (ThisIsAMarker(CodeLine) != "")
                return false; // Any other marker
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantAlpha)) == MyUniverse.SysGen.Constants.ConstantAlpha)
                return true;
            if (Strings.Left(CodeLine, 1) >= "A" & Strings.Left(CodeLine, 1) <= "Z")
                return true;
            if (Strings.Left(CodeLine, 1) >= "a" & Strings.Left(CodeLine, 1) <= "z")
                return true;
            return false;
        }


        // ***********************************************************************
        // Test if the  string is special character mark
        bool ThisIsASpecalCharacter(string CodeLine)
        {
            // First test if it a marker
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantSpecialCharacter)) == MyUniverse.SysGen.Constants.ConstantSpecialCharacter)
                return true;
            if (ThisIsAMarker(CodeLine) != "")
                return false;
            if (ThisIsAVariableName(CodeLine) == true)
                return false; // if it is a variable name (including special characters for this language

            // todo make sure that special characters for this language for this variable is not included
            if (Strings.InStr(MyUniverse.SysGen.Constants.ConstantSpecialCharacters + Constants.vbCr + Constants.vbLf + Constants.vbTab + MyUniverse.SysGen.Constants.ConstantWhiteSpace + FD, Strings.Left(CodeLine, 1)) > 0)
                return true;
            else
                // todo This only gets known special characters, if it is a forign language character set then it returns false.
                // Todo  I need to sometime in the future make provissions for non-7 bit Ascii character sets. (Either here or some where else.)
                return false;
        }

        // ***********************************************************************
        // Test if imbedded mark for a quote
        bool ThisIsAQuote(string CodeLine) // returns is this is the start of a quote
        {
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantQuotes)) == MyUniverse.SysGen.Constants.ConstantQuotes)
                return true;
            if (Strings.Left(Strings.Trim(CodeLine), 1) == Strings.Trim(MyUniverse.SysGen.Constants.ConstantQuote))
                return true;
            if (ThisIsAMarker(CodeLine) != "")
                return false; // casue its not quotes
            return false;
        }


        // ***********************************************************************
        // We are still not finding it in the list even tho it is there (Found with a loop through them all

        bool ThisIsA_KeyWord(string CodeLine) // returns is this is in the keyword list (ignores markers)
        {
            long I;
            string A, B;

            A = CodeLine;
            B = A;
            B = Strings.Trim(Pop1(ref B, MyUniverse.SysGen.Constants.ConstantWhiteSpace));  // Trim(Pop1(B, myuniverse.SysGen.constants.constantDelimeters))
            if (Information.IsNothing(B) | B == "")
                return false;
            I = FindInSortedLanguageList("Keyword", ref B, ref Language_KeyWord);
            if (I > Information.UBound(Language_KeyWord))
                Abug(211, "Index returnd outside of array size " + I, Information.UBound(Language_KeyWord), 0);
            if (I != constantMyErrorCode)
            {
                if (Language_KeyWord[I] == B)
                    return true;
                else
                    return false;
            }

            // Else we have to search it item by item (and resort it also
            for (I = 1; I <= Information.UBound(Language_KeyWord); I++)
            {
                if (Strings.LCase(B) == Strings.LCase(Language_KeyWord[I]))
                {
                    Abug(212, "(This is a function(): find in sorted language list() failed to find an existing word", B, "Found at " + I);
                    return true;
                }
            }
            return false;
        }

        // ***********************************************************************
        // Test if this is in the inputed keyWord list
        bool ThisIsA_Function(string CodeLine) // returns is this is in the keyword list (ignores markers)
        {
            long I;
            string A, B;
            A = CodeLine;
            B = A;
            B = Strings.Trim(Pop1(ref B, MyUniverse.SysGen.Constants.ConstantWhiteSpace)); // to get just one word
            if (Information.IsNothing(B) | B == "")
                return false;

            I = FindInSortedLanguageList("Function", ref B, ref Language_Function);
            if (I != constantMyErrorCode)
            {
                if (Language_Function[I] == B)
                    return true;
                else
                    return false;
            }

            // It say's it faild to find it, 
            if (I >= Information.LBound(Language_Function) & I <= Information.UBound(Language_Function))
                Abug(213, "binary search did not find keyword/operator/function- ThisIsA_Fuunction() Searching for " + HighLight(B), " Found " + HighLight(Language_Function[I]), "");// hack // hack

            // Else we have to search it item by item (and resort it also
            for (I = 1; I <= Information.UBound(Language_Function); I++)
            {
                if (Strings.LCase(B) == Strings.LCase(Language_Function[I]))
                {
                    // This is hear because finInSortedLanguageList() failed.  It is there, but did not return it correctly
                    Abug(214, "Failed binary search - ThisIsA_Fuunction() Searching for " + HighLight(B), " Found " + HighLight(Language_Function[I]), " looking at each item - At " + I.ToString());
                    // hack ************ follow this through if you get here
                    // ?I =
                    FindInSortedLanguageList("Function", ref B, ref Language_Function);
                    return true;
                }
            }
            // no need to test if it is a marker.
            // If ThisIsAMarker(CodeLine) <> "" Then Return False
            return false;
        }

        // ***********************************************************************
        // Test if this is in the inputed operator list
        bool ThisIsA_Operator(string CodeLine) // returns is this is in the keyword list (ignores markers)
        {
            long I;
            string A, B;
            A = CodeLine;
            B = A;
            B = Strings.Trim(Pop1(ref B, MyUniverse.SysGen.Constants.ConstantWhiteSpace)); // to get just one word
            if (Information.IsNothing(B) | B == "")
                return false;
            // Hardcoded for now all keyWord I can think of untill I put it in a /Keyword,language,keyWord

            I = FindInSortedLanguageList("Operator", ref B, ref Language_Operator);
            if (I != constantMyErrorCode)
            {
                if (Language_Operator[I] == B)
                    return true;
                else
                    return false;
            }

            // Else we have to search it item by item (and resort it also
            for (I = 1; I <= Information.UBound(Language_Operator); I++)
            {
                if (Strings.LCase(B) == Strings.LCase(Language_Operator[I]))
                {
                    Abug(215, "(This is a Operator(): find in sorted language list() failed to find an existing word", B, "Found at " + I);
                    return true;
                }
            }
            if (ThisIsAMarker(CodeLine) != "")
                return false;
            return false; // Not an operator
        }

        // ***********************************************************************
        // Test if imbedded mark for a variable name
        bool ThisIsAVariableName(string Codeline)
        {
            string TS, TE;
            TS = MyUniverse.SysGen.Constants.RMStart;
            TE = MyUniverse.SysGen.Constants.RMEnd;


            if (Strings.Len(Codeline) == 0)
                return false;

            if (Strings.Left(Codeline, Strings.Len(TS)) == TS)
            {
                if (Strings.Right(Codeline, Strings.Len(TE)) == TE)
                {
                    if (Strings.InStr(Codeline, ".") != 0)
                        return true;
                }
            }


            if (Strings.Left(Codeline, Strings.Len(MyUniverse.SysGen.Constants.ConstantVariable)) == MyUniverse.SysGen.Constants.ConstantVariable)
                return true;

            if (ThisIsAMarker(Codeline) != "")
                return false;

            if (ThisIsAnAlpha(Codeline))
                return true;
            else if (ThisIsANumber(Codeline))
                return true;
            return false;
        }


        // ***********************************************************************
        // returns the length of the marker (if any)
        // returns zero if not a marker
        // 21/02/2021 changed to return then name instead of the length
        string ThisIsAMarker(string CodeLine) // this returns the length of the marker (Which is always 3, excepte for one case, and if it changes in the future)
        {
            string X;
            if (CodeLine == "")
                return "";
            // All markers must start with {[(
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.RMStart)) != MyUniverse.SysGen.Constants.RMStart)
                return "";
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantQuotes)) == MyUniverse.SysGen.Constants.ConstantQuotes)
                return MyUniverse.SysGen.Constants.ConstantQuotes;
            // todo need to make this also look for {[(name.PATH)]} (or what ever...)
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantNumber)) == MyUniverse.SysGen.Constants.ConstantNumber)
                return MyUniverse.SysGen.Constants.ConstantNumber;
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantAlpha)) == MyUniverse.SysGen.Constants.ConstantAlpha)
                return MyUniverse.SysGen.Constants.ConstantAlpha;
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantGotoNextLine)) == MyUniverse.SysGen.Constants.ConstantGotoNextLine)
                return MyUniverse.SysGen.Constants.ConstantGotoNextLine;
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantCameFromLine)) == MyUniverse.SysGen.Constants.ConstantCameFromLine)
                return MyUniverse.SysGen.Constants.ConstantCameFromLine;
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantComment)) == MyUniverse.SysGen.Constants.ConstantComment)
                return MyUniverse.SysGen.Constants.ConstantComment;
            X = MyUniverse.ProgramOptions.C_L_MultiLine; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return X;
            X = MyUniverse.ProgramOptions.C_L_Comment; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return X;
            X = MyUniverse.ProgramOptions.C_L_Extention; if (Strings.Left(CodeLine, Strings.Len(X)) == X)
                return X;
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantVariable)) == MyUniverse.SysGen.Constants.ConstantVariable)
                return MyUniverse.SysGen.Constants.ConstantVariable;
            if (ThisIsAMarker2(CodeLine) != "")
                return ThisIsAMarker2(CodeLine); // Returns the length of this marker format MyUniverse.SysGen.Constants.RMStart & point.name & MyUniverse.SysGen.Constants.RMEnd
            // All special characters are after language special characters
            if (Strings.Left(CodeLine, Strings.Len(MyUniverse.SysGen.Constants.ConstantSpecialCharacter)) == MyUniverse.SysGen.Constants.ConstantSpecialCharacter)
                return MyUniverse.SysGen.Constants.ConstantSpecialCharacter;

            return ThisIsAMarker2(CodeLine); // Not a marker but might still be one of this kind
        }



        // *******************************************************************
        // This will return the variable if in the form variable.variable 
        // This has not be verified to work
        // 02/21/2021 THis return s the marker now
        string ThisIsAMarker2(string CodeLine) // this will return the variable if in formation [variable.option]
        {
            string X, VariableName, PartName;
            long M1, M2, M3, M4;
            X = CodeLine;
            if (Strings.Left(X, Strings.Len(MyUniverse.SysGen.Constants.RMStart)) == MyUniverse.SysGen.Constants.RMStart)
            {
                M1 = 1;
                M2 = Strings.InStr(CodeLine, ".");
                M3 = Strings.InStr(CodeLine, MyUniverse.SysGen.Constants.RMEnd);
                M4 = Strings.Len(CodeLine);
                if (M4 < M3)
                    return "";
                if (M3 < M2)
                    return "";
                if (M2 < M1)
                    return "";
                VariableName = Strings.Mid(CodeLine, 4, M2 - 4);
                PartName = Strings.Mid(CodeLine, M2 + 1, M3 - M2 - 1);

                if (ThisIsAVariableName(VariableName))
                {
                    if (ThisIsAPointAttribute(PartName) != "")
                        return MyUniverse.SysGen.Constants.RMStart + VariableName + "." + PartName + MyUniverse.SysGen.Constants.RMEnd;
                }
                if (Strings.Len(VariableName) == 0)
                {
                    if (Strings.Len(PartName) != 0)
                    {
                        AInfo1(782, "No Variable Name", Strings.Mid(X, 1, Strings.Len(PartName) + 7), "");
                        return Strings.Mid(X, 1, Strings.Len(PartName) + 7);
                    }
                }
            }
            else
                return "";
            Abug(216, "This starts with a marker but NOT known", CodeLine, "");
            return "";
        }

        string ThisIsAPointAttribute(string CodeLine)
        {
            // todo need to documentate these {[(name.PointAttribute)]}
            switch (Strings.LCase(CodeLine))
            {
            case "author":
            {
                return CodeLine;
            }

            case "bytes":
            {
                return CodeLine;
            }

            case "datatype":
            {
                return CodeLine;
            }

            case "datatypename":
            {
                return CodeLine;
            }

            case "datatypedescribtion":
            {
                return CodeLine;
            }

            case "datatypecolor":
            {
                return CodeLine;
            }

            case "distance":
            {
                return CodeLine;
            }

            case "filename":
            {
                return CodeLine;
            }

            case "index":
            {
                return CodeLine;
            }

            case "indexes":
            {
                return CodeLine;
            }

            case "io":
            {
                return CodeLine;
            }

            case "name":
            {
                return CodeLine;
            }

            case "notes":
            {
                return CodeLine;
            }

            case "opcode":
            {
                return CodeLine;
            }

            case "rotation":
            {
                return CodeLine;
            }

            case "stroke":
            {
                return CodeLine;
            }

            case "version":
            {
                return CodeLine;
            }

            case "xa":
            {
                return CodeLine;
            }

            case "x":
            {
                return CodeLine;
            }

            case "ya":
            {
                return CodeLine;
            }

            case "y":
            {
                return CodeLine;
            }

            case "pathname":
            {
                return CodeLine;
            }

            case "variable":
            {
                return CodeLine;
            }

            case "path":
            {
                return CodeLine;
            }

            case "pathX":
            {
                return CodeLine;
            }

            case "pathY":
            {
                return CodeLine;
            }

            case "width":
            {
                return CodeLine;
            }

            default:
            {
                return "";
            }
            }
            return "";
        }


        // ***********************************************************************
        // Routine This returns and removes till a carriage return or Line Feed
        string PopLine(string A) // Return up to the first CRLF, CR or LF
        {
            string B;
            PopLine = Strings.Left(A, 1);
            A = Strings.Mid(A, 2);
            B = Strings.Left(A + Strings.Chr(10), 1);
            while (Strings.Len(A) >= 1 & B != Constants.vbCr & B != Constants.vbCrLf & B != Constants.vbLf) // B > Chr(16) And '
            {
                PopLine += Strings.Left(A, 1);
                A = Strings.Mid(A, 2);
                B = Strings.Left(A + Strings.Chr(10), 1);
            }
        }



        long My_INT(string Text) // Cint() ignore all first ,'s.
        {
            long Sign;
            string Temp;
            Temp = Text;
            if (Strings.Left(Temp, Strings.Len(FD)) == FD)
                Temp = Strings.Mid(Temp, Strings.Len(FD), Strings.Len(Temp));
            Sign = 1;
            My_INT = 0;
            while (Strings.Len(Temp) > 0)
            {
                switch (Strings.Left(Temp, 1))
                {
                case "-":
                {
                    Sign = -1;
                    break;
                }

                case "0":
                {
                    My_INT = My_INT * 10 + 0;
                    break;
                }

                case "1":
                {
                    My_INT = My_INT * 10 + 1;
                    break;
                }

                case "2":
                {
                    My_INT = My_INT * 10 + 2;
                    break;
                }

                case "3":
                {
                    My_INT = My_INT * 10 + 3;
                    break;
                }

                case "4":
                {
                    My_INT = My_INT * 10 + 4;
                    break;
                }

                case "5":
                {
                    My_INT = My_INT * 10 + 5;
                    break;
                }

                case "6":
                {
                    My_INT = My_INT * 10 + 6;
                    break;
                }

                case "7":
                {
                    My_INT = My_INT * 10 + 7;
                    break;
                }

                case "8":
                {
                    My_INT = My_INT * 10 + 8;
                    break;
                }

                case "9":
                {
                    My_INT = My_INT * 10 + 9;
                    break;
                }

                case FD:
                {
                    return;
                }

                default:
                {
                    My_INT = My_INT; // This should never happen 
                    break;
                }
                }
                Temp = Strings.Mid(Temp, 2, Strings.Len(Temp));
            }
            My_INT *= Sign;
        }


        long PopNonZeroValue(string A)
        {
            PopNonZeroValue = PopValue(ref A);
            while (Strings.Len(A) > 0 & PopNonZeroValue == 0)
                PopNonZeroValue = PopValue(ref A);
        }


        MyLineStructure MyPathTextValues2Line(long FlowChartIndex, string S)
        {
            MyPathTextValues2Line = default(MyLineStructure);
            MyPathTextValues2Line.a.Named.PathName = FlowChart_Table_Path_SymbolName(FlowChartIndex);
            MyPathTextValues2Line.a.Xx = PopValue(ref S);
            MyPathTextValues2Line.a.Yy = PopValue(ref S);
            MyPathTextValues2Line.b.Xx = PopValue(ref S);
            MyPathTextValues2Line.b.Yy = PopValue(ref S);
            MyPathSnap(ref MyPathTextValues2Line, MyPathTextValues2Line);
            FlowChart_TableX1(FlowChartIndex, MyPathTextValues2Line.a.Xx);
            FlowChart_TableY1(FlowChartIndex, MyPathTextValues2Line.a.Yy);
            FlowChart_TableX2(FlowChartIndex, MyPathTextValues2Line.b.Xx);
            FlowChart_TableY2(FlowChartIndex, MyPathTextValues2Line.b.Yy);
        }



        MyLineStructure MyUseTextValues2Line(long FlowChartIndex, string S)
        {
            MyUseTextValues2Line = default(MyLineStructure);
            MyUseTextValues2Line.a = default(MyPointStructure);
            MyUseTextValues2Line.a.Xx = PopValue(ref S);
            MyUseTextValues2Line.a.Yy = PopValue(ref S);
            MyUseTextValues2Line.a = MySymbolSnap(MyUseTextValues2Line.a);
            FlowChart_TableX1(FlowChartIndex, MyUseTextValues2Line.a.Xx);
            FlowChart_TableY1(FlowChartIndex, MyUseTextValues2Line.a.Yy);
        }


        // ***********************************************************************
        // Routine This returns and removes all numbers before 'white' space
        long PopValue(string A) // Returns a number from the  string My_Int() & Value()
        {
            string Xstring;
            string Ystring;
            int Sign, Multiplyer;
            Sign = 1; // final sign of the number
            Multiplyer = 10; // stops when there is a period .
            PopValue = 0;
            A = MyTrim(A);
            Xstring = "";
            Ystring = " ";
            // This needs to be changed so that we find where the trim is, and then move the  string only once, becuse this way is VERY slow.
            while (Strings.Len(Xstring) < 8 & (Ystring >= "0" & Ystring <= "9") | Ystring == " " | Ystring == "-")
            {
                Xstring += Ystring;
                switch (Ystring)
                {
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                {
                    PopValue = PopValue * Multiplyer + My_INT(Ystring);
                    break;
                }

                case ".":
                {
                    Multiplyer = 1;
                    break;
                }

                case "-":
                {
                    Sign = -1;
                    break;
                }
                }
                Ystring = Left(A, 1);
                if (Strings.Len(A) > 0)
                    A = Strings.Mid(A, 2, Strings.Len(A));
            }
            // flow10'Change to get the value character by character 
            PopValue *= Sign; // My_Int(Trim(Xstring) & ".0")
        }

        string MyFormName(string Formed)
        {
            switch (Strings.LCase(Formed))
            {
            case "flowchartscreen":
            {
                return FlowChartScreen.Name;
            }

            case "symbolscreen":
            {
                return SymbolScreen.Name;
            }

            case "optionscreen":
            {
                return OptionScreen.Name;
            }

            case "":
            {
                return FileInputOutputScreen.Name;
            }

            case "toolstripflowchart":
            {
                // todo return the name of the owner Also rename one of the too
                // todo rename all of the toolstrips 1-
                return FlowChartScreen.Name;
            }

            case "toolstripoption":
            {
                return OptionScreen.Name;
            }

            case "toolstripsymboltop":
            case "toolstripsymbolbottom":
            {
                return SymbolScreen.Name;
            }

            default:
            {
                return "";
            }
            }
            return ""; // does not ever get here.
        }


        long FindInDropDownButton(string ItemName, ToolStripDropDownButton TSDD)
        {
            long I;
            string Temp;
            for (I = 0; I <= TSDD.DropDownItems.Count - 1; I++)
            {
                Temp = TSDD.DropDownItems(I).Text;
                if (ItemName == Pop(ref Temp, FD))
                    return I;
            }
            return constantMyErrorCode;
        }



        // ***********************************************************************
        // Returns the whole list of this record
        string MyUnEnum(long Number, ToolStripDropDownButton MyCombobox, long ItemNumberOffset)
        {
            long I;
            string Temp;
            long Count;
            var oldMyUniverse.MyStaticData.MyUnEnum.LastResults = MyUniverse.MyStaticData.MyUnEnum.LastResults;
            MyUniverse.MyStaticData.MyUnEnum.LastResults = new string[21];
            if (oldMyUniverse.MyStaticData.MyUnEnum.LastResults != null)
                Array.Copy(oldMyUniverse.MyStaticData.MyUnEnum.LastResults, MyUniverse.MyStaticData.MyUnEnum.LastResults, Math.Min(21, oldMyUniverse.MyStaticData.MyUnEnum.LastResults.Length));
            string PaRnt;
            Count = MyCombobox.DropDownItems.Count;
            MyUnEnum = "";

            PaRnt = MyCombobox.GetCurrentParent.Name;
            PaRnt = MyFormName(PaRnt);
            if (Number == constantMyErrorCode)
            {
                AInfo(623, PaRnt + " : " + " ndex is invalid index into the combobox" + MyCombobox.Name, Number, ItemNumberOffset);
                MyUnEnum = "";
                return;
            }
            // Test if this is a number and not a Indexes to the combobox
            if (Number > Count - 1)
            {
                AInfo(624, "The index is bigger than the combobox list in " + MyCombobox.Name + " at " + Number, " number in the combobox" + MyCombobox.DropDownItems.Count, "Get number " + Number);
                MyUnEnum = System.Convert.ToString(Number);
                return;
            }
            Temp = MyCombobox.DropDownItems.Item(MyMinMax(Number, 0, Count - 1)).ToString; // Should this allow combobox.items(0)?

            if (MyCombobox.Name == MyUniverse.MyStaticData.MyUnEnum.LastComboBox)
            {
                if (Temp == MyUniverse.MyStaticData.MyUnEnum.LastUnEnum)
                {
                    if (MyUniverse.MyStaticData.MyUnEnum.LastResults[ItemNumberOffset] != null)
                    {
                        MyUnEnum = MyUniverse.MyStaticData.MyUnEnum.LastResults[ItemNumberOffset];
                        return;
                    }
                }
            }
            else
                MyUniverse.MyStaticData.MyUnEnum.LastResults = new string[21];// get rid of everything

            MyUniverse.MyStaticData.MyUnEnum.LastComboBox = MyCombobox.Name;
            MyUniverse.MyStaticData.MyUnEnum.LastUnEnum = Temp;
            for (I = 0; I <= ItemNumberOffset; I++)
            {
                Temp = Strings.Trim(Temp);
                MyUnEnum = Pop(ref Temp, FD);
                MyUniverse.MyStaticData.MyUnEnum.LastResults[I] = MyUnEnum;
            }
        }

        // ***********************************************************************
        // converts from a number into the cap start/end type
        // This is erroring out, and not reutnr a valid type of data for this
        std::system.drawing::drawing2d.linecap()
            windows

        Drawing2D.LineCap MyCapCode(long Anumber)
        {
            switch (Anumber)
            {
            case 1:
            {                return Drawing2D.LineCap.AnchorMask;            }
            case 2:
            {                return Drawing2D.LineCap.ArrowAnchor;            }
            case 3:
            {                return Drawing2D.LineCap.DiamondAnchor;            }
            case 4:
            {                return Drawing2D.LineCap.Flat;            }
            case 5:
            {                return Drawing2D.LineCap.NoAnchor;            }
            case 6:
            {                return Drawing2D.LineCap.Round;            }
            case 7:
            {                return Drawing2D.LineCap.RoundAnchor;            }
            case 8:
            {                return Drawing2D.LineCap.Square;            }
            case 9:
            {                return Drawing2D.LineCap.SquareAnchor;            }
            case 10:
            {                return Drawing2D.LineCap.Triangle;            }
            default:
            {                return Drawing2D.LineCap.AnchorMask; } // if cant / dont know what it is 
            }
        }

        // ***********************************************************************
        // Returns the number of the first item in this number

        long MyEnumValue(string Whatstring, ToolStripDropDownButton MyComboBox)
        {
            long I;
            long Low, Idex, Jdex, Kdex, ErrorKounter;
            string SearchingFor;
            long Count;
            if (MyUniverse.MyStaticData.MyEnum.LastComboBox == MyComboBox.Name)
            {
                if (MyUniverse.MyStaticData.MyEnum.LastWhatString == Whatstring)
                    return MyUniverse.MyStaticData.MyEnum.Last_Enum;// return shortcut
            }

            Count = MyComboBox.DropDownItems.Count;
            if (Count < 1)
                return 0;
            Low = 0;
            SearchingFor = MyTrim(Whatstring);
            if (Strings.Len(SearchingFor) < 1)
            {
                // Abug(217, "MyEnumValue():" & HighLight(MyComboBox.Name), ":Can not find an empty  string in the list ", 0)
                MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name;
                MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring;
                MyUniverse.MyStaticData.MyEnum.Last_Enum = constantMyErrorCode;
                MyEnumValue = constantMyErrorCode;
                return;
            }

            // Lets try a binary search first
            Kdex = Count - 1;
            Idex = MyMinMax(System.Convert.Tolong(Kdex / (double)2), Low, Kdex);
            Jdex = MyMinMax(System.Convert.Tolong(Idex / (double)2), Low, Kdex);
            ErrorKounter = -(Count + 8); // Try to find it eight times to many
            // Temp = MyComboBox.Items.Item(Idex).ToString 'hack
            // Temp = Trim(Pop(MyComboBox.Items.Item(Idex).ToString, myuniverse.SysGen.constants.constantDelimeters)) 'hack
            I = MyCompared1_a(SearchingFor, Trim(Pop(ref MyComboBox.DropDownItems.Item(Idex).ToString, MyUniverse.SysGen.Constants.ConstantDelimeters)));
            while (I != 0)
            {
                ErrorKounter += 1;
                if (ErrorKounter + 2 > Count)
                {
                    // Not found and searched almost for ever.
                    MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name;
                    MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring;
                    MyUniverse.MyStaticData.MyEnum.Last_Enum = default(Integer);
                    // MyEnumValue = Nothing
                    goto FailedBinarySearch;
                }
                if (I < 0)
                    Idex = MyMinMax(Idex - Jdex, Low, Kdex);
                else
                    Idex = MyMinMax(Idex + Jdex, Low, Kdex);
                Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
                // Temp = MyComboBox.Items.Item(Idex).ToString 'hack
                // Temp = Trim(Pop(MyComboBox.Items.Item(Idex).ToString, myuniverse.SysGen.constants.constantDelimeters)) 'hack
                I = MyCompared1_a(SearchingFor, Trim(Pop(ref MyComboBox.DropDownItems.Item(Idex).ToString, MyUniverse.SysGen.Constants.ConstantDelimeters)));
            }
            MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name;
            MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring;
            MyUniverse.MyStaticData.MyEnum.Last_Enum = Idex;
            MyEnumValue = Idex;
            return;


            // The above should replace the below, but should add an excape incase it's not in the List to avoid a forever loop
        FailedBinarySearch:
            ;
            SearchingFor = MyTrim(Whatstring);
            if (SearchingFor == "" | SearchingFor == " ")
            {
                // Abug(218, "MyEnumValue", 0, 2)
                MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name;
                MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring;
                MyUniverse.MyStaticData.MyEnum.Last_Enum = constantMyErrorCode;
                MyEnumValue = constantMyErrorCode;
                return;
            }
            MyUniverse.MyStaticData.MyEnum.LastComboBox = MyComboBox.Name;
            MyUniverse.MyStaticData.MyEnum.LastWhatString = Whatstring;
            MyUniverse.MyStaticData.MyEnum.Last_Enum = default(Integer);
            MyEnumValue = default(Integer);
        }


        // ***********************************************************************
        // swaps the array (assumed no key
        void MySwap(string MyTable, long[] MyArray, long A, long B) // Swap the two numbers
        {
            long Temp;
            Temp = MyArray[A];
            MyArray[A] = MyArray[B];
            MyArray[B] = Temp;
        }

        // ***********************************************************************
        // swap the two numbers 
        // It looks lik it does not return the swapped values?
        // Why is A & B not by REF ?
        void MySwap(string MyTable, long A, long B) // Swap the two numbers
        {
            long Temp;
            Temp = A;
            A = B;
            B = Temp;
        }



        // Routine  changes places between two  string locations in an MyArray
        void MySwap(string MyTable, string MyArray[], long A, long B) // Swap the two items in the myArray
        {
            string TempA;
            TempA = MyArray[A];
            MyArray[A] = MyArray[B];
            MyArray[B] = TempA;
        }

        // ***********************************************************************
        // Swaps the two places of the keyWord array (Sorting them to keep them in order, should look into an insert sort method)
        void MySwapLanguagekeyWord(string MyTable, string MyArray[], long A, long B)
        {
            string T;
            // MyTrace(176, "SwapLanguagekeyWord", 47 - 32)

            if (A < 0)
                return;
            if (B < 0)
                return;
            if (A > Information.UBound(MyArray))
                return;
            if (B > Information.UBound(MyArray))
                return;
            T = MyArray[A];
            MyArray[A] = MyArray[B];
            MyArray[B] = T;
        }

        void MySwapBytes(string MyTable, byte[] MyArray, long A, long B)
        {
            byte TempA;
            byte TempB;
            // Should have an error message out here. and not swap anything (better yet, test it before it gets here)
            if (MyMinMax(A, 1, Information.UBound(MyArray) - 1) != A)
                return;
            if (MyMinMax(B, 1, Information.UBound(MyArray) - 1) != B)
                return;
            TempB = MyArray[B];
            TempA = MyArray[A];
            MyArray[A] = TempB;
            MyArray[B] = TempA;
        }



        // Routine changes places between two number locations in a number MyArray
        void MySwapN(string MyTable, string MyArray[], long iSAM[], long A, long B)
        {
            long TempA;
            // Dim DebugA, DebugB As String
            // Just to make sure that it is always valid
            if (MyMinMax(A, 1, Information.UBound(iSAM) - 1) != A)
            {
                Abug(221, "Index outside of array 1,", A, Information.UBound(iSAM) - 1);
                return;
            }
            if (MyMinMax(B, 1, Information.UBound(iSAM) - 1) != B)
            {
                Abug(222, "Index outside of array 1,", B, Information.UBound(iSAM) - 1);
                return;
            }
            // DebugA = MyArray(iSAM(A))
            // DebugB = MyArray(iSAM(B))
            TempA = iSAM[A];
            iSAM[A] = iSAM[B];
            iSAM[B] = TempA;
        }



        // Routine changes places between two number locations in a number MyArray
        void MySwapNn(string MyTable, long[] MyArray, long iSAM[], long A, long B)
        {
            long TempA;
            if (MyMinMax(A, 1, Information.UBound(iSAM) - 1) != A)
                return;
            if (MyMinMax(B, 1, Information.UBound(iSAM) - 1) != B)
            {
                MyMsgCtr(1437, "swapn", "1", A.ToString(), Information.UBound(iSAM).ToString(), "", "", "", "", "", "");
                return;
            }
            TempA = iSAM[A];
            iSAM[A] = iSAM[B];
            iSAM[B] = TempA;
        }


        void ReSortSymbolList() // Used only in decompileline
        {
            long I, IndexSymbol;
            for (IndexSymbol = 2; IndexSymbol <= TopOfFile("Symbol"); IndexSymbol++)
            {
                I = IndexSymbol;
                while (Symbol_FileCoded[I] == MyKeyword_2_Byte("/name")) // Moving /name to the top of the list
                {
                    while (Symbol_FileSymbolName[I - 1] == Symbol_FileSymbolName[I]) // A point name is before the symbol name
                    {
                        // Should never get here, if we do its a program bug
                        MySwapSymbolList(IndexSymbol, IndexSymbol + 1);
                        FindingMyBugs(100); // hack Least amount of checking here 'hack 2020 08 04
                        I -= 1;
                    }
                    I -= 1;
                }
                I = IndexSymbol;
                while (Symbol_FileCoded[I] == MyKeyword_2_Byte("/name") & Symbol_FileCoded[I - 1] == MyKeyword_2_Byte("/name") & Symbol_FileSymbolName[I - 1] == Symbol_FileSymbolName[I])
                {
                    MySwapSymbolList(IndexSymbol, IndexSymbol + 1);
                    FindingMyBugs(100); // hack Least amount of checking here 'hack 2020 08 04
                    I -= 1;
                }
            }
        }



        // Routine swaps in all symbol MyArrays two locations
        void MySwapSymbolList(long A, long B) // With one higher ' inserting records in a non-index-file
        {
            MyMakeArraySizesBigger();
            if (InvalidIndex(A, Symbol_FileSymbolName) | InvalidIndex(B, Symbol_FileSymbolName))
                return;
            if (Symbol_TableCoded_String(A) == "/unknown" & Symbol_TableCoded_String(B) == "/unknown")
                // dont bother to swap two invalid        -      
                return;
            MySwapBytes("Symbol", Symbol_FileCoded, A, B);
            MySwap("Symbol", ref Symbol_File_NameOfPoint, A, B);
            MySwap("Symbol", ref Symbol_FileSymbolName, A, B);
            MySwap("Symbol", Symbol_FileX1, A, B);
            MySwap("Symbol", Symbol_FileY1, A, B);
            MySwap("Symbol", Symbol_FileX2_io, A, B);
            MySwap("Symbol", Symbol_FileY2_dt, A, B);
        }



        // ***********************************************************************
        // Routine returns from 'real' world to screen scale
        long ScaledSize(long MyNumber) // single
        {
            LimitScale();
            ScaledSize = System.Convert.Tolong(MyNumber * MyUniverse.SysGen.MyFlowChartScale);
        }

        // ***********************************************************************
        // invalid use point/path/symbol snap
        // ***********************************************************************
        // Move the point to the grid
        long MyLineSnap(long XY)
        {
            return System.Convert.Tolong(XY / (double)MyUniverse.SysGen.Snaps.MySnap) * MyUniverse.SysGen.Snaps.MySnap;
        }

        MyLineStructure MyLineXY(MyPointStructure A, MyPointStructure B)
        {
            MyLineXY = default(MyLineStructure);
            MyLineXY.a.Xx = A.Xx;
            MyLineXY.a.Yy = A.Yy;
            MyLineXY.b.Xx = B.Xx;
            MyLineXY.b.Yy = B.Yy;
        }


        void MyPathSnap(ref MyLineStructure ReturnedXY, MyLineStructure XY) // As MyLineStructure
        {
            XY.a.Named.PathName = XY.a.Named.PathName;
            if (MyUniverse.SysGen.Snaps.MyPointSnap == 0)
            {
                ReturnedXY = XY;
                return;
            }
            ReturnedXY.a.Xx = System.Convert.Tolong(XY.a.Xx / (double)MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap;
            ReturnedXY.a.Yy = System.Convert.Tolong(XY.a.Yy / (double)MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap;
            ReturnedXY.b.Xx = System.Convert.Tolong(XY.b.Xx / (double)MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap;
            ReturnedXY.b.Yy = System.Convert.Tolong(XY.b.Yy / (double)MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap;
        }



        MyPointStructure MyPointSnap(MyPointStructure XY)
        {
            MyPointSnap = default(MyPointStructure);
            XY.Named.Pointname = XY.Named.Pointname; // incase it is a path, or a point get them both, and leave the symb name null
            XY.Named.PathName = XY.Named.PathName;
            MyPointSnap.Xx = System.Convert.Tolong(XY.Xx / (double)MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap;
            MyPointSnap.Yy = System.Convert.Tolong(XY.Yy / (double)MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap;
        }
        MyPointStructure MySymbolSnap(MyPointStructure XY)
        {
            MySymbolSnap = default(MyPointStructure);
            MySymbolSnap.Xx = System.Convert.Tolong(XY.Xx / (double)MyUniverse.SysGen.Snaps.MySymbolSnap) * MyUniverse.SysGen.Snaps.MySymbolSnap;
            MySymbolSnap.Yy = System.Convert.Tolong(XY.Yy / (double)MyUniverse.SysGen.Snaps.MySymbolSnap) * MyUniverse.SysGen.Snaps.MySymbolSnap;
        }

        bool MakePathOrthogonal(long IndexFlowChart) // returns if changed the line
        {
            long DX, DY, IndexFlowChart1;
            MakePathOrthogonal = false; // Didn't change anything
            if (MyOptionTest(14) == false)
                return; // Orthogonal paths
            // Need to make sure this is a path first
            if (FlowChart_TableCode(IndexFlowChart) != "/path")
                return;// this is not a path to beable to change

            // It's check so make this rect Orthogonal 
            // Get the distances between the two points on the line
            DX = MyABS(FlowChart_TableX1(IndexFlowChart) - FlowChart_TableX2(IndexFlowChart));
            DY = MyABS(FlowChart_TableY1(IndexFlowChart) - FlowChart_TableY2(IndexFlowChart));
            if (DX == 0 | DY == 0)
                return; // The X or Y is already stright up/down OR level right/left
            IndexFlowChart1 = InsertFlowChartRecord(NewTopOfFile("FlowChart"), FlowChart_TablePath_Name(IndexFlowChart), "/path", MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), MyPoint2XY(FlowChart_TableX2(IndexFlowChart), FlowChart_TableY2(IndexFlowChart)), FlowChart_Table_DataType(IndexFlowChart));
            MyMakeArraySizesBigger();
            PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart, IndexFlowChart); PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart1, IndexFlowChart1);
            if (DX >= DY)
            {
                DX = FlowChart_TableX1(IndexFlowChart);
                DY = FlowChart_TableY2(IndexFlowChart);
                FlowChart_TableX1(IndexFlowChart1, DX);
                FlowChart_TableY1(IndexFlowChart1, DY);
                FlowChart_TableX2(IndexFlowChart, DX);
                FlowChart_TableY2(IndexFlowChart, DY);
                PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart, IndexFlowChart); PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart1, IndexFlowChart1);
            }
            else
            {
                DX = FlowChart_TableX2(IndexFlowChart);
                DY = FlowChart_TableY1(IndexFlowChart);
                FlowChart_TableX1(IndexFlowChart1, DX);
                FlowChart_TableY1(IndexFlowChart1, DY);
                FlowChart_TableX2(IndexFlowChart, DX);
                FlowChart_TableY2(IndexFlowChart, DY);
                PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart, IndexFlowChart); PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart1, IndexFlowChart1);
            }
        }

        void SetMyLimitScreen(MyPointStructure FromXY)
        {
            if (MyUniverse.MyStaticData.MinXY.Xx > FromXY.Xx)
                MyUniverse.MyStaticData.MinXY.Xx = FromXY.Xx - 1000;
            if (MyUniverse.MyStaticData.MinXY.Yy > FromXY.Yy)
                MyUniverse.MyStaticData.MinXY.Yy = FromXY.Yy - 1000;
            if (MyUniverse.MyStaticData.MaxXY.Xx < FromXY.Xx)
                MyUniverse.MyStaticData.MaxXY.Xx = FromXY.Xx + 1000;
            if (MyUniverse.MyStaticData.MaxXY.Yy < FromXY.Yy)
                MyUniverse.MyStaticData.MaxXY.Yy = FromXY.Yy + 1000;
        }


        MyPointStructure FixSymbolLimits2Screen(MyPointStructure XY1)
        {
            FixSymbolLimits2Screen = XY1;
            // FixSymbolLimits2Screen.Xx = MyMinMax(FixSymbolLimits2Screen.Xx, -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter)
            // FixSymbolLimits2Screen.Yy = MyMinMax(FixSymbolLimits2Screen.Yy, -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter)
            FixSymbolLimits2Screen.Xx = MyMinMax(FixSymbolLimits2Screen.Xx, 0, SymbolScreen.PictureBox1.Width - 2);
            FixSymbolLimits2Screen.Yy = MyMinMax(FixSymbolLimits2Screen.Yy, 0, SymbolScreen.PictureBox1.Height - 2);
            if (FixSymbolLimits2Screen.Xx != XY1.Xx | FixSymbolLimits2Screen.Yy != XY1.Yy)
                Abug(716, "Change to the bounds of screen", MyShowPoint(FixSymbolLimits2Screen), MyShowPoint(XY1));
        }



        // Routine returns from 'real' world to screen scale
        MyPointStructure Copy2ScreenXY(string Where, MyPointStructure FromXY)
        {
            long TempH, TempV;
            Copy2ScreenXY = default(MyPointStructure);
            LimitScale();
            switch (Where.Parent.Name)
            {
            case "FlowChartScreen":
            {
                SetMyLimitScreen(FromXY);
                if (MyOptionTest(23) == true)
                {
                    TempH = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.Xx;
                    TempV = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.Yy;
                }
                else
                {
                    TempH = System.Convert.Tolong((MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx + MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx) * FlowChartScreen.HScrollBar1.Value / (double)FlowChartScreen.HScrollBar1.Maximum);
                    TempV = System.Convert.Tolong((MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy - MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy) * FlowChartScreen.VScrollBar1.Value / (double)FlowChartScreen.VScrollBar1.Maximum);
                }
                Copy2ScreenXY.Xx = System.Convert.Tolong((FromXY.Xx - TempH) * MyUniverse.SysGen.MyFlowChartScale);
                Copy2ScreenXY.Yy = System.Convert.Tolong((FromXY.Yy - TempV) * MyUniverse.SysGen.MyFlowChartScale);
                break;
            }

            case "SymbolScreen":
            {
                // hack debugging

                Copy2ScreenXY.Xx = System.Convert.Tolong((FromXY.Xx + MyUniverse.SysGen.Constants.constantSymbolCenter) * MyUniverse.SysGen.MySymbolScale);
                Copy2ScreenXY.Yy = System.Convert.Tolong((FromXY.Yy + MyUniverse.SysGen.Constants.constantSymbolCenter) * MyUniverse.SysGen.MySymbolScale);

                Copy2ScreenXY = FixSymbolLimits2Screen(Copy2ScreenXY);


                // I think this should be 0?
                if (Copy2ScreenXY.Xx < 0)
                    Abug(224, "2Screen " + "The X1 is under of the symbol graphics area " + " From " + MyShowPoint(FromXY) + " to " + MyShowPoint(Copy2ScreenXY) + "Sized for Symbol" + MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter)), "Sized for image " + MyShowPoint(ZeroZero), "");
                // I think this should be picture width?
                if (Copy2ScreenXY.Xx > SymbolScreen.PictureBox1.Width)
                    Abug(225, "2Screen " + "The is X over the symbol graphics area " + " From " + MyShowPoint(FromXY) + " to " + MyShowPoint(Copy2ScreenXY) + "Sized for Symbol" + MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter)), "Sized for image " + MyShowPoint(MyPoint1XY(SymbolScreen.PictureBox1.Width, SymbolScreen.PictureBox1.Height)), "");
                // I think this should be 0?
                if (Copy2ScreenXY.Yy < 0)
                    Abug(226, "2Screen " + "The Y is under of the symbol graphics area " + " From " + MyShowPoint(FromXY) + " to " + MyShowPoint(Copy2ScreenXY) + "Sized for Symbol" + MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter)), "Sized for image " + MyShowPoint(MyPoint1XY(SymbolScreen.PictureBox1.Width, SymbolScreen.PictureBox1.Height)), "");
                // I think this should be picture height?
                if (Copy2ScreenXY.Yy > SymbolScreen.PictureBox1.Height)
                    Abug(227, "2Screen " + "The Y is over the symbol graphics area " + " From " + MyShowPoint(FromXY) + " to " + MyShowPoint(Copy2ScreenXY) + "Sized for Symbol" + MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter)), "Sized for image " + MyShowPoint(MyPoint1XY(SymbolScreen.PictureBox1.Width, SymbolScreen.PictureBox1.Height)), "");
                break;
            }

            default:
            {
                Copy2ScreenXY.Xx = -1;
                Copy2ScreenXY.Yy = -1;
                Abug(228, " unable to convert from world to screen because this is not a graphics screen ", Where.Parent.Name, Where.Name);
                break;
            }
            }
        }


        // Routine copies from screen scale to 'real' world scale

        // todo rename the X in the x( routine(s) and remove the debugtestthis  string parametrer
        MyPointStructure Copy2WorldXY(string CodeString, string Where, MyPointStructure FromXY)
        {
            float TempH, TempV;
            Copy2WorldXY = default(MyPointStructure);
            LimitScale();
            switch (Where.Parent.Name)
            {
            case "FlowChartScreen":
            {
                // todo need to hide scroll bars if the hand option is used.
                if (MyOptionTest(23) == true)
                {
                    TempH = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.Xx;
                    TempV = MyUniverse.MyMouseAndDrawing.MyScrenZeroZero.Yy;
                }
                else
                {
                    TempH = System.Convert.ToSingle((MyUniverse.MyMouseAndDrawing.MyScreen.b.Xx + MyUniverse.MyMouseAndDrawing.MyScreen.a.Xx) * FlowChartScreen.HScrollBar1.Value / (double)FlowChartScreen.HScrollBar1.Maximum);
                    TempV = System.Convert.ToSingle((MyUniverse.MyMouseAndDrawing.MyScreen.b.Yy - MyUniverse.MyMouseAndDrawing.MyScreen.a.Yy) * FlowChartScreen.VScrollBar1.Value / (double)FlowChartScreen.VScrollBar1.Maximum);
                }

                switch (CodeString)
                {
                    case "/use" // symbolgrid snap
                        :
                    {
                        MyUniverse.Area.MyWorldXY.a = MySymbolSnap(MyUniverse.Area.MyWorldXY.a);
                        Copy2WorldXY = MySymbolSnap(MyPoint1XY(FromXY.Xx + TempH, FromXY.Yy + TempV));
                        break;
                    }

                    case "/constant" // Point / Path grid snap
                        :
                    {
                        MyUniverse.Area.MyWorldXY.a = MyPointSnap(MyUniverse.Area.MyWorldXY.a);
                        Copy2WorldXY = MySymbolSnap(MyPoint1XY(FromXY.Xx + TempH, FromXY.Yy + TempV));
                        break;
                    }

                    case "/path" // point/path grid snap
                        :
                    {
                        MyPathSnap(ref MyUniverse.Area.MyWorldXY, MyUniverse.Area.MyWorldXY);
                        Copy2WorldXY = MySymbolSnap(MyPoint1XY(FromXY.Xx + TempH, FromXY.Yy + TempV));
                        break;
                    }

                    case "/":
                    case "":
                    {
                        Copy2WorldXY.Xx = System.Convert.Tolong((FromXY.Xx / (double)MyUniverse.SysGen.MyFlowChartScale) + TempH);
                        Copy2WorldXY.Yy = System.Convert.Tolong((FromXY.Yy / (double)MyUniverse.SysGen.MyFlowChartScale) + TempV);
                        break;
                    }

                    default:
                    {
                        Abug(231, "how do I know if this is a symbol or a path?", CodeString, "unable to snap to grid");
                        Copy2WorldXY.Xx = System.Convert.Tolong((FromXY.Xx / (double)MyUniverse.SysGen.MyFlowChartScale) + TempH);
                        Copy2WorldXY.Yy = System.Convert.Tolong((FromXY.Yy / (double)MyUniverse.SysGen.MyFlowChartScale) + TempV);
                        break;
                    }
                }

                break;
            }

            case "SymbolScreen":
            {
                switch (CodeString)
                {
                case "/point":
                {
                    Copy2WorldXY.Xx = FromXY.Xx / (double)MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.constantSymbolCenter;
                    Copy2WorldXY.Yy = FromXY.Yy / (double)MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.constantSymbolCenter;
                    Copy2WorldXY = MyPointSnap(Copy2WorldXY);
                    break;
                }

                case "/line" // no snapping of lines. 
                    :
                {
                    Copy2WorldXY.Xx = FromXY.Xx / (double)MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.constantSymbolCenter;
                    Copy2WorldXY.Yy = FromXY.Yy / (double)MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.constantSymbolCenter;
                    break;
                }

                case "/":
                case "":
                {
                    Copy2WorldXY.Xx = System.Convert.Tolong(System.Convert.ToSingle(FromXY.Xx - MyUniverse.SysGen.Constants.constantSymbolCenter) * MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.constantSymbolCenter);
                    Copy2WorldXY.Yy = System.Convert.Tolong(System.Convert.ToSingle(FromXY.Yy - MyUniverse.SysGen.Constants.constantSymbolCenter) * MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.constantSymbolCenter);
                    break;
                }

                default:
                {
                    Abug(233, "Can not use a ", CodeString.ToString(), " in the  " + Where.Parent.Name);
                    Copy2WorldXY.Xx = System.Convert.Tolong(System.Convert.ToSingle(FromXY.Xx - MyUniverse.SysGen.Constants.constantSymbolCenter) * MyUniverse.SysGen.MySymbolScale + MyUniverse.SysGen.Constants.constantSymbolCenter);
                    Copy2WorldXY.Yy = System.Convert.Tolong(System.Convert.ToSingle(FromXY.Yy - MyUniverse.SysGen.Constants.constantSymbolCenter) * MyUniverse.SysGen.MySymbolScale + MyUniverse.SysGen.Constants.constantSymbolCenter);
                    break;
                }
                } // /point/line/
                  // todo This is for debugging only.
                if (Copy2WorldXY.Xx < -MyUniverse.SysGen.Constants.constantSymbolCenter)
                {
                    Abug(234, "The X is under the symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY) + " : " + MyShowPoint(MyPoint1XY(0, 2 * MyUniverse.SysGen.Constants.constantSymbolCenter)));
                    Copy2WorldXY.Xx = -MyUniverse.SysGen.Constants.constantSymbolCenter + 10;
                }
                if (Copy2WorldXY.Xx > MyUniverse.SysGen.Constants.constantSymbolCenter)
                {
                    Abug(235, "The X is over the symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY) + MyShowPoint(MyPoint1XY(0, 2 * MyUniverse.SysGen.Constants.constantSymbolCenter)));
                    Copy2WorldXY.Xx = MyUniverse.SysGen.Constants.constantSymbolCenter - 10;
                }
                if (Copy2WorldXY.Yy < -MyUniverse.SysGen.Constants.constantSymbolCenter)
                {
                    Abug(236, "The Y is under the symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY));
                    Copy2WorldXY.Yy = -MyUniverse.SysGen.Constants.constantSymbolCenter + 10;
                }
                if (Copy2WorldXY.Yy > MyUniverse.SysGen.Constants.constantSymbolCenter)
                {
                    Abug(237, "The Y is over symbol drawing area", MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY));
                    Copy2WorldXY.Yy = MyUniverse.SysGen.Constants.constantSymbolCenter - 10;
                }

                break;
            }

            default:
            {
                Abug(238, "Trying to scale on something that is not a FlowChart or Symbol", Where.Parent.Name, "");
                Copy2WorldXY.Xx = -1;
                Copy2WorldXY.Yy = -1;
                Abug(239, "Myscale the program does Not understand trying to convert the XY on " + Where.Parent.Name, "", "");
                break;
            }
            }
        }


        // ******************************************************************************
        // This is where all file openings take place
        // ReadOrWrite is a  string of "read" for input of a FlowChart
        // "write" for output of a FlowChart
        // "decompile" for input from source code
        // "compile" for output to source code
        // All of them open a dialog box to get the file name (SaveAs, there is no save (yet))

        // Routine Returns the file name opened. (Does not change the input file name
        string XOpenFile(string ReadOrWrite, string MyTitle) // , My_FileName As String) As  string 'Opens the standard selection box'2020 08 10
        {
            string My_FileName;
            My_FileName = null;
            // OpenFileDialog 
            switch (Strings.LCase(ReadOrWrite))
            {
            case "read":
            {
                OpenFileDialog openFileDialog1 = new OpenFileDialog();
                // If MyFileName = Nothing Then 2020 08 10
                My_FileName = DrillDown_FileName + "." + MyUniverse.ProgramOptions.C_L_Extention;
                openFileDialog1.Title = MyTitle;
                openFileDialog1.FileName = My_FileName;
                openFileDialog1.InitialDirectory = "c:    \\";
                openFileDialog1.Filter = "Software Schematic files (*.FlowChart)|*.FlowChart|Symbol files (*.Symbol)|*.Symbol|TextFile (*.txt)|*.txt|All Files (*.*)|*.*";
                openFileDialog1.RestoreDirectory = true;
                openFileDialog1.AddExtension = true;
                openFileDialog1.DefaultExt = ".FlowChart";
                openFileDialog1.Multiselect = false;
                if (openFileDialog1.ShowDialog() == DialogResult.OK)
                    My_FileName = openFileDialog1.FileName;
                else
                    My_FileName = null;
                XOpenFile = My_FileName;
                openFileDialog1.Dispose();
                break;
            }

            case "decompile":
            {
                OpenFileDialog openFileDialog1 = new OpenFileDialog();
                // If My_FileName = Nothing Then 
                My_FileName = DrillDown_FileName + "." + MyUniverse.ProgramOptions.C_L_Extention;
                openFileDialog1.Title = MyTitle;
                openFileDialog1.FileName = My_FileName;
                openFileDialog1.InitialDirectory = "c:\\\\";
                openFileDialog1.Filter = ComputerFileNamesAre();
                openFileDialog1.RestoreDirectory = true;
                openFileDialog1.AddExtension = true;
                openFileDialog1.DefaultExt = ComputerFileNamesAre(); // "*." & MyUniverse.ProgramOptions.C_L_Extention ' should be an option in the imort file 
                openFileDialog1.Multiselect = false;
                if (openFileDialog1.ShowDialog() == DialogResult.OK)
                    My_FileName = openFileDialog1.FileName;
                else
                    My_FileName = null;
                XOpenFile = My_FileName;
                openFileDialog1.Dispose();
                break;
            }

            case "write":
            {
                SaveFileDialog SaveFileDialog1 = new SaveFileDialog();
                if (My_FileName == null)
                    My_FileName = "Start" + "." + MyUniverse.ProgramOptions.C_L_Extention;
                SaveFileDialog1.Title = MyTitle;
                SaveFileDialog1.FileName = My_FileName;
                SaveFileDialog1.InitialDirectory = "c:\\";
                SaveFileDialog1.Filter = "Software Schematic files (*.FlowChart)|*.FlowChart|Symbol files (*.Symbol)|*.Symbol|TextFile (*.txt)|*.txt|All Files (*.*)|*.*";
                SaveFileDialog1.RestoreDirectory = true;
                SaveFileDialog1.AddExtension = true;
                SaveFileDialog1.DefaultExt = ".FlowChart";
                SaveFileDialog1.CheckFileExists = false;
                SaveFileDialog1.CheckPathExists = true;
                if (SaveFileDialog1.ShowDialog() == DialogResult.OK)
                    My_FileName = SaveFileDialog1.FileName;
                else
                    My_FileName = null;
                XOpenFile = My_FileName;
                SaveFileDialog1.Dispose();
                break;
            }

            case "compile":
            {
                SaveFileDialog SaveFileDialog1 = new SaveFileDialog();
                if (My_FileName == null)
                    My_FileName = DrillDown_FileName + "." + MyUniverse.ProgramOptions.C_L_Extention;
                SaveFileDialog1.Title = MyTitle;
                SaveFileDialog1.FileName = My_FileName;
                SaveFileDialog1.InitialDirectory = "c:\\";

                SaveFileDialog1.Filter = "Source files (*.Src)|*.txt|Source files (*.Source)|*.Source|TextFile (*.txt)|*.txt|All Files (*.*)|*.*";

                SaveFileDialog1.RestoreDirectory = true;
                SaveFileDialog1.AddExtension = true;
                SaveFileDialog1.DefaultExt = ".Source";
                SaveFileDialog1.CheckFileExists = false;
                SaveFileDialog1.CheckPathExists = true;
                if (SaveFileDialog1.ShowDialog() == DialogResult.OK)
                    My_FileName = SaveFileDialog1.FileName;
                else
                    My_FileName = null;
                XOpenFile = My_FileName;
                SaveFileDialog1.Dispose();
                break;
            }

            default:
            {
                XOpenFile = null;
                break;
            }
            }
        }

        Point ConvertPoint2MyPointStruct(MyPointStructure xy)
        {
            ConvertPoint2MyPointStruct.X = xy.Xx;
            ConvertPoint2MyPointStruct.Y = xy.Yy;
        }
        byte[] ConvertString2Bytes(string A)
        {
            long i, k;
            byte[] Temp = new byte[Strings.Len(A) * 2 + 6 + 1]; // ute-16
            byte[] Temp2 = new byte[Strings.Len(A) * 2 + 6 + 1]; // ute-16 variable character length
            Temp = System.Text.Encoding.Unicode.GetBytes(A);

            k = 0;
            for (i = 0; i <= Information.UBound(Temp); i++)
            {
                if (Temp[i] == 0)
                {
                }
                else
                {
                    Temp2[k] = Temp[i];
                    k += 1;
                }
            }
            return Temp2;
        }


        // Routine This will write out one line of text to the file stream I/O
        void MyWriteLine1(StreamWriter Writer, string OutPutString)
        {
            // todo make sure that there is no " and no crlf before outputing it, or else tell about it
            if (Strings.InStr(OutPutString, Constants.vbCrLf) != 0)
            {
                if (Strings.InStr(OutPutString, Constants.vbCrLf + "/") == 0)
                    Writer.WriteLine(RemoveTheseLetters(OutPutString, Constants.vbCrLf));
                else
                    Writer.WriteLine(OutPutString);
            }
            else
                Writer.WriteLine(OutPutString);
        }


        string NoComments(string MyCodeLine)
        {
            string TempComment;
            NoComments = MyCodeLine;
            TempComment = MyUniverse.ProgramOptions.C_L_Comment;
            if (Strings.InStr(MyCodeLine, TempComment) > 0)
            {
                NoComments = Strings.Mid(MyCodeLine, 1, Strings.InStr(MyCodeLine, TempComment) - 1);
                return;
            }
        }


        // *******************************************************************
        // This is parsing the inport file from the format /keyword=options....
        string TrimEqual(string InputString)
        {
            if (Strings.Left(InputString, 1) == "=")
                TrimEqual = Strings.Trim(Strings.Mid(InputString, 2, Strings.Len(InputString)));
            else
                TrimEqual = InputString;
        }


        string XTrim(string StringtoTrim)
        {
            XTrim = Strings.Trim(StringtoTrim);
            while (Strings.Left(XTrim, 1) == FD)
                XTrim = Strings.Mid(XTrim, 2, Strings.Len(XTrim));
        }


        // ***************************************************************
        // Routine This will trim a  string from all spaces, carrage returns, and Linefeeds
        // This needs to be changed so that we find where the trim is, and then move the  string only once, becuse this way is VERY slow.
        string My2Trim(string StringToTrim, string what)
        {
            My2Trim = StringToTrim;
            while (Strings.Left(My2Trim, Strings.Len(what)) == what)
                My2Trim = Strings.Mid(My2Trim, Strings.Len(what) + 1, Strings.Len(My2Trim));

            while (Strings.Right(My2Trim, Strings.Len(what)) == what)
                My2Trim = Strings.Mid(My2Trim, 1, Strings.Len(My2Trim) - Strings.Len(what));
        }


        string MyTrim(string StringToTrim)
        {
            MyTrim = Strings.Trim(StringToTrim);
            MyTrim = My2Trim(MyTrim, Constants.vbCrLf);
            MyTrim = My2Trim(MyTrim, Constants.vbLf);
            MyTrim = My2Trim(MyTrim, Constants.vbCr);
        }


        // Routine This writes out all of the data in the MyArrays to a file (Has error, not able to create a new file yet)

        // todo needs to redo this and all of the MyShowFlowchart(), MyShowSymbol() and so on so that it ONLY returns the export (Which will then appear everwhere else yI need to show a record, (and not all of the internal junk)
        void Export(string OutputFileName)
        {
            string OutPutLine;
            long I, IndexFlowChart, IndexiSAM, IndexSymbol, IndexNamed;
            if (FileSystem.Dir(OutputFileName) == "")
            {
                using (System.IO.StreamWriter Writer = System.IO.File.CreateText(OutputFileName))
                {
                }
            }
            else
            {
                // System.IO.File.Create(OutputFileName)
                FileSystem.Kill(OutputFileName);
                using (System.IO.StreamWriter Writer = System.IO.File.CreateText(OutputFileName))
                {
                }
            }



            if (MyOptionTest(22) == true)
            {
                for (IndexFlowChart = Information.LBound(Language_KeyWord) + 1; IndexFlowChart <= Information.UBound(Language_KeyWord); IndexFlowChart++)
                    ReSortLanguagekeyWord("LanguagekeyWord", ref Language_KeyWord, IndexFlowChart);
                for (IndexFlowChart = Information.LBound(Language_Function) + 1; IndexFlowChart <= Information.UBound(Language_Function); IndexFlowChart++)
                    ReSortLanguagekeyWord("LanguageFunction", ref Language_Function, IndexFlowChart);
                for (IndexFlowChart = Information.LBound(Language_Operator) + 1; IndexFlowChart <= Information.UBound(Language_Operator); IndexFlowChart++)
                    ReSortLanguagekeyWord("LanguageOperator", ref Language_Operator, IndexFlowChart);
            }

            // Make sure everthing is in sorted order, cause Ima putting it out in sorted order, so it will be easier to re-input (except for FlowChart_Table...)

            SortColors();
            SortDataType();
            SortNamed();
            SortFlowChart();

            // Now open it for output
            // Using MyWriter As System.IO.StreamWriter = System.IO.File.OpenText(OutputFileName)
            using (StreamWriter MyWriter = new StreamWriter(OutputFileName))
            {
                // MyWriter = FreeFile()
                // FileOpen(MyWriter, OutputFileName, OpenMode.Output, OpenAccess.Write, OpenShare.Default, -1)


                if (MyOptionTest(22) == true)
                {
                    DisplayMyStatus("Exporting Language Key Words");
                    MyWriteLine1(MyWriter, "/Ignore= " + formatColor);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatDatatype);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatSymbolName);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatPoint);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatLine);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatNameOfFile);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatLanguage);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatStroke);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatNotes);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatOrder);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatVersion);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatAuthor);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatOpcode);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatPath);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatUse);
                    MyWriteLine1(MyWriter, "/Ignore= " + formatConstant);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatMacroText);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatOption);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatError);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatDelete);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatThisCode);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatLanguage_KeyWord);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatLanguage_operator);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatLanguage_Function);
                    MyWriteLine1(MyWriter, "/Ignore= " + FormatSintaxKeyWord);
                }

                // Write out all of the options that are turned OFF
                OutPutLine = "/Language=" + MyUniverse.ProgramOptions.C_L_LanguageClassName;
                OutPutLine += Constants.vbCrLf + "/C_L_DialectName=" + MyUniverse.ProgramOptions.C_L_DialectName;
                OutPutLine += Constants.vbCrLf + "/C_L_Case=" + MyUniverse.ProgramOptions.C_L_Case;
                OutPutLine += Constants.vbCrLf + "/C_L_Comment= " + MyUniverse.ProgramOptions.C_L_Comment;
                OutPutLine += Constants.vbCrLf + "/C_L_Extention=" + MyUniverse.ProgramOptions.C_L_Extention;
                OutPutLine += Constants.vbCrLf + "/C_L_MultiLine=" + MyUniverse.ProgramOptions.C_L_MultiLine;
                OutPutLine += Constants.vbCrLf + "/C_L_Process=" + MyUniverse.ProgramOptions.C_L_Process;
                OutPutLine += Constants.vbCrLf + "/C_L_VarChars=" + MyUniverse.ProgramOptions.C_L_VarChars;

                MyWriteLine1(MyWriter, OutPutLine);

                if (MyOptionTest(22) == true)
                {
                    for (IndexFlowChart = 1; IndexFlowChart <= 998 + 1; IndexFlowChart++)
                    {
                        if (IsBitSet(IndexFlowChart) == true)
                        {
                        }
                        else
                            MyWriteLine1(MyWriter, "/Option=" + IndexFlowChart + FD + "off");
                    }

                    // write out all of the message options options that are turned off (Escape on the message box)
                    for (IndexFlowChart = 1000; IndexFlowChart <= 10000 - 1; IndexFlowChart++)
                    {
                        if (IsBitSet(IndexFlowChart))
                        {
                        }
                        else
                            MyWriteLine1(MyWriter, "/Option=" + IndexFlowChart + FD + "off");
                    }

                    // Write out all of the key words
                    // TempFormat = FormatLanguage_KeyWord
                    for (IndexFlowChart = Information.LBound(Language_KeyWord); IndexFlowChart <= Information.UBound(Language_KeyWord); IndexFlowChart++)
                    {
                        if (Language_KeyWord[IndexFlowChart] != "" & Strings.Left(Language_KeyWord[IndexFlowChart], Strings.Len(Language_KeyWord[IndexFlowChart])) != MyConstantIgnoreFunctionOperatorkeyWord)
                        {
                            OutPutLine = MyShowkeyWord("/keyword", Language_KeyWord[IndexFlowChart]);
                            MyWriteLine1(MyWriter, OutPutLine);
                        }
                    }

                    // TempFormat = FormatLanguage_operator
                    for (IndexFlowChart = Information.LBound(Language_Operator); IndexFlowChart <= Information.UBound(Language_Operator); IndexFlowChart++)
                    {
                        if (Language_Operator[IndexFlowChart] != "")
                        {
                            OutPutLine = MyShowkeyWord("/operator", Language_Operator[IndexFlowChart]);
                            MyWriteLine1(MyWriter, OutPutLine);
                        }
                    }

                    // TempFormat = FormatLanguage_Function
                    for (IndexFlowChart = Information.LBound(Language_Function); IndexFlowChart <= Information.UBound(Language_Function); IndexFlowChart++)
                    {
                        if (Language_Function[IndexFlowChart] != "")
                        {
                            OutPutLine = MyShowkeyWord("/Function", Language_Function[IndexFlowChart]);
                            MyWriteLine1(MyWriter, OutPutLine);
                        }
                    }

                    // Write out all of the color information (Including all of those that are not used here
                    DisplayMyStatus("Exporting Colors");
                    // TempFormat = formatColor
                    for (IndexiSAM = 1; IndexiSAM <= TopOfFile("Color") - 1; IndexiSAM++)
                    {
                        I = Color_Name_iSAM[IndexiSAM];
                        OutPutLine = MyShowColor(I);
                        MyWriteLine1(MyWriter, OutPutLine);
                    }
                }





                DisplayMyStatus("Exporting Data Types");
                // TempFormat = formatDatatype
                // datatypes are not getting sorted before export

                for (IndexiSAM = 1; IndexiSAM <= TopOfFile("DataType"); IndexiSAM++)
                {
                    I = DataType_Name_iSAM[IndexiSAM];
                    OutPutLine = MyShowDataTable(I);
                    MyWriteLine1(MyWriter, OutPutLine);
                }
                OutPutLine = null;


                // We have to output it in the order of the file.
                DisplayMyStatus("Exporting Symbols");
                FindingMyBugs(10); // hack Least amount of checking here 'hack
                for (IndexNamed = 1; IndexNamed <= TopOfFile("Named"); IndexNamed++)
                {
                    IndexSymbol = GetSelfCorrectingIndexes(Named_TableSymbolName(IndexNamed));
                    OutPutLine = MyShowSymbolRecords(IndexSymbol);
                    MyWriteLine1(MyWriter, OutPutLine);
                }


                DisplayMyStatus("Exporting FlowChart Details");

                // todo need to change all of this to use myshowFlowChart()

                for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
                {
                    I = FlowChart_iSAM_Name[IndexFlowChart];
                    switch (Strings.LCase(FlowChart_TableCode(I)))
                    {
                    case "/use":
                    {
                        // Error here X3 should never be Null (-1)
                        DisplayMyStatus("Exporting Call " + FlowChart_TableSymbol_Name(I));
                        OutPutLine = MyShowFlowChartRecord(I) + Constants.vbCrLf + "/ignore=" + formatUse;
                        MyWriteLine1(MyWriter, OutPutLine);
                        break;
                    }

                    case "/path":
                    {
                        DisplayMyStatus("Exporting Path " + FlowChart_TablePathName(I));
                        OutPutLine = MyShowPath(I);
                        // Removed                             DisplayMyStatus(FlowChart_TableCompiledMacroCodeText(I))

                        // OutPutLine &= ", \\ i =" & PrintAbleNull( i ) ' print out but ignored on input.
                        // OutPutLine &= ", \\linkd=" & PrintAbleNull(FlowChart_TableLinks( i )) ' print out but ignored on input.
                        // TempFormat = formatPath
                        MyWriteLine1(MyWriter, OutPutLine);
                        break;
                    }

                    case "/constant":
                    {
                        OutPutLine = Constants.vbCrLf + "/constant" + "=";
                        OutPutLine += FD + PrintAbleNull(FindInSymbolList(ref FlowChart_Tableother_Name(I)));
                        OutPutLine += FD + FlowChart_TableX1(I);
                        OutPutLine += FD + FlowChart_TableY1(I);
                        OutPutLine += FD + FlowChart_Table_DataType(I);
                        // TempFormat = formatConstant
                        MyWriteLine1(MyWriter, OutPutLine);
                        break;
                    }

                    case "/delete":
                    {
                        if (MyOptionTest(22) == true)
                        {
                            OutPutLine = Constants.vbCrLf + "/delete" + " = ";
                            OutPutLine += FD + PrintAbleNull(FindInSymbolList(ref FlowChart_Tableother_Name(I)));
                            OutPutLine += FD + FlowChart_TableX1(I);
                            OutPutLine += FD + FlowChart_TableY1(I);
                            OutPutLine += FD + FlowChart_TableX2(I);
                            OutPutLine += FD + FlowChart_TableY2(I);
                            OutPutLine += FD + PrintAbleNull(FlowChart_Table_DataType(I));
                            // OutPutLine &= ", \\ i =" & PrintAbleNull( i ) ' print out but ignored on input.
                            // OutPutLine &= ", \\linkd=" & PrintAbleNull(FlowChart_TableLinks( i )) ' print out but ignored on input.
                            // TempFormat = FormatDelete
                            MyWriteLine1(MyWriter, OutPutLine);
                        }

                        break;
                    }

                    case "/error":
                    {
                        if (MyOptionTest(22) == true)
                        {
                            // TempFormat = FormatError
                            OutPutLine = Constants.vbCrLf + "/error" + " = " + FlowChart_TableCode(I);
                            OutPutLine += FD + PrintAbleNull(FindInSymbolList(ref FlowChart_Tableother_Name(I)));
                            OutPutLine += FD + FlowChart_TableX1(I);
                            OutPutLine += FD + FlowChart_TableY1(I);
                            OutPutLine += FD + FlowChart_TableX2(I);
                            OutPutLine += FD + FlowChart_TableY2(I);
                            OutPutLine += FD + FlowChart_Table_DataType(I); // datatype is not required (ignored) on Import and should be '_' Null
                                                                            // OutPutLine &= ", \\ i =" & PrintAbleNull( i ) ' print out but ignored on input.
                                                                            // OutPutLine &= ", \\linkd=" & PrintAbleNull(FlowChart_TableLinks( i )) ' print out but ignored on input.
                                                                            // TempFormat = FormatError
                            MyWriteLine1(MyWriter, OutPutLine);
                        }

                        break;
                    }

                    default:
                    {
                        if (MyOptionTest(22) == true)
                        {
                            OutPutLine = Constants.vbCrLf + "/Error=Export FlowChart unknown /";
                            OutPutLine += FlowChart_TableCode(I);
                            OutPutLine += ",\\Code= " + FlowChart_TableCode(I);
                            OutPutLine += ",\\Named= " + FindInSymbolList(ref FlowChart_TableOther_Name(I));
                            OutPutLine += ",\\Number= " + FlowChart_TablePathName(I);
                            OutPutLine += ",\\X1 = " + FlowChart_TableX1(I);
                            OutPutLine += ",\\Y1 = " + FlowChart_TableY1(I);
                            OutPutLine += ",\\X2 = " + FlowChart_TableX2(I);
                            OutPutLine += ",\\Y2 = " + FlowChart_TableY2(I);
                            OutPutLine += ",\\DataType = " + PrintAbleNull(FlowChart_Table_DataType(I));
                            OutPutLine += ",\\ i  =" + PrintAbleNull(I.ToString()); // print out but ignored on input.
                                                                                    // Removed                             OutPutLine &= ",\\linkd =" & PrintAbleNull(FlowChart_TableCompiledMacroCodeText(I)) ' print out but ignored on input.
                            MyWriteLine1(MyWriter, OutPutLine);
                        }

                        break;
                    }
                    }
                }
                MyWriter.Close(); // FileClose(MyWriter)
            }
            // End Using 'writer1
            ShowAllForms(ShowScreen1, HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1);
            DisplayMyStatus("Export Finished.");
        }

        void ImportDataTypes(string Key_line, long LineNumber)
        {
            long IndexDataType;
            string Inputline;
            string DataTypeName;
            string LostColorName;
            long LostColorIndex;
            Inputline = TrimEqual(Key_line);
            DataTypeName = MyTrim(Pop(ref Inputline, Constants.vbLf + Constants.vbCr + FD & ",=/\\" + Constants.vbCrLf));

                if (PrintAbleNull(DataTypeName) == "_")
                    // MyMsgCtr(1413, "ImportDataTypes", DataTypeName, "15", "", "", "", "", "", "", "")
                    return;
            // CheckForAnySortNeeded("", 205)
            DataType_FileColorIndex[NewTopOfFile("DataType")] = FindColor("Black"); // 20200628'to fool FindingMyBugs for now
            IndexDataType = FindIndexIniSAMTable("DataType", "add", ref DataType_FileName, ref DataType_Name_iSAM, DataTypeName);
            // ****** incase we added then it is out of order
            // ShowSorts("DataType", SortDataType())
            // CheckForAnySortNeeded("", 206)
            // IndexDataType = MyMinMax(TopOfFile("DataType"), IndexDataType, TopOfFile("DataType"))
            // *******
            // DataType_TableName(Index) = Pop(KeyLine)
            DataType_TableNumberOfBytes(IndexDataType, PopValue(ref Inputline));
            LostColorName = Pop(ref Inputline, MyUniverse.SysGen.Constants.ConstantDelimeters);
            LostColorName = MyTrim(LostColorName);
            LostColorIndex = FindColor(LostColorName);
            if (LostColorIndex == constantMyErrorCode)
            {
                Abug(241, "Failed finding the color " + LostColorName, " For Datatype " + DataTypeName, "");
                ShowSorts("color", SortColors());
            }
            DataType_TableColorIndex(IndexDataType, FindColor(LostColorName));
            if (DataType_TableColorIndex(IndexDataType) < 1)
                DataType_TableColorIndex(IndexDataType, FindColor("RED"));
            if (DataType_TableColorIndex(IndexDataType) == constantMyErrorCode)
            {
                FindingMyBugs(10); // hack Least amount of checking here
                // MyMsgCtr(1048, "ImportDataTypes", LostColorName, DataType_TableName(IndexDataType), IndexDataType.ToString, LineNumber.ToString, MyUniverse.ProgramOptions.SelectedColor, "", "", "", "")
                DataType_TableColorIndex(IndexDataType, FindColor(MyUniverse.ProgramOptions.SelectedColor));
            }
            DataType_TableWidth(IndexDataType, System.Convert.ToByte(MyABS(PopValue(ref Inputline))));

            DataType_TableDescribtion(IndexDataType, Pop(ref Inputline, FD + Constants.vbCr + Constants.vbLf + Constants.vbCrLf));
            // CheckForAnySortNeeded("", 207) 'hack
            ShowSorts("DataType", MyReSort("DataType", ref DataType_FileName, ref DataType_Name_iSAM, IndexDataType)); // 03/12/19 Only resort the top item
            // FindingMyBugs(10) 'hack Least amount of checking here 'hack
            SortDataType();
            // FindingMyBugs(10) 'hack Least amount of checking here 'hack
            CheckForAnySortNeeded("", 208); // hack
            MyMakeArraySizesBigger();
            // FindingMyBugs(10) 'hack Least amount of checking here 'hack
            SymbolScreen.ToolStripDropDownDataType.DropDownItems.Add(DataType_TableName(IndexDataType));
        }


        void SetOptions(string ImportLine)
        {
            string X0, X1, X2, X3, X4, x5; // DUMP FILE NAMES
            long I, I1, I2, I3;
            X0 = ImportLine;
            X1 = Pop(ref X0, FD); // What
            switch (Strings.LCase(X1))                    // format /language=(name of language) then all of the options
            {
                case "points" // Location of the points (first to last point) 1-121??
                    :
                {
                    // The first two points are the CameFromLine and goto (1 and 2)
                    I1 = MyMinMax(My_INT(Pop(ref X0, FD)), 0, Information.UBound(MyUniverse.MySymbolPoints));
                    I2 = MyMinMax(My_INT(Pop(ref X0, FD)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter);
                    I3 = MyMinMax(My_INT(Pop(ref X0, FD)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter);
                    MyUniverse.MySymbolPoints[I1].X = I2;
                    MyUniverse.MySymbolPoints[I1].Y = I3;
                    break;
                }

                case "text" // Location of the options to display 
                    :
                {
                    // The first two points are the CameFromLine and goto (1 and 2)
                    I1 = MyMinMax(My_INT(Pop(ref X0, FD)), 0, Information.UBound(MyUniverse.OptionDisplay));
                    I2 = MyMinMax(My_INT(Pop(ref X0, FD)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter);
                    I3 = MyMinMax(My_INT(Pop(ref X0, FD)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter);
                    MyUniverse.OptionDisplay[I1].X = I2;
                    MyUniverse.OptionDisplay[I1].Y = I3;
                    MyUniverse.OptionDisplay[I1].Textwidth = MyMinMax(PopValue(ref X0), 50, MyUniverse.SysGen.Constants.constantSymbolCenter + MyUniverse.SysGen.Constants.constantSymbolCenter);
                    MyUniverse.OptionDisplay[I1].Textheight = MyMinMax(PopValue(ref X0), 50, MyUniverse.SysGen.Constants.constantSymbolCenter + MyUniverse.SysGen.Constants.constantSymbolCenter);
                    break;
                }

                case "delimiters":
                {
                    MyUniverse.SysGen.Constants.RMStart = Pop(ref X0, FD);
                    MyUniverse.SysGen.Constants.RMEnd = Pop(ref X0, FD);
                    break;
                }

                case "language" // Set a new language parameter (for any new language)
                    :
                {
                    // hack, need to also see if this language is already there and replace it.
                    OptionScreen.ListBoxLanguage.Items.Add(X0);
                    break;
                }

                case "options":
                {
                    // Force it to only change the available list
                    X2 = Pop(ref X0, FD);
                    I = MyMinMax(My_INT(X2), 0, OptionScreen.CheckedListBoxOptionSelection.Items.Count - 1);
                    OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(I, CheckState.Checked);
                    break;
                }

                case "scale":
                {
                    X2 = Pop(ref X0, FD);
                    MyUniverse.SysGen.MyFlowChartScale = System.Convert.ToSingle(System.Convert.ToDouble(X2) / 1000.0);
                    AInfo(625, "Scale changed", "from " + Constants.vbTab + MyUniverse.SysGen.MyFlowChartScale.ToString(), MyShowScale());
                    LimitScale();
                    break;
                }

                case "Grids":
                {
                    // Done Add /set=grids=
                    // Symbol grid(default 250), 
                    // Point and path Grid(defaul 50),
                    // Line grid(default 1)
                    MyUniverse.SysGen.Snaps.MySnap = MyMinMax(My_INT(Pop(ref X0, FD)), 1, 10);
                    MyUniverse.SysGen.Snaps.MyPointSnap = MyMinMax(My_INT(Pop(ref X0, FD)), 1, 250);
                    MyUniverse.SysGen.Snaps.MySymbolSnap = MyMinMax(My_INT(Pop(ref X0, FD)), 1, 10000);
                    MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing = MyMinMax(My_INT(Pop(ref X0, FD)), MyUniverse.SysGen.Constants.constantSymbolCenter * 2, MyUniverse.SysGen.Constants.constantSymbolCenter * 10);
                    break;
                }

                case "dump":
                {
                    mydoevents();
                    X2 = Pop(ref X0, FD);
                    mydoevents();
                    X3 = Pop(ref X0, FD);
                    X4 = Pop(ref X0, FD);
                    x5 = Pop(ref X0, FD);
                    AInfo(626, "Dump Files Set to", X2 + Constants.vbCrLf + X3 + Constants.vbCrLf + X4 + Constants.vbCrLf + x5, "");
                    MyUniverse.MySystem.Dumps.OutputFileName1 = X2;
                    MyUniverse.MySystem.Dumps.OutputFileName2 = X3;
                    MyUniverse.MySystem.Dumps.OutputFileName3 = X4;
                    MyUniverse.MySystem.Dumps.OutputFileName4 = x5;
                    // todo kill all dump file ehen you start and also when you import another dump file (delete the old, and also the new)
                    if (FileSystem.Dir(MyUniverse.MySystem.Dumps.OutputFileName1) != "")
                        FileSystem.Kill(MyUniverse.MySystem.Dumps.OutputFileName1);
                    if (FileSystem.Dir(MyUniverse.MySystem.Dumps.OutputFileName2) != "")
                        FileSystem.Kill(MyUniverse.MySystem.Dumps.OutputFileName2);
                    if (FileSystem.Dir(MyUniverse.MySystem.Dumps.OutputFileName3) != "")
                        FileSystem.Kill(MyUniverse.MySystem.Dumps.OutputFileName3);
                    if (FileSystem.Dir(MyUniverse.MySystem.Dumps.OutputFileName4) != "")
                        FileSystem.Kill(MyUniverse.MySystem.Dumps.OutputFileName4);
                    break;
                }
            }
        }


        void DoOption(long WhichOne, string HowMuch, string OtherOptions)
        {
            long I;
            string X;
            long Level;

            switch (WhichOne)
            {
            case 51:
            {
                for (I = Information.LBound(MyMessageBits); I <= Information.UBound(MyMessageBits); I++)
                    MyMessageBits[I] = 255;// Turn "on" all message and debug bits
                break;
            }

            case 53 // Turn off information messages
                :
            {
                for (I = 0; I <= OptionScreen.ComboBoxDebug.Items.Count - 1; I++)
                {
                    X = OptionScreen.ComboBoxDebug.Items.Item(I).ToString;
                    Level = PopValue(ref X);
                    if (Strings.LCase(Strings.Trim(Pop(ref X, MyUniverse.SysGen.Constants.ConstantDelimeters))) == "information")
                        BitSet(Level, "off");// turn on or off all information that can show up
                }

                break;
            }

            case 54 // Turn off warning messages
                :
            {
                for (I = 0; I <= OptionScreen.ComboBoxDebug.Items.Count - 1; I++)
                {
                    X = OptionScreen.ComboBoxDebug.Items.Item(I).ToString;
                    Level = PopValue(ref X);
                    if (Strings.LCase(Strings.Trim(Pop(ref X, MyUniverse.SysGen.Constants.ConstantDelimeters))) == "warning")
                        BitSet(Level, "off");// turn on or off all information that can show up
                }

                break;
            }

            case 55 // Turn off wrong messages
                :
            {
                for (I = 0; I <= OptionScreen.ComboBoxDebug.Items.Count - 1; I++)
                {
                    X = OptionScreen.ComboBoxDebug.Items.Item(I).ToString;
                    Level = PopValue(ref X);
                    if (Strings.LCase(Strings.Trim(Pop(ref X, MyUniverse.SysGen.Constants.ConstantDelimeters))) == "wrong")
                        BitSet(Level, "off");// turn on or off all information that can show up
                }

                break;
            }

            default:
            {
                if (WhichOne >= 998 & WhichOne < 10000)
                    BitSet(WhichOne, HowMuch);
                break;
            }
            }
        }


        void ImportColors(string Key_Line)
        {
            string Temp;
            long Temp2;
            long IndexColor;
            string Inputline;

            Inputline = TrimEqual(Key_Line);

            MyMakeArraySizesBigger();
            Temp = Pop(ref Inputline, MyUniverse.SysGen.Constants.ConstantDelimeters);
            if (Temp == "=")
                Temp = Pop(ref Inputline, MyUniverse.SysGen.Constants.ConstantDelimeters);
            Temp = MyTrim(Temp);
            // should never return a -1
            if (PrintAbleNull(Temp) == "_")
                // MyMsgCtr(1413, "ImportColors", Temp, "16", "", "", "", "", "", "", "")
                return;
            CheckForAnySortNeeded("", 209);
            // ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_iSAM, IndexColor)) '3/13/19 incase of a color being added to the end
            IndexColor = FindIndexIniSAMTable("Color", "add", ref Color_FileName, ref Color_Name_iSAM, Temp); // hack
            // ShowSorts("Color", MyReSort("Color", Color_FileName, Color_Name_iSAM, IndexColor)) '3/13/19 incase of a color being added to the end
            // IndexColor = FindIndexIniSAMTable("Color", "add", Color_FileName, Color_Name_iSAM, Temp) 'hack
            if (IndexColor < 0)
            {
                CheckForAnySortNeeded("", 215);
                IndexColor = FindIndexIniSAMTable("Color", "add", ref Color_FileName, ref Color_Name_iSAM, Temp); // hack
                if (IndexColor == constantMyErrorCode)
                    IndexColor = NewTopOfFile("Color");
            }
            else
            {
                Temp2 = MyMinMax(IndexColor, 1, TopOfFile("Color"));
                if (Temp2 != IndexColor)
                    Abug(242, "ImportColors():", Temp2, IndexColor);
            }
            // Not in the table, so search for the closest name to this and make that the default color's

            if (Color_Name_iSAM[IndexColor] == 0)
                Color_Name_iSAM[IndexColor] = IndexColor;// Add a missing isam pointer


            // Color_TableName(Index) = Pop(KeyLine)
            Color_TableAlpha(IndexColor, PopValue(ref Inputline)); // Alpha
            Color_TableRed(IndexColor, PopValue(ref Inputline)); // Red
            Color_TableGreen(IndexColor, PopValue(ref Inputline)); // Green
            Color_TableBlue(IndexColor, PopValue(ref Inputline)); // Blue
            // ****** This is wrong, because all of the options are not available for all of the CAP styles, need to fix this later
            Color_TableStyle(IndexColor, Pop(ref Inputline, MyUniverse.SysGen.Constants.ConstantDelimeters)); // constantEnumStyle, Inputline)
            Color_TableStartCap(IndexColor, MyEnumValue(Pop(ref Inputline, MyUniverse.SysGen.Constants.ConstantDelimeters), SymbolScreen.ToolStripDropDownPathStart));
            Color_TableEndCap(IndexColor, MyEnumValue(Pop(ref Inputline, MyUniverse.SysGen.Constants.ConstantDelimeters), SymbolScreen.ToolStripDropDownPathEnd));
            CheckForAnySortNeeded("", 217); // hack


            ShowSorts("Color", MyReSort("Color", ref Color_FileName, ref Color_Name_iSAM, IndexColor)); // 03/12/19 only resort top item if changed
            CheckForAnySortNeeded("", 218); // hack
            // DisplayMyStatus(" Added Color " & Temp)
            TopOfFile("color"); // This is to update the top of file, and make the array bigger
            TestIfColorStandardMicroSoftColorName(IndexColor);
            SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Add(Color_TableName(IndexColor));
        }


        void ImportSymbolPointPreference()
        {
            MyUniverse.MySymbolPoints[1].X = 0; MyUniverse.MySymbolPoints[1].Y = -250;
            MyUniverse.MySymbolPoints[2].X = 0; MyUniverse.MySymbolPoints[2].Y = 250;
            MyUniverse.MySymbolPoints[3].X = 250; MyUniverse.MySymbolPoints[3].Y = 0;
            MyUniverse.MySymbolPoints[4].X = -250; MyUniverse.MySymbolPoints[4].Y = 0;
            MyUniverse.MySymbolPoints[5].X = -150; MyUniverse.MySymbolPoints[5].Y = -250;
            MyUniverse.MySymbolPoints[6].X = 150; MyUniverse.MySymbolPoints[6].Y = -250;
            MyUniverse.MySymbolPoints[7].X = 150; MyUniverse.MySymbolPoints[7].Y = 250;
            MyUniverse.MySymbolPoints[8].X = -150; MyUniverse.MySymbolPoints[8].Y = 250;
            MyUniverse.MySymbolPoints[9].X = -250; MyUniverse.MySymbolPoints[9].Y = -250;
            MyUniverse.MySymbolPoints[10].X = 250; MyUniverse.MySymbolPoints[10].Y = -250;
            MyUniverse.MySymbolPoints[11].X = 250; MyUniverse.MySymbolPoints[11].Y = 250;
            MyUniverse.MySymbolPoints[12].X = -250; MyUniverse.MySymbolPoints[12].Y = 250;
            MyUniverse.MySymbolPoints[13].X = -250; MyUniverse.MySymbolPoints[13].Y = -150;
            MyUniverse.MySymbolPoints[14].X = 250; MyUniverse.MySymbolPoints[14].Y = -150;
            MyUniverse.MySymbolPoints[15].X = 250; MyUniverse.MySymbolPoints[15].Y = 150;
            MyUniverse.MySymbolPoints[16].X = -250; MyUniverse.MySymbolPoints[16].Y = 150;
            MyUniverse.MySymbolPoints[17].X = -150; MyUniverse.MySymbolPoints[17].Y = -150;
            MyUniverse.MySymbolPoints[18].X = 150; MyUniverse.MySymbolPoints[18].Y = -150;
            MyUniverse.MySymbolPoints[19].X = 150; MyUniverse.MySymbolPoints[19].Y = 150;
            MyUniverse.MySymbolPoints[20].X = -150; MyUniverse.MySymbolPoints[20].Y = 150;
            MyUniverse.MySymbolPoints[21].X = -50; MyUniverse.MySymbolPoints[21].Y = -50;
            MyUniverse.MySymbolPoints[22].X = 50; MyUniverse.MySymbolPoints[22].Y = -50;
            MyUniverse.MySymbolPoints[23].X = 50; MyUniverse.MySymbolPoints[23].Y = 50;
            MyUniverse.MySymbolPoints[24].X = -50; MyUniverse.MySymbolPoints[24].Y = 50;
            MyUniverse.MySymbolPoints[25].X = -50; MyUniverse.MySymbolPoints[25].Y = 0;
            MyUniverse.MySymbolPoints[26].X = 50; MyUniverse.MySymbolPoints[26].Y = 0;
            MyUniverse.MySymbolPoints[27].X = 0; MyUniverse.MySymbolPoints[27].Y = -50;
            MyUniverse.MySymbolPoints[28].X = 0; MyUniverse.MySymbolPoints[28].Y = 50;
            MyUniverse.MySymbolPoints[29].X = -100; MyUniverse.MySymbolPoints[29].Y = 100;
            MyUniverse.MySymbolPoints[30].X = 100; MyUniverse.MySymbolPoints[30].Y = 100;
            MyUniverse.MySymbolPoints[31].X = 100; MyUniverse.MySymbolPoints[31].Y = -100;
            MyUniverse.MySymbolPoints[32].X = -100; MyUniverse.MySymbolPoints[32].Y = -100;
            MyUniverse.MySymbolPoints[33].X = -100; MyUniverse.MySymbolPoints[33].Y = 0;
            MyUniverse.MySymbolPoints[34].X = 0; MyUniverse.MySymbolPoints[34].Y = 100;
            MyUniverse.MySymbolPoints[35].X = 100; MyUniverse.MySymbolPoints[35].Y = 0;
            MyUniverse.MySymbolPoints[36].X = 0; MyUniverse.MySymbolPoints[36].Y = -100;
            MyUniverse.MySymbolPoints[37].X = -150; MyUniverse.MySymbolPoints[37].Y = -100;
            MyUniverse.MySymbolPoints[38].X = 150; MyUniverse.MySymbolPoints[38].Y = 100;
            MyUniverse.MySymbolPoints[39].X = 150; MyUniverse.MySymbolPoints[39].Y = -100;
            MyUniverse.MySymbolPoints[40].X = -150; MyUniverse.MySymbolPoints[40].Y = 100;
            MyUniverse.MySymbolPoints[41].X = -150; MyUniverse.MySymbolPoints[41].Y = 0;
            MyUniverse.MySymbolPoints[42].X = 150; MyUniverse.MySymbolPoints[42].Y = 0;
            MyUniverse.MySymbolPoints[43].X = 0; MyUniverse.MySymbolPoints[43].Y = -150;
            MyUniverse.MySymbolPoints[44].X = 0; MyUniverse.MySymbolPoints[44].Y = 150;
            MyUniverse.MySymbolPoints[45].X = -200; MyUniverse.MySymbolPoints[45].Y = 0;
            MyUniverse.MySymbolPoints[46].X = 0; MyUniverse.MySymbolPoints[46].Y = -200;
            MyUniverse.MySymbolPoints[47].X = 0; MyUniverse.MySymbolPoints[47].Y = 200;
            MyUniverse.MySymbolPoints[48].X = 200; MyUniverse.MySymbolPoints[48].Y = 0;
            MyUniverse.MySymbolPoints[49].X = -200; MyUniverse.MySymbolPoints[49].Y = -150;
            MyUniverse.MySymbolPoints[50].X = -200; MyUniverse.MySymbolPoints[50].Y = -100;
            MyUniverse.MySymbolPoints[51].X = -200; MyUniverse.MySymbolPoints[51].Y = 100;
            MyUniverse.MySymbolPoints[52].X = -200; MyUniverse.MySymbolPoints[52].Y = 150;
            MyUniverse.MySymbolPoints[53].X = 200; MyUniverse.MySymbolPoints[53].Y = 150;
            MyUniverse.MySymbolPoints[54].X = 200; MyUniverse.MySymbolPoints[54].Y = 100;
            MyUniverse.MySymbolPoints[55].X = 200; MyUniverse.MySymbolPoints[55].Y = -100;
            MyUniverse.MySymbolPoints[56].X = 200; MyUniverse.MySymbolPoints[56].Y = -150;
            MyUniverse.MySymbolPoints[57].X = -100; MyUniverse.MySymbolPoints[57].Y = -150;
            MyUniverse.MySymbolPoints[58].X = -100; MyUniverse.MySymbolPoints[58].Y = 150;
            MyUniverse.MySymbolPoints[59].X = 100; MyUniverse.MySymbolPoints[59].Y = 150;
            MyUniverse.MySymbolPoints[60].X = 100; MyUniverse.MySymbolPoints[60].Y = -150;
            MyUniverse.MySymbolPoints[61].X = -50; MyUniverse.MySymbolPoints[61].Y = -100;
            MyUniverse.MySymbolPoints[62].X = -50; MyUniverse.MySymbolPoints[62].Y = 100;
            MyUniverse.MySymbolPoints[63].X = 50; MyUniverse.MySymbolPoints[63].Y = 100;
            MyUniverse.MySymbolPoints[64].X = 50; MyUniverse.MySymbolPoints[64].Y = -100;
            MyUniverse.MySymbolPoints[65].X = -50; MyUniverse.MySymbolPoints[65].Y = -150;
            MyUniverse.MySymbolPoints[66].X = 50; MyUniverse.MySymbolPoints[66].Y = -150;
            MyUniverse.MySymbolPoints[67].X = 50; MyUniverse.MySymbolPoints[67].Y = 150;
            MyUniverse.MySymbolPoints[68].X = -50; MyUniverse.MySymbolPoints[68].Y = 150;
            MyUniverse.MySymbolPoints[69].X = -100; MyUniverse.MySymbolPoints[69].Y = 50;
            MyUniverse.MySymbolPoints[70].X = -100; MyUniverse.MySymbolPoints[70].Y = -50;
            MyUniverse.MySymbolPoints[71].X = 100; MyUniverse.MySymbolPoints[71].Y = -50;
            MyUniverse.MySymbolPoints[72].X = 100; MyUniverse.MySymbolPoints[72].Y = 50;
            MyUniverse.MySymbolPoints[73].X = -150; MyUniverse.MySymbolPoints[73].Y = -200;
            MyUniverse.MySymbolPoints[74].X = 150; MyUniverse.MySymbolPoints[74].Y = -200;
            MyUniverse.MySymbolPoints[75].X = 150; MyUniverse.MySymbolPoints[75].Y = -50;
            MyUniverse.MySymbolPoints[76].X = 150; MyUniverse.MySymbolPoints[76].Y = 50;
            MyUniverse.MySymbolPoints[77].X = -150; MyUniverse.MySymbolPoints[77].Y = 50;
            MyUniverse.MySymbolPoints[78].X = -150; MyUniverse.MySymbolPoints[78].Y = -50;
            MyUniverse.MySymbolPoints[79].X = -200; MyUniverse.MySymbolPoints[79].Y = -200;
            MyUniverse.MySymbolPoints[80].X = -100; MyUniverse.MySymbolPoints[80].Y = -200;
            MyUniverse.MySymbolPoints[81].X = -50; MyUniverse.MySymbolPoints[81].Y = -200;
            MyUniverse.MySymbolPoints[82].X = 50; MyUniverse.MySymbolPoints[82].Y = -200;
            MyUniverse.MySymbolPoints[83].X = 100; MyUniverse.MySymbolPoints[83].Y = -200;
            MyUniverse.MySymbolPoints[84].X = 200; MyUniverse.MySymbolPoints[84].Y = -200;
            MyUniverse.MySymbolPoints[85].X = 200; MyUniverse.MySymbolPoints[85].Y = -50;
            MyUniverse.MySymbolPoints[86].X = 200; MyUniverse.MySymbolPoints[86].Y = 50;
            MyUniverse.MySymbolPoints[87].X = 200; MyUniverse.MySymbolPoints[87].Y = 200;
            MyUniverse.MySymbolPoints[88].X = 150; MyUniverse.MySymbolPoints[88].Y = 200;
            MyUniverse.MySymbolPoints[89].X = 100; MyUniverse.MySymbolPoints[89].Y = 200;
            MyUniverse.MySymbolPoints[90].X = 50; MyUniverse.MySymbolPoints[90].Y = 200;
            MyUniverse.MySymbolPoints[91].X = -50; MyUniverse.MySymbolPoints[91].Y = 200;
            MyUniverse.MySymbolPoints[92].X = -100; MyUniverse.MySymbolPoints[92].Y = 200;
            MyUniverse.MySymbolPoints[93].X = -150; MyUniverse.MySymbolPoints[93].Y = 200;
            MyUniverse.MySymbolPoints[94].X = -200; MyUniverse.MySymbolPoints[94].Y = 200;
            MyUniverse.MySymbolPoints[95].X = -200; MyUniverse.MySymbolPoints[95].Y = 50;
            MyUniverse.MySymbolPoints[96].X = -200; MyUniverse.MySymbolPoints[96].Y = -50;
            MyUniverse.MySymbolPoints[97].X = -200; MyUniverse.MySymbolPoints[97].Y = -250;
            MyUniverse.MySymbolPoints[98].X = -100; MyUniverse.MySymbolPoints[98].Y = -250;
            MyUniverse.MySymbolPoints[99].X = -50; MyUniverse.MySymbolPoints[99].Y = -250;
            MyUniverse.MySymbolPoints[100].X = 50; MyUniverse.MySymbolPoints[100].Y = -250;
            MyUniverse.MySymbolPoints[101].X = 100; MyUniverse.MySymbolPoints[101].Y = -250;
            MyUniverse.MySymbolPoints[102].X = 200; MyUniverse.MySymbolPoints[102].Y = -250;
            MyUniverse.MySymbolPoints[103].X = 250; MyUniverse.MySymbolPoints[103].Y = -200;
            MyUniverse.MySymbolPoints[104].X = 250; MyUniverse.MySymbolPoints[104].Y = -100;
            MyUniverse.MySymbolPoints[105].X = 250; MyUniverse.MySymbolPoints[105].Y = -50;
            MyUniverse.MySymbolPoints[106].X = 250; MyUniverse.MySymbolPoints[106].Y = 50;
            MyUniverse.MySymbolPoints[107].X = 250; MyUniverse.MySymbolPoints[107].Y = 100;
            MyUniverse.MySymbolPoints[108].X = 250; MyUniverse.MySymbolPoints[108].Y = 200;
            MyUniverse.MySymbolPoints[109].X = 200; MyUniverse.MySymbolPoints[109].Y = 250;
            MyUniverse.MySymbolPoints[110].X = 100; MyUniverse.MySymbolPoints[110].Y = 250;
            MyUniverse.MySymbolPoints[111].X = 50; MyUniverse.MySymbolPoints[111].Y = 250;
            MyUniverse.MySymbolPoints[112].X = -50; MyUniverse.MySymbolPoints[112].Y = 250;
            MyUniverse.MySymbolPoints[113].X = -100; MyUniverse.MySymbolPoints[113].Y = 250;
            MyUniverse.MySymbolPoints[114].X = -200; MyUniverse.MySymbolPoints[114].Y = 250;
            MyUniverse.MySymbolPoints[115].X = -250; MyUniverse.MySymbolPoints[115].Y = 200;
            MyUniverse.MySymbolPoints[116].X = -250; MyUniverse.MySymbolPoints[116].Y = 100;
            MyUniverse.MySymbolPoints[117].X = -250; MyUniverse.MySymbolPoints[117].Y = 50;
            MyUniverse.MySymbolPoints[118].X = -250; MyUniverse.MySymbolPoints[118].Y = -50;
            MyUniverse.MySymbolPoints[119].X = -250; MyUniverse.MySymbolPoints[119].Y = -100;
            MyUniverse.MySymbolPoints[120].X = -250; MyUniverse.MySymbolPoints[120].Y = -200;
            MyUniverse.MySymbolPoints[121].X = 0; MyUniverse.MySymbolPoints[121].Y = 0;
        }


        ImportLineStruct FillImportLine()
        {
            FillImportLine = default(ImportLineStruct);
            FillImportLine.LastName = "";
            FillImportLine.IndexName = -1;
            FillImportLine.IndexSymbol = -1;
            FillImportLine.TopMost = -1;

            FillImportLine.Inputs.KeyLineOrFile = "?";
            FillImportLine.Inputs.KeyParameters = "?";
            FillImportLine.Inputs.KeyWord = "?";
            FillImportLine.Inputs.LineNumberIn = 1;

            FillImportLine.Temps.TempInteger1 = -1;
            FillImportLine.Temps.TempString2 = "off";
            FillImportLine.Temps.TempFormat = "?";
            FillImportLine.Temps.TempRecord = -1;

            FillImportLine.MyRecord.Coded = 0;
            FillImportLine.MyRecord.X1 = -1;
            FillImportLine.MyRecord.Y1 = -1;
            FillImportLine.MyRecord.X2.MyString = "";
            FillImportLine.MyRecord.Y2.MyString = "";
            FillImportLine.MyRecord.X2.MyNumber = 0;
            FillImportLine.MyRecord.Y2.MyNumber = 0;
            FillImportLine.MyRecord.NameOfPoint = "?";
        }



        string ImportLineOrFile(string InputLineOrFile)
        {
            long I;
            string MyTemp;
            MyMakeArraySizesBigger();
            // process all 
            // make sure that i include anything left over not done.
            MyUniverse.MySS.Inputs.KeyLineOrFile = InputLineOrFile;

            while (Strings.Len(MyUniverse.MySS.Inputs.KeyLineOrFile) > 0)
            {
                mydoevents();
                MyUniverse.MySS.Inputs.KeyLineOrFile = MyTrim(MyUniverse.MySS.Inputs.KeyLineOrFile);
                MyUniverse.MySS.Inputs.KeyParameters = PopLine(ref MyTrim(MyUniverse.MySS.Inputs.KeyLineOrFile));
                MyUniverse.MySS.Inputs.KeyLineOrFile = Strings.Mid(MyUniverse.MySS.Inputs.KeyLineOrFile, 1 + Strings.Len(MyUniverse.MySS.Inputs.KeyParameters), Strings.Len(MyUniverse.MySS.Inputs.KeyLineOrFile));
                MyUniverse.MySS.Inputs.KeyWord = Pop(ref MyUniverse.MySS.Inputs.KeyParameters, "=");
                if (MyUniverse.MySS.Inputs.LineNumberIn != 0 & Conversion.Int(MyUniverse.MySS.Inputs.LineNumberIn / (double)100) * 100 == MyUniverse.MySS.Inputs.LineNumberIn)
                    DisplayMyStatus("At Line " + MyUniverse.MySS.Inputs.LineNumberIn + " " + MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters);
                switch (Strings.LCase(MyTrim(MyUniverse.MySS.Inputs.KeyWord)))
                {
                case "/route":
                {
                    for (I = 1; I <= Information.UBound(Net_FileLinks); I++)
                    {
                        AInfo1(726, "Doing path " + I, MyShowNetLnks(I), "");
                        RouterTicked();
                        MyROUTERnetIndex(I);
                    }

                    break;
                }

                case "/ignore":
                {
                    MyUniverse.MySS.Inputs.KeyParameters = "";// Ignore everything on this
                    break;
                }

                case "/set":
                {
                    SetOptions(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/option":
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatOption;
                    if (ThisIsANumber(MyUniverse.MySS.Inputs.KeyParameters))
                    {
                        MyUniverse.MySS.Temps.TempInteger1 = PopValue(ref MyUniverse.MySS.Inputs.KeyParameters);
                        MyUniverse.MySS.Temps.Templong = PopValue(ref MyUniverse.MySS.Inputs.KeyParameters);
                        if (MyUniverse.MySS.Temps.Templong == 0)
                            MyUniverse.MySS.Temps.TempString2 = "off";
                        else
                            MyUniverse.MySS.Temps.TempString2 = "on";
                        BitSet(MyMinMax(MyUniverse.MySS.Temps.TempInteger1, 1, 10000 - 1), MyUniverse.MySS.Temps.TempString2);
                    }

                    break;
                }

                case "/C_L_case":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_Case = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/C_L_multiline":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_MultiLine = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.ProgramOptions.C_L_MultiLine = ReplaceWithActuralControlCharacter(MyUniverse.ProgramOptions.C_L_MultiLine);
                    break;
                }

                case "/C_L_comment":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_Comment = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/C_L_extention":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_Extention = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/C_L_VarChars":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_VarChars = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/C_L_DialectName":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_DialectName = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/GotoNextLine":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.SysGen.Constants.ConstantGotoNextLine = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/CameFromLine":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.SysGen.Constants.ConstantCameFromLine = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/C_L_process":
                {
                    if (MyTrim(MyUniverse.MySS.Inputs.KeyParameters) != "")
                        MyUniverse.ProgramOptions.C_L_Process = MyTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/color":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatColor;
                    ImportColors(MyUniverse.MySS.Inputs.KeyParameters);
                    ShowSorts("Color", SortColors());// 20200702
                    break;
                }

                case "/datatype":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatDatatype;
                    ImportDataTypes(MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn);
                    SortDataType();
                    break;
                }

                case "/name":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatSymbolName;
                    ShowSorts("Named", MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, TopOfFile("named")));
                    ShowSorts("Named", MyReSort("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, TopOfFile("named")));
                    MyUniverse.MySS.LastName = Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters);
                    MakeItTheBiggestSymbolNumber(ref MyUniverse.MySS.LastName);
                    CheckForAnySortNeeded("", 219);
                    // ***********************************************************
                    // is returning the wrong should be 1 and returns 0
                    MyUniverse.MySS.IndexName = FindIndexIniSAMTable("Named", "add", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, MyUniverse.MySS.LastName);
                    // *********************************************************
                    if (MyUniverse.MySS.IndexName == constantMyErrorCode)
                    {
                        Abug(243, MyUniverse.MySS.Inputs.KeyLineOrFile, "The index for the symbol is not found.", MyUniverse.MySS.LastName);
                        MyUniverse.MySS.IndexName = AddNewNamedRecord(MyUniverse.MySS.LastName, "?", "?", "?", "?", "?", "?", "?", "?", "?");
                        MyUniverse.MySS.IndexName = TopOfFile("named");
                        MyUniverse.MySS.IndexName = FindIndexIniSAMTable("Named", "Don Add Find Again after Sort", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, MyUniverse.MySS.LastName);
                        CheckForAnySortNeeded("", 223);
                    }
                    if (MyUniverse.MySS.IndexName == constantMyErrorCode)
                    {
                    }
                    else
                    {
                        // Get the Direct Array Indexes
                        if (Named_TableSymbolName(MyUniverse.MySS.IndexName) != MyUniverse.MySS.LastName)
                            Abug(245, MyUniverse.MySS.Inputs.KeyLineOrFile, 3, 3);// we should always have the name after we have just found it'
                                                                                  // Named_TableSymbolName(MyUniverse.MySS.indexname, MyUniverse.MySS.lastname) ' why are we replacing it when we just found it?
                        MyMakeArraySizesBigger();
                        if (PrintAbleNull(MyUniverse.MySS.Inputs.KeyParameters) == "_")
                            MyUniverse.MySS.Inputs.KeyParameters = "?" + MyUniverse.MySS.LastName;
                        MyUniverse.MySS.IndexSymbol = FindInSymbolList(ref MyUniverse.MySS.LastName);
                        if (MyUniverse.MySS.IndexSymbol == constantMyErrorCode)
                        {
                            AddNEWSymbolpointRecord(MyUniverse.MySS.LastName, "/name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn);
                            MyUniverse.MySS.IndexSymbol = TopOfFile("Symbol");
                        }
                        if (MyUniverse.MySS.IndexSymbol != constantMyErrorCode)
                        {
                            // Debug, check if this is updating the table after finding it above
                            Symbol_FileCoded[MyUniverse.MySS.IndexSymbol] = MyKeyword_2_Byte("/name"); // KeyConstName '"/name"
                                                                                                       // Symbol_TableSymbolName(MyUniverse.MySS.indexsymbol, MyUniverse.MySS.lastname)' Did not need to do it again!!!!!
                            Symbol_Table_NameOfPoint(MyUniverse.MySS.IndexSymbol, MyUniverse.MySS.Inputs.KeyParameters);
                            Symbol_TableX1(MyUniverse.MySS.IndexSymbol, 1);
                            Symbol_TableY1(MyUniverse.MySS.IndexSymbol, 1);
                            Symbol_TableX2(MyUniverse.MySS.IndexSymbol, 1);
                            Symbol_TableY2(MyUniverse.MySS.IndexSymbol, 1);
                            Symbol_TableX1(MyUniverse.MySS.IndexSymbol, 1);
                        }
                        else
                            MyMsgCtr(1411, "Import", MyUniverse.MySS.IndexSymbol.ToString(), TopOfFile("Symbol").ToString(), MyUniverse.MySS.Inputs.KeyWord, MyUniverse.MySS.Inputs.KeyLineOrFile, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), "", "", "", "");
                    }

                    break;
                }

                case "/point":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatPoint;
                    MyUniverse.MySS.Inputs.KeyParameters = XTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.MyRecord.a.Xx = PopValue(ref MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.Inputs.KeyParameters = XTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.MyRecord.a.Yy = PopValue(ref MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.MyRecord.a = MyPointSnap(MyUniverse.MySS.MyRecord.a);
                    MyUniverse.MySS.Inputs.KeyParameters = XTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.MyRecord.X2.MyString = Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters);
                    MyUniverse.MySS.Inputs.KeyParameters = XTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.MyRecord.Y2.MyString = Strings.Trim(Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters));
                    MyUniverse.MySS.Inputs.KeyParameters = XTrim(MyUniverse.MySS.Inputs.KeyParameters);
                    MyUniverse.MySS.MyRecord.NameOfPoint = MyUniverse.MySS.Inputs.KeyParameters;
                    MyUniverse.MySS.Inputs.KeyParameters = XTrim(MyUniverse.MySS.Inputs.KeyParameters);

                    // This will inser them backwards, but who cares? (It should not make a difference because each record should be independant.
                    AddNEWSymbolpointRecord(MyUniverse.MySS.LastName, "/point", MyUniverse.MySS.MyRecord.X1, MyUniverse.MySS.MyRecord.Y1, MyUniverse.MySS.MyRecord.X2.MyString, MyUniverse.MySS.MyRecord.Y2.MyString, MyUniverse.MySS.MyRecord.NameOfPoint, MyUniverse.MySS.Inputs.LineNumberIn);
                    CheckForAnySortNeeded("", 230);


                    Symbol_Table_NameOfPoint(TopOfFile("Symbol"), MyUniverse.MySS.Inputs.KeyParameters); // For A point
                    ShowSorts("DataType", MyReSort("DataType", ref DataType_FileName, ref DataType_Name_iSAM, TopOfFile("Symbol"))); // 3/12/19 only sort added 
                    break;
                }

                case "/line":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatLine;
                    MyUniverse.MySS.TopMost = NewTopOfFile("Symbol");
                    Symbol_FileSymbolName[MyUniverse.MySS.TopMost] = "L_" + MyUniverse.MySS.TopMost; // No lines have input names, only color, so this is to allow other sorts to work
                    Symbol_TableCode(MyUniverse.MySS.TopMost, MyKeyword_2_Byte(MyUniverse.MySS.Inputs.KeyWord));
                    Symbol_TableX1(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(ref MyUniverse.MySS.Inputs.KeyParameters)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter));
                    Symbol_TableY1(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(ref MyUniverse.MySS.Inputs.KeyParameters)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter));
                    Symbol_TableX2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(ref MyUniverse.MySS.Inputs.KeyParameters)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter));
                    Symbol_TableY2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(ref MyUniverse.MySS.Inputs.KeyParameters)), -MyUniverse.SysGen.Constants.constantSymbolCenter, MyUniverse.SysGen.Constants.constantSymbolCenter));
                    Symbol_Table_NameOfPoint(MyUniverse.MySS.TopMost, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters)); // Color
                    if (MyUniverse.MySS.Inputs.KeyParameters == "")
                        Symbol_TableSymbolName(MyUniverse.MySS.TopMost, "Line" + TopOfFile("Symbol"));
                    else
                        Symbol_TableSymbolName(MyUniverse.MySS.TopMost, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters));// Optional, but should never be a named line, Only Paths
                    MyMakeArraySizesBigger();
                    break;
                }

                case "/path":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatPath;
                    MyUniverse.MySS.Temps.TempRecord = NewFlowChartRecord();
                    FlowChart_TableCode(MyUniverse.MySS.Temps.TempRecord, "/path"); // KeyConstPath)
                    FlowChart_TablePathSymbolName(MyUniverse.MySS.Temps.TempRecord, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters)); // name last
                    MyPathTextValues2Line(MyUniverse.MySS.Temps.TempRecord, ref MyUniverse.MySS.Inputs.KeyLineOrFile);


                    FlowChart_Table_DataType(MyUniverse.MySS.Temps.TempRecord, Strings.Trim(Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters))); // Datatype
                    ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord));
                    // 20200709                            PaintAll(Where, myy.temps.temprecord, myy.temps.temprecord)
                    MyMakeArraySizesBigger();
                    PaintAll(FlowChartScreen.PictureBox1, MyUniverse.MySS.Temps.TempRecord, MyUniverse.MySS.Temps.TempRecord);
                    break;
                }

                case "/use":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatUse; // hack
                    MyUniverse.MySS.Temps.TempRecord = NewFlowChartRecord();
                    FlowChart_TableCode(MyUniverse.MySS.Temps.TempRecord, "/use");
                    FlowChart_TablePathSymbolName(MyUniverse.MySS.Temps.TempRecord, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters)); // Name First
                    MyUseTextValues2Line(MyUniverse.MySS.Temps.TempRecord, ref MyUniverse.MySS.Inputs.KeyParameters);
                    // FlowChart_TableX1(MyUniverse.MySS.Temps.TempRecord, MySymbolSnap(PopValue(MyUniverse.MySS.Inputs.KeyParameters)))
                    // FlowChart_TableY1(MyUniverse.MySS.Temps.TempRecord, MySymbolSnap(PopValue(MyUniverse.MySS.Inputs.KeyParameters)))
                    FlowChart_Table_Rotation(MyUniverse.MySS.Temps.TempRecord, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters));
                    FlowChart_Table_DataType(MyUniverse.MySS.Temps.TempRecord, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters)); // later for dynamic symbols
                    ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord));
                    PaintAll(FlowChartScreen.PictureBox1, MyUniverse.MySS.Temps.TempRecord, MyUniverse.MySS.Temps.TempRecord);
                    break;
                }

                case "/thiscode" // Ignore it
                    :
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatThisCode;
                    if (TopOfFile("FlowChart") > 0)
                        FlowChart_Table_DataType(TopOfFile("FlowChart"), FlowChart_Table_DataType(TopOfFile("FlowChart")) + Constants.vbCrLf + MyUniverse.MySS.Inputs.KeyParameters);
                    else
                        MyMsgCtr(1402, "Import", "/thiscode" + " : ", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/microcodetext":
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatMacroText;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableMicroCodeText(MyUniverse.MySS.IndexName, Named_TableMicroCodeText(MyUniverse.MySS.IndexName) + Constants.vbCrLf + MyUniverse.MySS.Inputs.KeyParameters + MyUniverse.ProgramOptions.C_L_MultiLine);
                    else
                        MyMsgCtr(1403, "Import", "/microcodetext", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/syntax":
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatSintaxKeyWord;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableSintax(MyUniverse.MySS.IndexName, Named_TableSintax(MyUniverse.MySS.IndexName) + Constants.vbCr + MyUniverse.MySS.Inputs.KeyParameters);
                    else
                        MyMsgCtr(1403, "Import", "/Syntax", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/order":
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatOrder;
                    MyUniverse.SysGen.Order = PopLine(ref MyUniverse.MySS.Inputs.KeyParameters);
                    break;
                }

                case "/filename":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatNameOfFile;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableNameOfFile(MyUniverse.MySS.IndexName, MyUniverse.MySS.Inputs.KeyParameters);
                    else
                        MyMsgCtr(1404, "Import", "/filename", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/language":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatLanguage;
                    MyDoEvents();
                    MyFlowChartNameSpace.F_C.MyUniverse.ProgramOptions.C_L_LanguageClassName = MyUniverse.MySS.Inputs.KeyParameters;
                    // OptionScreen.ListBoxComputerLanguage, MyUniverse.MySS.Inputs.KeyParameters
                    // The name of the computer language is not a keyword
                    // AddAtomsToKeywordOROperatorORFunctionList("keyWord", MyUniverse.MySS.Inputs.KeyParameters, Language_KeyWord, FileInputOutputScreen.ProgressBarkeyWord)
                    MyButtonsEnableRules();
                    break;
                }

                case "/stroke":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatStroke;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableStroke(MyUniverse.MySS.IndexName, MyUniverse.MySS.Inputs.KeyParameters);
                    else
                        MyMsgCtr(1406, "Import", "/stroke" + " : ", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/notes":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatNotes;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableNotes(MyUniverse.MySS.IndexName, Named_TableNotes(MyUniverse.MySS.IndexName) + Constants.vbCr + PopLine(ref MyUniverse.MySS.Inputs.KeyParameters));
                    else
                        MyMsgCtr(1407, "Import", "/notes" + " : ", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/version":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatVersion;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableVersion(MyUniverse.MySS.IndexName, MyUniverse.MySS.Inputs.KeyParameters);
                    else
                        MyMsgCtr(1408, "Import", "/version" + " : ", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/author":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatAuthor;
                    if (MyUniverse.MySS.IndexName > 0)
                        Named_TableAuthor(MyUniverse.MySS.IndexName, MyUniverse.MySS.Inputs.KeyParameters);
                    else
                        MyMsgCtr(1409, "Import", "/author" + " : ", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/opcode":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatOpcode;
                    if (MyUniverse.MySS.IndexName > 0)
                    {
                        if (Strings.Len(Named_TableOpCode(MyUniverse.MySS.IndexName)) > 0)
                            Named_TableOpCode(MyUniverse.MySS.IndexName, Named_TableOpCode(MyUniverse.MySS.IndexName) + " " + MyUniverse.ProgramOptions.C_L_MultiLine + " " + MyUniverse.MySS.Inputs.KeyParameters);
                        else
                            Named_TableOpCode(MyUniverse.MySS.IndexName, MyUniverse.MySS.Inputs.KeyParameters);
                    }
                    else
                        MyMsgCtr(1410, "Import", "/opcode" + " : ", MyUniverse.MySS.Inputs.KeyWord + "=" + MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.LastName, "", "", "", "", "");
                    break;
                }

                case "/constant":
                {
                    MyUniverse.MySS.Temps.TempFormat = formatConstant;
                    MyUniverse.MySS.Temps.TempRecord = TopOfFile("FlowChart");
                    FlowChart_TableCode(MyUniverse.MySS.Temps.TempRecord, MyUniverse.MySS.Inputs.KeyWord);
                    MyUseTextValues2Line(MyUniverse.MySS.Temps.TempRecord, ref MyUniverse.MySS.Inputs.KeyParameters);
                    FlowChart_Table_DataType(MyUniverse.MySS.Temps.TempRecord, Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters));
                    FlowChart_TablePathSymbolName(MyUniverse.MySS.Temps.TempRecord, MyUniverse.MySS.Inputs.KeyParameters);
                    ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord));
                    CheckForAnySortNeeded("", 231);
                    ReSetScrollBars(MyUniverse.MySS.Temps.TempRecord);
                    break;
                }

                case "/error":
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatError;
                    break;
                }

                case "/delete":
                {
                    MyUniverse.MySS.Temps.TempFormat = FormatDelete;
                    break;
                }

                case "/keyword":
                {
                    // FindingMyBugs(10) 'hack Least amount of checking here
                    AddAtomsToKeywordOROperatorORFunctionList("keyWord", MyUniverse.MySS.Inputs.KeyParameters, ref Language_KeyWord, FileInputOutputScreen.ProgressBarKeyWords);
                    break;
                }

                case "/operator":
                {
                    // FindingMyBugs(10) 'hack Least amount of checking here
                    AddAtomsToKeywordOROperatorORFunctionList("Operator", MyUniverse.MySS.Inputs.KeyParameters, ref Language_Operator, FileInputOutputScreen.ProgressBarOperators); // Get rid of the '=' sign
                    break;
                }

                case "/function":
                {
                    // FindingMyBugs(10) 'hack Least amount of checking here
                    AddAtomsToKeywordOROperatorORFunctionList("Function", Strings.Trim(MyUniverse.MySS.Inputs.KeyParameters), ref Language_Function, FileInputOutputScreen.ProgressBarFunctions); // get rid of the equal sign and any white space
                    break;
                }

                case "/finish":
                case "":
                    case null // do nothing
                        :
                    {
                        break;
                    }

                    default:
                    {
                        SortALLiSAM();
                        if (Strings.Left(MyUniverse.MySS.Inputs.KeyParameters, 1) != "/")
                        {
                            if (Strings.Len(MyUniverse.MySS.Inputs.KeyParameters) > 0)
                                MyTemp = MyUniverse.MySS.Inputs.KeyParameters + " = " + MyUniverse.MySS.Inputs.KeyParameters;
                            else
                                MyTemp = MyUniverse.MySS.Inputs.KeyParameters;
                            MyDeCompileLine(MyTemp);
                            // todo this needs to remove all of the mymsgbox stuff below the exit select
                            break;
                        }

                        switch (MyMsgCtr(1211, "Import", MyUniverse.MySS.Inputs.LineNumberIn.ToString(), MyUniverse.MySS.Inputs.KeyWord, MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.MySS.Inputs.LineNumberIn.ToString(), "Not known command", "", "", "", ""))
                        {
                        case Constants.vbNo:
                        {
                            break;
                        }

                        case Constants.vbOK:
                        case Constants.vbYes:
                        {
                            MyMakeArraySizesBigger();
                            FlowChart_TableCode(TopOfFile("FlowChart"), "/error");
                            FlowChart_Table_DataType(TopOfFile("FlowChart"), MyUniverse.MySS.Inputs.KeyLineOrFile);
                            SortALLiSAM();
                            break;
                        }

                        case Constants.vbCancel:
                        {
                            Init();
                            return "";
                        }

                        default:
                        {
                            Abug(246, "Invalid inputs to program", MyUniverse.MySS.Inputs.KeyWord, MyUniverse.MySS.Inputs.KeyWord);
                            break;
                        }
                        }
                        FindingMyBugs(10); // hack Least amount of checking here 'hack
                        break;
                    }
                }
            }
            return ""; // nothing
        }




        // Routine This reads in an file with all of the information for a FlowChart & symbol.
        void Import(string InputFileName) // Yes I know its spelled Import, but I did not want to confuse it between the two
        {
            string MyCompleteFileText;
            MyUniverse.SysGen.DontAskToAdd = true;
            // Start off with junk
            MyUniverse.MySS = FillImportLine();

            ShowAllForms(ShowScreen1, HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1);
            if (FileSystem.Dir(InputFileName) == "")
                Abug(999, "The file name ", InputFileName, "Could not be found");
            using (System.IO.TextReader reader = System.IO.File.OpenText(InputFileName))
            {
                MyCompleteFileText = ""; // Used to get through the first time only
                do
                {
                    if (Strings.Len(MyCompleteFileText) < 100)
                        MyCompleteFileText += reader.ReadToEnd();
                    MyMakeArraySizesBigger();
                    DisplayMyStatus("Importing:line # " + MyUniverse.MySS.Inputs.LineNumberIn + " : " + MyUniverse.MySS.Inputs.KeyParameters);
                    MyCompleteFileText = ImportLineOrFile(MyCompleteFileText);
                } while (MyCompleteFileText != null)// add to this text if less than 100 characters long
                    ;
            }
            SortALLiSAM();
            ShowAllForms(ShowScreen1, HideScreen1, HideScreen1, ShowScreen1, HideScreen1, HideScreen1);
            MyUniverse.SysGen.DontAskToAdd = false;
            // FindingMyBugs(10) 'hack Least amount of checking here
            PaintAll(FlowChartScreen.PictureBox1, 1, TopOfFile("FlowChart")); // 20200709
            DisplayMyStatus("Finished Importing.  Number of lines =" + MyUniverse.MySS.Inputs.LineNumberIn);
        }

        MyLineStructure MyFlowChartPathLine(long IndexFlowChart)
        {
            MyFlowChartPathLine = default(MyLineStructure);
            MyFlowChartPathLine.a.Named.PathName = FlowChart_TablePathName(IndexFlowChart);
            MyFlowChartPathLine.b.Named.PathName = FlowChart_TablePathName(IndexFlowChart);
            MyFlowChartPathLine.a.Xx = FlowChart_TableX1(IndexFlowChart);
            MyFlowChartPathLine.a.Yy = FlowChart_TableY1(IndexFlowChart);
            MyFlowChartPathLine.b.Xx = FlowChart_TableX2(IndexFlowChart);
            MyFlowChartPathLine.b.Yy = FlowChart_TableY2(IndexFlowChart);
        }

        // A line (distance) between two record points
        //   Shared Function MyLineFlowChart(IndexFlowChart1   As long, IndexFlowChart2   As long) As MyLineStructure
        // MyLine2 = Nothing
        // MyLine2.a.Xx = FlowChart_TableX1(IndexFlowChart1  )
        // MyLine2.a.Yy = FlowChart_TableY1(IndexFlowChart1  )
        // MyLine2.b.Xx = FlowChart_TableX1(IndexFlowChart2  )
        // MyLine2.b.Yy = FlowChart_TableY1(IndexFlowChart2  )
        // End Function


        // A line (distance) between two record points
        MyLineStructure MyLine1(MyPointStructure aXY, MyPointStructure bXY)
        {
            MyLine1 = default(MyLineStructure);
            MyLine1.a.Xx = aXY.Xx;
            MyLine1.a.Yy = aXY.Yy;
            MyLine1.b.Xx = bXY.Xx;
            MyLine1.b.Yy = bXY.Yy;
            return MyLine1;
        }

        MyLineStructure MyLine1(long X1, long Y1, long X2, long Y2)
        {
            MyLine1 = default(MyLineStructure);
            MyLine1.a.Xx = X1;
            MyLine1.a.Yy = Y1;
            MyLine1.b.Xx = X2;
            MyLine1.b.Yy = Y2;
        }


        // a line in one record
        MyLineStructure MyLine1(long IndexFlowChart)
        {
            MyLine1 = default(MyLineStructure);
            MyLine1.a.Xx = FlowChart_TableX1(IndexFlowChart);
            MyLine1.a.Yy = FlowChart_TableY1(IndexFlowChart);
            MyLine1.b.Xx = FlowChart_TableX2(IndexFlowChart);
            MyLine1.b.Yy = FlowChart_TableY2(IndexFlowChart);
        }
        MyLineStructure MyLine2(long IndexFlowChart)
        {
            MyLine2 = default(MyLineStructure);
            MyLine2.a.Xx = FlowChart_TableX1(IndexFlowChart);
            MyLine2.a.Yy = FlowChart_TableY1(IndexFlowChart);
            MyLine2.b.Xx = FlowChart_TableX2(IndexFlowChart);
            MyLine2.b.Yy = FlowChart_TableY2(IndexFlowChart);
        }
        MyLineStructure MyLineS(long IndexFlowChart1, long IndexFlowChart2, long WhichOne)
        {
            MyLineS = default(MyLineStructure);
            switch (WhichOne)
            {
            case 1:
            {
                MyLineS.a.Xx = FlowChart_TableX1(IndexFlowChart1); MyLineS.a.Yy = FlowChart_TableY1(IndexFlowChart1);
                MyLineS.b.Xx = FlowChart_TableX2(IndexFlowChart2); MyLineS.b.Yy = FlowChart_TableY2(IndexFlowChart2);
                break;
            }

            case 2:
            {
                MyLineS.a.Xx = FlowChart_TableX1(IndexFlowChart1); MyLineS.a.Yy = FlowChart_TableY1(IndexFlowChart1);
                MyLineS.b.Xx = FlowChart_TableX2(IndexFlowChart2); MyLineS.b.Yy = FlowChart_TableY2(IndexFlowChart2);
                break;
            }

            case 3:
            {
                MyLineS.a.Xx = FlowChart_TableX1(IndexFlowChart1); MyLineS.a.Yy = FlowChart_TableY1(IndexFlowChart1);
                MyLineS.b.Xx = FlowChart_TableX2(IndexFlowChart2); MyLineS.b.Yy = FlowChart_TableY2(IndexFlowChart2);
                break;
            }

            case 4:
            {
                MyLineS.a.Xx = FlowChart_TableX1(IndexFlowChart1); MyLineS.a.Yy = FlowChart_TableY1(IndexFlowChart1);
                MyLineS.b.Xx = FlowChart_TableX2(IndexFlowChart2); MyLineS.b.Yy = FlowChart_TableY2(IndexFlowChart2);
                break;
            }

            default:
            {
                MyLineS.a.Xx = FlowChart_TableX1(IndexFlowChart1); MyLineS.a.Yy = FlowChart_TableY1(IndexFlowChart1);
                MyLineS.b.Xx = FlowChart_TableX2(IndexFlowChart2); MyLineS.b.Yy = FlowChart_TableY2(IndexFlowChart2);
                break;
            }
            }
        }


        // Routine converts from two numbers (x, y) to structure xy
        MyPointStructure MyPoint1XY(long X, long Y)
        {
            MyPoint1XY = default(MyPointStructure);
            MyPoint1XY.Xx = X;
            MyPoint1XY.Yy = Y;
        }

        MyPointStructure MyPoint1XY(long IndexFlowChart)
        {
            MyLineStructure XYZ;
            XYZ = default(MyLineStructure);
            XYZ = MySnapindex(IndexFlowChart); // , FlowChart_TableX1(IndexFlowChart))
            // MyPoint1XY.Yy = MySnap(IndexFlowChart, FlowChart_TableY1(IndexFlowChart))
            return XYZ.a;
        }

        MyPointStructure MyPoint1_1XY(long IndexFlowChart)
        {
            MyLineStructure XYZ;
            XYZ = MySnapindex(IndexFlowChart);
            return XYZ.a;
        }

        MyPointStructure MyPoint2XY(long X, long Y)
        {
            MyLineStructure XYZ;
            XYZ = MySnapXYXY("/path", X, Y, X, Y);
            return XYZ.a;
        }

        MyPointStructure MyPoint2_1XY(long IndexFlowChart)
        {
            MyLineStructure XYZ;
            XYZ = MySnapindex(IndexFlowChart);
            return XYZ.a;
        }

        MyPointStructure MyPoint2_2XY(long IndexFlowChart)
        {
            MyLineStructure XYZ;
            XYZ = MySnapindex(IndexFlowChart);
            return XYZ.a;
        }

        // Routine 
        string MyFixLine(string Astring)
        {
            long Index;
            MyFixLine = Astring;
            for (Index = 1; Index <= Strings.Len(MyFixLine) - 1; Index++)
            {
                if (Strings.Mid(MyFixLine, Index, 1) == FD | Strings.Mid(MyFixLine, Index, 1) == FD)
                {
                    if (Strings.Mid(MyFixLine, Index + 1, 1) == FD | Strings.Mid(MyFixLine, Index + 1, 1) == FD)
                        MyFixLine = Strings.Left(MyFixLine, Index) + " " + Strings.Mid(MyFixLine, Index + 1, Strings.Len(MyFixLine));
                }

                if (Strings.Mid(MyFixLine, Index, 1) == FD | Strings.Mid(MyFixLine, Index, 1) == FD)
                {
                    if (Strings.Mid(MyFixLine, Index + 1, 1) == Constants.vbCr)
                        MyFixLine = Strings.Left(MyFixLine, Index) + " " + Strings.Mid(MyFixLine, Index + 1, Strings.Len(MyFixLine));
                }

                if (Strings.Mid(MyFixLine, Index, 1) == FD | Strings.Mid(MyFixLine, Index, 1) == FD)
                {
                    if (Strings.Mid(MyFixLine, Index + 1, 1) == Constants.vbLf)
                        MyFixLine = Strings.Left(MyFixLine, Index) + " " + Strings.Mid(MyFixLine, Index + 1, Strings.Len(MyFixLine));
                }

                if (Strings.Mid(MyFixLine, Index, 1) == FD | Strings.Mid(MyFixLine, Index, 1) == FD)
                {
                    if (Strings.Mid(MyFixLine, Index + 1, 1) == "/")
                        MyFixLine = Strings.Left(MyFixLine, Index) + " " + Strings.Mid(MyFixLine, Index + 1, Strings.Len(MyFixLine));
                }
            }
        }




        // This is used to fill/refill the list of currently available lib symbols 
        void GetAllSymbolNames(string SelectedSymbolName)
        {
            long Index;
            int IndexDropDown;
            long IndexColor;
            string ColorName;
            ColorName = "Black"; // only to avoid a warning message.


            SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Clear();
            FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Clear();

            // Adding all symbol names to the symbol select list(S). (only button that should be on two screens)
            for (Index = 1; Index <= TopOfFile("named"); Index++)
            {
                if (Information.IsNothing(Named_TableSymbolName(Index)))
                {
                }
                else
                    AddSymbolToDropDown(Named_TableSymbolName(Index));
            }


            // For IndexDropDown = 0 To SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1
            // If SelectedSymbolName = SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text Then
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);
            SelectInToolStripDropDownButton(FlowChartScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);
            // FindingMyBugs(100)
            // Exit For
            // End If
            // Next

            // need to make the datatype selected from something
            SymbolScreen.ToolStripDropDownDataType.DropDownItems.Clear();
            for (Index = 1; Index <= TopOfFile("DataType"); Index++)
            {
                if (Information.IsNothing(DataType_TableName(Index)))
                    Abug(247, "No Color Name at " + Index, "", "");
                else
                    SymbolScreen.ToolStripDropDownDataType.DropDownItems.Add(DataType_TableName(Index));
            }


            SymbolScreen.ToolStripDropDownButtonColor.DropDown.Items.Clear();
            for (Index = 1; Index <= TopOfFile("Color"); Index++)
            {
                IndexColor = Color_Name_iSAM[Index];
                if (IndexColor != constantMyErrorCode)
                {
                    if (Information.IsNothing(Color_TableName(IndexColor)) | Color_TableName(IndexColor) == "")
                        Abug(248, "GetAllSymbolNames() This is an empty color name", Index, IndexColor);
                    else
                        SymbolScreen.ToolStripDropDownButtonColor.DropDown.Items.Add(Color_TableName(IndexColor));
                }
                else
                    Abug(249, "Color not found ", Color_TableName(IndexColor), "While using the color table to find the color table");
            }

            for (IndexDropDown = 0; IndexDropDown <= SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Count - 1; IndexDropDown++)
            {
                if (LCase(Trim(SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Item(IndexDropDown).Text)) == Strings.LCase(Strings.Trim(ColorName)))
                {
                    SymbolScreen.ToolStripDropDownButtonColor.Text = ColorName;
                    MyUniverse.ProgramOptions.SelectedColor = ColorName;
                    break;
                }
            }
        }


        void YouHaveAnErrorMessage(long WhichOne, string WhatIsIt)
        {
            DisplayMyStatus("You have an error message " + WhatIsIt);
        }



        void MoveAllPaths(string Where, MyPointStructure AtX1Y1, MyPointStructure MoveOverXY)
        {
            MyLineStructure AtXY;
            long Index;
            AtXY.a.Xx = AtX1Y1.Xx;
            AtXY.a.Yy = AtX1Y1.Yy;
            for (Index = 1; Index <= TopOfFile("FlowChart"); Index++)
            {
                switch (FlowChart_TableCode(Index))
                {
                case "/path":
                {
                    // Try One End 
                    // Comparing the same code type snap ' this really is a hack, but it works
                    if (DoesPointMatch(MySnapindex(Index).a, MySnapXYXY("/path", AtXY.a.Xx, AtXY.a.Yy, AtXY.b.Xx, AtXY.b.Yy).a) == true)
                    {
                        PaintErase(Where, Index);
                        FlowChart_TableX1(Index, FlowChart_TableX1(Index) + MoveOverXY.Xx);
                        FlowChart_TableY1(Index, FlowChart_TableY1(Index) + MoveOverXY.Yy);
                        PaintAll(Where, Index, Index);
                    }
                    // Try the other end
                    if (DoesPointMatch(MySnapindex(Index).b, MySnapXYXY("/path", AtXY.a.Xx, AtXY.a.Yy, AtXY.b.Xx, AtXY.b.Yy).a) == true)
                    {
                        PaintErase(Where, Index);
                        FlowChart_TableX2(Index, FlowChart_TableX2(Index) + MoveOverXY.Xx);
                        FlowChart_TableY2(Index, FlowChart_TableY2(Index) + MoveOverXY.Yy);
                        PaintAll(Where, Index, Index);
                    }

                    break;
                }
                }
            }
        }



        void MoveSymbolAndAllPaths(string Where, long Index, MyPointStructure MyDistXY)
        {
            // Need to change this to also move any connected paths before moving the symbol
            long IndexPoint;
            MyPointStructure XY;
            long XDist;
            long YDist;

            XDist = MyDistXY.Xx;
            YDist = MyDistXY.Yy;

            IndexPoint = FindInSymbolList(ref FlowChart_TableSymbol_Name(Index));

            if (IndexPoint != constantMyErrorCode)
            {
                IndexPoint += 1; // Skip over the name
                while (IndexPoint < TopOfFile("Symbol") & Symbol_TableCoded_String(IndexPoint) != "/name")
                {
                    switch (Symbol_TableCoded_String(IndexPoint))
                    {
                    case "/point":
                    {
                        XY = MyRotated(Index, IndexPoint);
                        MoveAllPaths(Where, XY, MyDistXY);
                        break;
                    }

                    case "/line":
                    {
                        break;
                    }

                    default:
                    {
                        break;
                    }
                    }

                    IndexPoint += 1; // Skip over the name
                }
            }

            AInfo1(801, "Moving symbol " + Index, MyShowFlowChartRecord(Index), "To " + MyPoint1XY(FlowChart_TableX1(Index) + XDist, FlowChart_TableY1(Index) + YDist).ToString());
            PaintErase(Where, Index);
            FlowChart_TableX1(Index, FlowChart_TableX1(Index) + XDist);
            FlowChart_TableY1(Index, FlowChart_TableY1(Index) + YDist);
            PaintAll(Where, Index, Index);
        }


        MyLineStructure BlockedRectAt(MyLineStructure xy1, MyLineStructure xy2)
        {
            long A, B;
            BlockedRectAt = default(MyLineStructure);
            A = MyMax(xy1.a.Xx, xy1.b.Xx);
            B = MyMax(xy2.a.Xx, xy2.b.Xx);
            BlockedRectAt.a.Xx = MyMin(A, B);

            A = MyMax(xy1.a.Yy, xy1.b.Yy);
            B = MyMax(xy2.a.Yy, xy2.b.Yy);
            BlockedRectAt.a.Xx = MyMin(A, B);

            A = MyMin(xy1.a.Xx, xy1.b.Xx);
            B = MyMin(xy2.a.Xx, xy2.b.Xx);
            BlockedRectAt.a.Xx = MyMax(A, B);

            A = MyMin(xy1.a.Xx, xy1.b.Xx);
            B = MyMin(xy2.a.Xx, xy2.b.Xx);
            BlockedRectAt.a.Xx = MyMax(A, B);
        }



        bool SymbolOnTop(long A, long B)
        {
            long T2;
            if (FlowChart_TableCode(A) != "/use")
                return false;
            if (FlowChart_TableCode(B) != "/use")
                return false;
            // check that they are both symbols, and not a path, because the path might be connected to it.
            T2 = MyDistance(MyPoint1XY(A), MyPoint1_1XY(B));
            MyDoEvents();
            if (T2 < MyUniverse.SysGen.Constants.constantSymbolCenter * 5)
            {
                AInfo(627, "DIstance of " + T2.ToString() + " between symbol centers", MyShowFlowChartRecord(A), MyShowFlowChartRecord(B));
                SymbolOnTop = true;
            }
            else
                SymbolOnTop = false;
        }

        bool PathAboveOrBelow(long aY, long bY1, long bY2)
        {
            if (aY > bY1 & aY > bY2)
                PathAboveOrBelow = false;
            else if (aY < bY1 & aY < bY2)
                PathAboveOrBelow = false;
            else
                PathAboveOrBelow = true;
        }

        bool DoesFlowChartPathMatch(long IndexFlowChart1, long IndexFlowChart2)
        {
            return DoesPathMeet(MyLine1(IndexFlowChart1), MyLine2(IndexFlowChart2));
        }


        bool DoesPointMatch(MyPointStructure A, MyPointStructure B)
        {
            if (A.Xx == B.Xx & A.Yy == B.Yy)
                return true;
            return false;
        }

        bool DoesPathMeet(MyLineStructure A, MyLineStructure B)
        {
            if (DoesPointMatch(A.a, B.a) == true)
                return true;
            if (DoesPointMatch(A.a, B.b) == true)
                return true;
            if (DoesPointMatch(A.b, B.a) == true)
                return true;
            if (DoesPointMatch(A.b, B.b) == true)
                return true;
            return false;
        }



        bool PathOnTop(MyLineStructure A, MyLineStructure B) // Is the Path on top of each other
        {
            // I am only checking if the distance is close to each other, not if they lines are on top of each other.
            // On top of each other is only if theyt are up/down and/or right/left - angle lines should be change 
            // (if the option is checked) other wise no checking
            long T1, T2, T3, T4, Temp;
            // If this option is chosen
            if (MyOptionTest(14) == true)
            {
                if (DoesPathMeet(A, B) == true)
                {
                    if (PathAboveOrBelow(A.a.Xx, B.a.Xx, B.b.Xx) == true)
                    {
                        PathOnTop = true; return;
                    }
                    if (PathAboveOrBelow(A.a.Yy, B.a.Yy, B.b.Yy) == true)
                    {
                        PathOnTop = true; return;
                    }
                    if (PathAboveOrBelow(A.b.Xx, B.a.Xx, B.b.Xx) == true)
                    {
                        PathOnTop = true; return;
                    }
                    if (PathAboveOrBelow(A.b.Yy, B.a.Yy, B.b.Yy) == true)
                    {
                        PathOnTop = true; return;
                    }
                }
            }
            else
            {
                T1 = MyDistance(MyPoint1XY(A.a.Xx, A.a.Yy), MyPoint2XY(B.a.Xx, B.a.Yy)); // a1-b1
                T2 = MyDistance(MyPoint1XY(A.a.Xx, A.a.Yy), MyPoint2XY(B.b.Xx, B.b.Yy)); // a1-b2
                T3 = MyDistance(MyPoint1XY(A.b.Xx, A.b.Yy), MyPoint2XY(B.a.Xx, B.a.Yy)); // a2-b1
                T4 = MyDistance(MyPoint1XY(A.b.Xx, A.b.Yy), MyPoint2XY(B.b.Xx, B.b.Yy)); // a2-b2
                Temp = T1;
                if (Temp < T2)
                    Temp = T2;
                if (Temp < T3)
                    Temp = T3;
                if (Temp < T4)
                    Temp = T4;
                if (Temp < MyUniverse.SysGen.Constants.constantDistanceBetweenControls)
                {
                    PathOnTop = true; return;
                }
            }
            PathOnTop = false;
        }



        void CheckColorTable()
        {
            long IndexColor;
            long JdexColor;
            long I;
            for (I = 1; I <= TopOfFile("Color") - 1; I++)
            {
                MyDoEvents();
                IndexColor = Color_Name_iSAM[I];
                JdexColor = Color_Name_iSAM[I + 1];
                if (Strings.LCase(Strings.Trim(Color_TableName(IndexColor))) == Strings.LCase(Strings.Trim(Color_TableName(JdexColor))))
                {
                    YouHaveAnErrorMessage(1, "dublicate color named " + Strings.LCase(Color_TableName(IndexColor)) + " and " + Strings.LCase(Color_TableName(JdexColor)));
                    Color_TableName(IndexColor, Color_TableName(IndexColor) + "_Duplicate_Copy" + I);
                }
            }
        }

        void CheckDataType_Table()
        {
            long Index;
            long jdex;
            for (Index = 1; Index <= TopOfFile("DataType"); Index++)
            {
                MyDoEvents();
                for (jdex = Index + 1; jdex <= TopOfFile("DataType"); jdex++)
                {
                    MyDoEvents();
                    if (Strings.LCase(DataType_TableName(Index)) == Strings.LCase(DataType_TableName(jdex)))
                    {
                        YouHaveAnErrorMessage(1, "dublicate data type named " + Strings.LCase(DataType_TableName(Index)) + " and " + Strings.LCase(DataType_TableName(jdex)));
                        DataType_TableName(Index, DataType_TableName(Index) + "_Copy");
                    }
                }
            }
        }



        void CheckNamed_Table()
        {
            long IsamIndex;
            long jdex;
            for (IsamIndex = 1; IsamIndex <= TopOfFile("named"); IsamIndex++)
            {
                MyDoEvents();
                jdex = IsamIndex + 1;
                MyDoEvents();
                if (Strings.LCase(Named_TableSymbolName(Named_FileSymbolName_iSAM[IsamIndex])) == Strings.LCase(Named_TableSymbolName(Named_FileSymbolName_iSAM[jdex])))
                {
                    YouHaveAnErrorMessage(1, "dublicate Symbol named " + Strings.LCase(Named_TableSymbolName(Named_FileSymbolName_iSAM[IsamIndex])) + " and " + Strings.LCase(Named_TableSymbolName(Named_FileSymbolName_iSAM[jdex])));
                    Named_TableSymbolName(jdex, Named_TableSymbolName(Named_FileSymbolName_iSAM[jdex]) + "_Copy");
                }
            }
        }


        void MyCheckForMovingPathEnds(string Where, long index, MyPointStructure xy)
        {
            MyPointStructure XY1XY = default(MyPointStructure);
            if (Strings.LCase(FlowChart_TableCode(index)) != "/path")
                return; // not a path to modify, program should never reach here
            XY1XY.Xx = FlowChart_TableX1(index);
            XY1XY.Yy = FlowChart_TableY1(index);
            if (MyDistance(XY1XY, xy) <= MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
            {
                // MyStatus("Changing " & FlowChart_TableX1(index) & " To " & XY.xx & " and also " & FlowChart_TableY1(index) & " To " & xy.Y)
                PaintErase(Where, index); // get rid of where it was and
                FlowChart_TableX1(index, xy.Xx);
                FlowChart_TableY1(index, xy.Yy);
                PaintAll(Where, index, index); // repaint it where its going to
            }


            XY1XY.Xx = FlowChart_TableX2(index);
            XY1XY.Yy = FlowChart_TableY2(index);
            if (MyDistance(XY1XY, xy) <= MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
            {
                // MyStatus("Changing " & FlowChart_TableX2_Rotation(index) & " To " & XY.xx & " and also " & FlowChart_TableY2_Option(index) & " To " & xy.yy)
                PaintErase(Where, index); // get rid of where it was and
                FlowChart_TableX2(index, xy.Xx);
                FlowChart_TableY2(index, xy.Yy);
                PaintAll(Where, index, index); // repaint it where its going to
            }
        }


        void CheckAllPaths(string Where)
        {
            bool Flag;
            MyRECTStructure MyXY1;
            MyPointStructure MyXY2;
            long FlowChartUseIndex, FlowChartPathIndex, FLowChartCheckingPathIndex;

            MyXY1 = default(MyRECTStructure);
            MyXY2 = default(MyPointStructure);


            for (FlowChartUseIndex = 1; FlowChartUseIndex <= TopOfFile("FlowChart"); FlowChartUseIndex++)
            {
                MyDoEvents();
                Flag = false;
                MyXY1.MyWorldXY.a.Xx = FlowChart_TableX1(FlowChartUseIndex);
                MyXY1.MyWorldXY.a.Yy = FlowChart_TableY1(FlowChartUseIndex);
                MyXY1.MyWorldXY.b.Xx = FlowChart_TableX2(FlowChartUseIndex);
                MyXY1.MyWorldXY.b.Yy = FlowChart_TableY2(FlowChartUseIndex);
                MyDoEvents();
                // MyMsgCtr(1015, "CheckAllPaths", FlowChartUseIndex.ToString, MyXY1.MyWorldXY.a.Xx.ToString, MyXY1.MyWorldXY.a.Yy.ToString, MyXY1.MyWorldXY.b.Xx.ToString, MyXY1.MyWorldXY.b.Yy.ToString, FlowChart_TablePathName(FlowChartUseIndex), "", "", "")
                switch (Strings.LCase(FlowChart_TableCode(FlowChartUseIndex)))
                {
                    case "" // ignore if nothing also
                        :
                    {
                        break;
                    }

                    case "/path":
                    case "/use":
                    {
                        // We are looking at a symbol points connecting
                        for (FlowChartPathIndex = FlowChartUseIndex + 1; FlowChartPathIndex <= TopOfFile("FlowChart"); FlowChartPathIndex++) // Looking only for /use statements
                        {
                            MyDoEvents();
                            PaintErase(Where, FlowChartPathIndex);
                            switch (Strings.LCase(FlowChart_TableCode(FlowChartPathIndex)))
                            {
                            case "/use":
                            {
                                FLowChartCheckingPathIndex = FindInSymbolList(ref FlowChart_TableSymbol_Name(FlowChartPathIndex));
                                if (FLowChartCheckingPathIndex == constantMyErrorCode)
                                {
                                    Abug(251, FlowChart_TableSymbol_Name(FlowChartPathIndex), 0, 0);
                                    MakeErrorAt(Where, MyXY1.MyInputScreenXY.a, "There is no symbol defined in the libaray with the name >" + FlowChart_TableSymbol_Name(FlowChartPathIndex) + "< ");
                                    MakeErrorAt(Where, MyXY1.MyInputScreenXY.b, "There is no symbol defined in the libaray with the name >" + FlowChart_TableSymbol_Name(FlowChartPathIndex) + "< ");
                                }
                                else
                                {
                                    FLowChartCheckingPathIndex += 1; // skip over the name of the symbol
                                                                     // MyStatus("Comparing " & Index & " : " & FlowChartPathIndex & " : " & FLowChartCheckingPathIndex)
                                    while (FLowChartCheckingPathIndex < TopOfFile("Symbol"))  // Till the next name
                                    {
                                        MyDoEvents();
                                        // MyStatus("Comparing index " & Index & " with index " & FlowChartPathIndex & " with index  " & FLowChartCheckingPathIndex)
                                        switch (Symbol_TableCoded_String(FLowChartCheckingPathIndex))
                                        {
                                        case "/name":
                                        {
                                            break; // End of the symbol (starting of the next symbol)
                                            break;
                                        }

                                        case "/line"  // Line Start so ignore - cause lines have no meaning
                                            :
                                        {
                                            break;
                                        }

                                        case "/point"  // See if the path matches the point
                                            :
                                        {
                                            MyXY2 = MyRotated(FLowChartCheckingPathIndex, FlowChartPathIndex);
                                            // Checking of point points to here.
                                            if (MyDistance(MyXY2, MyXY1.MyWorldXY.a) < MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
                                            {
                                                Abug(252, Symbol_FileSymbolName[FLowChartCheckingPathIndex], 0, MyDistance(MyXY2, MyXY1.MyWorldXY.a));
                                                MyCheckForMovingPathEnds(Where, FlowChartPathIndex, MyXY2);
                                                // ?Flag = True
                                                break;
                                            }
                                            if (MyDistance(MyXY2, MyXY1.MyWorldXY.b) < MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
                                            {
                                                Abug(253, Symbol_FileSymbolName[FLowChartCheckingPathIndex], 0, MyDistance(MyXY2, MyXY1.MyWorldXY.b));
                                                MyCheckForMovingPathEnds(Where, FlowChartPathIndex, MyXY2);
                                                // ?Flag = True
                                                break;
                                            }

                                            break;
                                        }

                                        case "/delete":
                                        {
                                            break;
                                        }

                                        case "/error":
                                        {
                                            break;
                                        }

                                        default:
                                        {
                                            break;
                                        }
                                        } // end of the symbols
                                        FLowChartCheckingPathIndex += 1; // Should I ?
                                    } // next record in the symbols
                                } // Testing if this is a /use

                                break;
                            }

                            case "/path":
                            {
                                // check if two paths are connected
                                // FlowChartPathIndex = Index
                                if (Strings.LCase(FlowChart_TableCode(FlowChartUseIndex)) == "/path")
                                {
                                    for (FLowChartCheckingPathIndex = FlowChartPathIndex; FLowChartCheckingPathIndex <= TopOfFile("FlowChart"); FLowChartCheckingPathIndex++)
                                    {
                                        MyDoEvents();
                                        if (FLowChartCheckingPathIndex != FlowChartUseIndex)
                                        {
                                            if (Strings.LCase(FlowChart_TableCode(FLowChartCheckingPathIndex)) == "/path")
                                            {
                                                // xy1 to xy2
                                                if (MyDistance(MyPoint1_1XY(FlowChartUseIndex), MyPoint2_2XY(FLowChartCheckingPathIndex)) == 0)
                                                {
                                                    Abug(254, "CheckAllPaths():", FlowChartUseIndex, FLowChartCheckingPathIndex);
                                                    // We are matching two paths together so Ignore ifit goes to another.
                                                    // **** We need to check that the names (name of the variable) are the same for the two paths (or can make them the same)
                                                    MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint2_2XY(FLowChartCheckingPathIndex));
                                                    Flag = true;
                                                }
                                                // xy2 to xy1
                                                if (MyDistance(MyPoint2_1XY(FlowChartUseIndex), MyPoint1XY(FLowChartCheckingPathIndex)) == 0)
                                                {
                                                    Abug(255, "CheckAllPaths", FlowChartUseIndex, FLowChartCheckingPathIndex);
                                                    MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint1XY(FLowChartCheckingPathIndex));
                                                    Flag = true;
                                                }

                                                if (MyDistance(MyPoint2_1XY(FlowChartUseIndex), MyPoint2_2XY(FLowChartCheckingPathIndex)) == 0)
                                                {
                                                    Abug(256, "CheckAllPaths():", MyShowFlowChartRecord(FlowChartUseIndex), MyShowFlowChartRecord(FLowChartCheckingPathIndex));
                                                    MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint2_2XY(FLowChartCheckingPathIndex));
                                                    Flag = true;
                                                }
                                                if (MyDistance(MyPoint2_1XY(FlowChartUseIndex), MyPoint2_2XY(FLowChartCheckingPathIndex)) == 0)
                                                {
                                                    Abug(257, "CheckAllPaths():", MyShowFlowChartRecord(FlowChartUseIndex), MyShowFlowChartRecord(FLowChartCheckingPathIndex));
                                                    MyCheckForMovingPathEnds(Where, FlowChartUseIndex, MyPoint2_2XY(FLowChartCheckingPathIndex));
                                                    Flag = true;
                                                }
                                            }
                                        }
                                    }
                                }

                                break;
                            }

                            case "/constant":
                            {
                                Flag = true;
                                break;
                            }

                            case "/delete":
                            {
                                Flag = true;
                                break;
                            }

                            case "/error":
                            {
                                Flag = true;
                                break;
                            }

                            default:
                            {
                                break;
                            }
                            }
                            if (Flag == false)
                            {
                                Abug(258, "Path Goes Nowhere", MyShowFlowChartRecord(FlowChartUseIndex), MyShowFlowChartRecord(FLowChartCheckingPathIndex)); // hack
                                MakeErrorAt(Where, MyPoint1_1XY(FlowChartUseIndex), "Path goes no where");
                            }
                        }

                        break;
                    }
                }
            } // Index
        }





        long CheckAllSymbolsOnFlowChart(string Where)
        {
            long IndexFlowChart, Jdex;
            MyPointStructure MyXY;
            MyXY = default(MyPointStructure);
            CheckAllSymbolsOnFlowChart = 0;
            for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
            {
                MyDoEvents();
                for (Jdex = IndexFlowChart + 1; Jdex <= TopOfFile("FlowChart"); Jdex++)
                {
                    MyDoEvents();
                    if (Strings.LCase(FlowChart_TableCode(Jdex)) == "/use")
                    {
                        if (MyOptionTest(15) == true)
                        {
                            while (SymbolOnTop(IndexFlowChart, Jdex) == true)
                            {
                                MyDoEvents();
                                MoveSymbolAndAllPaths(Where, Jdex, MyPoint1XY(MyUniverse.SysGen.Snaps.MySymbolSnap, 0));
                                MyDoEvents();
                                // PaintEach(Where, MyPoint1XY(FlowChart_TableX1(IndexFlowChart ), FlowChart_TableY1(IndexFlowChart )), FlowChart_TablePathSymbol_Name(Index))
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 1), "red");
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 2), "green");
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 3), "orange");
                                MyDrawLineXY_XY(Where, MyLineS(IndexFlowChart, Jdex, 4), "purple");
                            }
                        }
                        else if (SymbolOnTop(IndexFlowChart, Jdex) == true)
                        {
                            MyXY.Xx = FlowChart_TableX1(IndexFlowChart);
                            MyXY.Yy = FlowChart_TableY1(IndexFlowChart);
                            CheckAllSymbolsOnFlowChart += 1;
                            MakeErrorAt(Where, MyXY, "Symbol Overlaps " + MyShowFlowChartRecord(IndexFlowChart) + " with " + MyShowFlowChartRecord(Jdex));
                        }
                    }

                    if (Strings.LCase(FlowChart_TableCode(IndexFlowChart)) == "/use")
                        CheckAllSymbolsOnFlowChart += CheckSymbolByNamedIndex(IndexFlowChart);
                }
            }
        }


        long CheckSymbolByNamedIndex(long IndexNamed)
        {
            long IndexSymbol;
            CheckSymbolByNamedIndex = constantMyErrorCode;

            // IndexNamed = FindIndexIniSAMTable("Named", "DoNotAdd", Named_FileSymbolName, Named_FileSymbolName_iSAM, FlowChart_TablePathSymbol_Name(IndexFlowChart ))
            if (IndexNamed == constantMyErrorCode)
                return constantMyErrorCode;

            IndexSymbol = GetSelfCorrectingIndexes(Named_TableSymbolName(IndexNamed));

            if (IndexSymbol != constantMyErrorCode)
            {
                IndexSymbol += 1; // go past the name 
                while (IndexSymbol <= TopOfFile("named"))
                {
                    // First check that the name of the point is in the program text (with " & MyUniverse.SysGen.Constants.RMStart & "
                    switch (Strings.LCase(Symbol_TableCoded_String(IndexSymbol)))
                    {
                    case "/name":
                    {
                        return CheckSymbolByNamedIndex; // hack Least amount of checking here 'hack
                    }

                    case "/line" // ignore all lines
                        :
                    {
                        break;
                    }

                    case "/error" // ignore all errors in the symbol (for now)
                        :
                    {
                        AInfo(802, "Ignore /error ", "", "");
                        break;
                    }

                    case "/point" // Check points
                        :
                    {

                        // hack Is this instr right?  or should it be the other way around?

                        if (Strings.InStr(Named_TableSintax(IndexNamed), NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))) == 0)
                        {
                            CheckSymbolByNamedIndex += 1;
                            AInfo1(729, "A Point name " + HighLight(Symbol_Table_NameOfPoint(IndexSymbol)) + " is not in the syntax", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                            Abug(261, "A See error 729 also : Index = " + IndexNamed.ToString() + ":" + IndexSymbol.ToString(), MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                            Abug(262, "A Point name does not syntax code text ", HighLight(Named_TableSintax(IndexNamed)), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)));
                        }

                        if (Strings.InStr(Named_TableMicroCodeText(IndexNamed), NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))) == 0)
                        {
                            CheckSymbolByNamedIndex += 1;
                            AInfo1(729, "B Point name " + HighLight(Symbol_Table_NameOfPoint(IndexSymbol)) + " is not in the micro text ", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                            Abug(261, "B See error 729B also : Index = " + IndexNamed.ToString() + ":" + IndexSymbol.ToString(), MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                            Abug(262, "B Point name does not match micro code ", HighLight(Named_TableSintax(IndexNamed)), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)));
                        }

                        break;
                    }

                    case "/unknown":
                    {
                        AInfo1(731, "Ignoreing unknown code", MyShowSymbolGraphic(IndexSymbol), Symbol_TableCoded_String(IndexSymbol));
                        Dump3(620, "Unknown code in the symbol graphics " + Symbol_TableCoded_String(IndexSymbol));
                        break;
                    }

                    default:
                    {
                        CheckSymbolByNamedIndex += 1;
                        Interaction.MsgBox(MyShowSymbolGraphic(IndexSymbol), MsgBoxStyle.Information, "Error in Symbolo construction unknown code");
                        break;
                    }
                    }
                    IndexSymbol += 1;
                }
            }
            return CheckSymbolByNamedIndex; // hack Least amount of checking here 'hack
        }


        void CheckThisLong(long MyBugNumber, long[] MyArrayLong, long iSAM[], long Index)
        {
            // CheckThisLong = false
            if (Index <= 0)
                // Abug(263, "CheckThisLong(#1):", 0, 1390)
                // MyMsgCtr(1390, "CheckThisLong", "", "", "", "", "", "", "", "", MyBugNumber.ToString)
                return;
            if (Index > Information.UBound(MyArrayLong) - 1)
                // Abug(264, "CheckThisLong(#2):", 0, 1391)
                // MyMsgCtr(1391, "CheckThisLong", "", "", "", "", "", "", "", "", MyBugNumber.ToString)
                return;
            if (Index > Information.UBound(iSAM) - 1)
                // Abug(265, "CheckThisLong(#3):", 0, 1392)
                // MyMsgCtr(1392, "CheckThisLong", "", "", "", "", "", "", "", "", MyBugNumber.ToString)
                return;
            // Need to check if at the end of the MyArray here (as in the  string MyArray check
            if (iSAM[Index] < 1)
                // MyMsgCtr(1380, "CheckThisLong", "", iSAM(Index).ToString, Index.ToString, "", "", "", "", "".ToString, MyBugNumber.ToString)
                return;
            if (iSAM[Index] >= Information.UBound(MyArrayLong) - 1)
                // MyMsgCtr(1387, "CheckThisLong", "", iSAM(Index).ToString, Index.ToString, "", "", "", "", "", MyBugNumber.ToString)
                return;
        }


        void CheckThisStringArray(long MyBugNumber, string MyArray[], long iSAM[], long Index)
        {
            // CheckThis = false
            if (Index <= 0)
                // Abug(268, "CheckThis(#1):", 0, 1390)
                // MyMsgCtr(1390, "CheckThis", "", "", "", "", "", "", "", "", MyBugNumber.ToString)
                return;
            if (Index > Information.UBound(MyArray) - 1)
                // Abug(269, "CheckThis", 0, 1393)
                // MyMsgCtr(1393, "CheckThis", "", "", "", "", "", "", "", "", MyBugNumber.ToString)
                return;
            if (Index > Information.UBound(iSAM) - 1)
                // Abug(271, "CheckThis", 0, 1394)
                // MyMsgCtr(1394, "CheckThis", "", "", "", "", "", "", "", "", MyBugNumber.ToString)
                return;

            // This check is no longer valid, because I split the symbol name and path name into two arrays (uses only one or the other now.
            if (Information.IsNothing(MyArray[Index]))
                return;// Because iSAM checks are meaningless after
            if (iSAM[Index] < 1)
                return;
            if (iSAM[Index] >= Information.UBound(MyArray) - 1)
                // Abug(273, "CheckThis", 0, 1389)
                // MyMsgCtr(1389, "CheckThis", "", iSAM(Index).ToString, Index.ToString, "", "", "", "CheckThis", "", MyBugNumber.ToString)
                return;
        }


        // This is to check everything (It should be a thread that is always running on new/moved/delete)
        void CheckAll()
        {
            MyDoEvents();
            // First check for two named symbols in the named/DataType/COlor table
            CheckColorTable();
            MyDoEvents();
            CheckDataType_Table();
            MyDoEvents();
            CheckNamed_Table();
            MyDoEvents();
            CheckAllPaths(FlowChartScreen.PictureBox1);
            MyDoEvents();
            CheckAllSymbolsOnFlowChart(FlowChartScreen.PictureBox1);
            MyDoEvents();
        }

        void MyRemoveAllUnusedSymbols()
        {
            long Index;
            long Jdex;
            // Need to Add to make sure that every /name in symbols has a name in Named_Table also
            ShowSorts("Named", MySortStringArray("Named", ref Named_FileSintax, ref Named_FileSintax_Isam));
            ShowSorts("Named", MySortStringArray("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM)); // make sure that the named symbol table is in order for this to work.
            for (Index = 1; Index <= TopOfFile("named"); Index++)
            {
                if (Strings.LCase(Named_TableSymbolName(Index)) == Strings.LCase(Named_TableSymbolName(Index + 1)))
                {
                    if (Named_TableSymbolName(Index) != "")
                    {
                        MyReMoveSymbol(Named_TableSymbolName(Index)); // From both named and symbol
                        MyReMoveNamed(Index);
                    }
                }
            }

            for (Index = 1; Index <= TopOfFile("named"); Index++)
            {
                if (Strings.Len(Named_TableSymbolName(Index)) == 0)
                    Abug(274, "MyRemoveAllUnusedSymbols():Null Symbol Name", 0, 0);
                else
                {
                    CheckForAnySortNeeded("", 244);
                    Jdex = FindIndexIniSAMTable("FlowChart", "DoNotAdd", ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, Named_TableSymbolName(Index));
                    CheckForAnySortNeeded("", 245);
                    // If Jdex > 1 Then
                    // MyMsgCtr(1366, "MyRemoveAllUnusedSymbols",
                    // "39 Names : ",
                    // Named_TableSymbolName(Index),
                    // Named_TableSymbolName(Named_FileSymbolName_iSAM(Jdex - 1)),
                    // Named_TableSymbolName(Named_FileSymbolName_iSAM(Jdex)),
                    // Named_TableSymbolName(Named_FileSymbolName_iSAM(Jdex + 1)), "", "", "", "")
                    // End If
                    if (Jdex == constantMyErrorCode)
                    {
                        MyReMoveSymbol(Named_TableSymbolName(Index)); // From both named and symbol
                        MyReMoveNamed(Index);
                    }
                }
            }
            ShowSorts("Named", MySortStringArray("Named", ref Named_FileSintax, ref Named_FileSintax_Isam)); // make sure that the named symbol table is in order for this to work.
            ShowSorts("Named", MySortStringArray("Named", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM));
        }

        void MyReMoveNamed(long IndexNamed) // completel destroy it (for now)
        {
            Named_TableSymbolName(IndexNamed, null);
            Named_TableMicroCodeText(IndexNamed, null);
            // Named_TableLanguage(IndexNamed, Nothing)
            Named_TableNotes(IndexNamed, null);
            Named_TableOpCode(IndexNamed, null);
            Named_TableSymbolIndexes(IndexNamed, default(Integer));
            Named_TableNameOfFile(IndexNamed, null);
            Named_TableStroke(IndexNamed, null);
        }

        void MyReMoveSymbol(string SymbolName)
        {
            long Index;
            Index = FindInSymbolList(ref SymbolName);

            if (Index == constantMyErrorCode)
                Abug(275, "This symbol name is not found in the symbol name table", SymbolName, 0);
            else if (Strings.LCase(Symbol_TableSymbolName(Index)) == Strings.LCase(SymbolName))
            {
                Symbol_TableCode(Index, "/delete");
                while (Symbol_TableCoded_String(Index) != "/name" & Index < TopOfFile("Symbol"))
                {
                    Symbol_TableCode(Index, "/delete"); // consider making it nothing.
                    Index += 1;
                }
            }
            else
            {
            }
        }

        // Need to make sure that we Sort after at least one of these (and reset the kounter)
        void MyDeleteDataType_Table(long Index)
        {
            DataType_TableName(Index, null);
            DataType_TableColorIndex(Index, 0L);
            DataType_TableDescribtion(Index, null);
            DataType_TableNumberOfBytes(Index, default(Integer));
            DataType_TableWidth(Index, default(Byte));
        }


        void DeleteAllErrorMessages()
        {
            long Index;
            long Jdex;
            Jdex = 0; // one before the usable records
            for (Index = 1; Index <= TopOfFile("Symbol"); Index++)
            {
                if (Symbol_TableCoded_String(Index) == "/error" | Symbol_TableCoded_String(Index) == "/delete")
                {
                }
                else
                    Jdex += 1;
                if (Index != Jdex)
                {
                    FindingMyBugs(10); // hack Least amount of checking here 'hack 2020 08 04
                    MySwapSymbolList(Index, Jdex); // Move the records forward over the bad record to compress
                    FindingMyBugs(10); // hack Least amount of checking here 'hack 2020 08 04
                }
            }

            Jdex = 0;
            for (Index = 1; Index <= TopOfFile("FlowChart"); Index++)
            {
                if (FlowChart_TableCode(Index) == "/error" | FlowChart_TableCode(Index) == "/delete")
                {
                }
                else
                    Jdex += 1;
                if (Index != Jdex)
                {
                    FindingMyBugs(10); // hack Least amount of checking here 'hack 2020 08 04
                    MySwapSymbolList(Index, Jdex); // Move the records forward over the bad record to compress
                    FindingMyBugs(10); // hack Least amount of checking here 'hack 2020 08 04
                }
            }
            SortALLiSAM();
            FindingMyBugs(10); // hack Least amount of checking here 'hack
        }

        // *******************************************************************
        // This makes sure that something is printable (make it an underline instead of nothing)
        string PrintAbleNull(object A)
        {
            if (A is string)
            {
                if (Strings.Len(A.ToString()) == 0 | Information.IsNothing(A))
                    PrintAbleNull = "_";
                else
                    PrintAbleNull = A.ToString();
            }
            else if (A is long)
                PrintAbleNull = Conversion.Str(A);
            else if (A is int)
                PrintAbleNull = Conversion.Str(A);
            else if (A is long)
                PrintAbleNull = Conversion.Str(A);
            else if (A is byte)
                PrintAbleNull = Conversion.Str(A);
            else if (Information.IsNothing(A))
                PrintAbleNull = "_";
            else
                PrintAbleNull = " " + A.ToString();
        }


        MyPointStructure MyOffset(MyPointStructure XY, string X, string Y)
        {
            // flow10'MyTrace(248, "MyOffSet", 4)
            MyOffset = default(MyPointStructure);
            MyOffset.Xx = XY.Xx + My_INT(X);
            MyOffset.Yy = XY.Yy + My_INT(Y);
        }



        void FindPathNameAtLine()
        {
            string S1, S2;
            long Idex, Jdex;
            S1 = "";
            S2 = "";
            Idex = FindPathNameAt(MyUniverse.Area.MyWorldXY.b);
            Jdex = FindPathNameAt(MyUniverse.Area.MyWorldXY.a);
            S1 = FlowChart_TablePathName(Idex);
            S2 = FlowChart_TablePathName(Jdex);
            if (S1 == S2)
                return S1;
            if (Strings.Len(S1) == 0)
            {
                if (Strings.Len(S2) == 0)
                    return null;
                else
                    return S2;
            }
            else if (Strings.Len(S2) == 0)
                return S1;
            else
                return null;
            return MakePathName("Path");
        }


        // This routine returns the name of (any-First) path that it finds closest to this location
        long FindPathNameAt(MyPointStructure XY) // index of path
        {
            long D1, D2;
            long Found; // First Found One
            long Index;
            long D3, D4; // hack
            long Found2; // hack
            Found = 0;
            Found2 = 0;
            for (Index = 1; Index <= TopOfFile("FlowChart"); Index++)
            {
                switch (Strings.LCase(FlowChart_TableCode(Index)))
                {
                case "/path":
                {
                    if (Found == 0)
                    {
                        XY.Named.PathName = FlowChart_TablePathName(Index) + "A";
                        AInfo(794, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + Constants.vbCrLf + MyShowFlowChartRecord(Index) + Constants.vbCrLf + MyShowFlowChartRecord(Found) + Constants.vbCrLf + MyShowFlowChartRecord(Found2));
                        Found = Index;
                    }
                    D1 = MyDistance(XY, MyPoint1XY(Index));
                    D2 = MyDistance(XY, MyPoint1XY(Found));

                    if (D1 < D2)
                    {
                        Found = Index;
                        XY.Named.PathName = FlowChart_TablePathName(Index) + "B";
                        AInfo(795, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + Constants.vbCrLf + MyShowFlowChartRecord(Index) + Constants.vbCrLf + MyShowFlowChartRecord(Found) + Constants.vbCrLf + MyShowFlowChartRecord(Found2));
                    }

                    break;
                }

                default:
                {
                    if (Found2 == 0)
                    {
                        Found2 = Index;
                        XY.Named.SymbolName = FlowChart_TableSymbol_Name(Index) + "C";
                        AInfo(795, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + Constants.vbCrLf + MyShowFlowChartRecord(Index) + Constants.vbCrLf + MyShowFlowChartRecord(Found) + Constants.vbCrLf + MyShowFlowChartRecord(Found2));
                    }
                    D3 = MyDistance(XY, MyPoint1XY(Index));
                    D4 = MyDistance(XY, MyPoint1XY(Found));

                    if (D3 < D4)
                    {
                        Found2 = Index;
                        XY.Named.SymbolName = FlowChart_TableSymbol_Name(Index) + "D";
                        AInfo(797, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + Constants.vbCrLf + MyShowFlowChartRecord(Index) + Constants.vbCrLf + MyShowFlowChartRecord(Found) + Constants.vbCrLf + MyShowFlowChartRecord(Found2));
                    }

                    break;
                }
                }
            }

            if (Found > 0)
            {
                AInfo(674, "Found " + MyShowPoint(XY), " Distance = " + D2, MyShowFlowChartRecord(Found));
                return Found;
            }
            else
            {
                AInfo(675, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + Constants.vbCrLf + MyShowFlowChartRecord(Index) + Constants.vbCrLf + MyShowFlowChartRecord(Found) + Constants.vbCrLf + MyShowFlowChartRecord(Found2));
                if (Found2 > 0)
                {
                    if (FlowChart_TableCode(Found2) != "/use")
                        Abug(277, "Did Find at " + MyShowPoint(XY), "Distances =" + MyShowPoint(MyPoint1XY(D3, D4)), " found at " + MyShowFlowChartRecord(Found2) + Constants.vbCrLf + "But it is not a path");
                }
                AInfo(677, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + MyShowFlowChartRecord(Index));
                return constantMyErrorCode;
            }
            // should never get to this point!!!!
            Abug(481, "Searching for path to " + MyShowPoint(XY), "Distances" + D1 + ":" + D2 + ":" + D3 + ":" + D4 + "  Indexes " + ":" + Index + ":" + Found + ":" + Found2, " Found something else" + MyShowFlowChartRecord(Index));
        }

        // RECURSIVE routine to find all of the paths connected together to XY.
        bool FindAllPaths(long IndexFlowChart, MyPointStructure XY, string Pathname)
        {
            // ***************** Yes I know that it causes recursion loop that will never stop, I'll fix it later - Really I will
            // Find all of the points to this location and return as a  string of the index to that path
            long I;
            long IndexFlowChartX1;

            Pathname = CheckThisPathName(Pathname, IndexFlowChart);
            // AInfo(825, "FindAllPaths " & MyShowPoint(XY), Pathname, MyShowFlowChartRecord(IndexFlowChart))
            if (IndexFlowChart < 1)
            {
                Abug(278, XY.Xx, XY.Yy, IndexFlowChart);
                return false;
            }
            if (IndexFlowChart > TopOfFile("FlowChart"))
                return false;
            if (Strings.LCase(FlowChart_TableCode(IndexFlowChart)) != "/path")
                return false;

            if (MyInListOfNumbers(IndexFlowChart) == false)
            {
                AInfo1(776, "The path number " + IndexFlowChart + " is NOT in the pathlinks", MyShowFlowChartRecord(IndexFlowChart), "");
                return false;
            }

            CheckForAnySortNeeded("", 248);
            // ******************** Error this is not returning the index of a found item
            IndexFlowChartX1 = FindIndexIniSAMTable("FlowChart", ref "DoNotAdd", ref FlowChart_FileX1, ref FlowChart_iSAM_X1, ref FlowChart_TableX1(IndexFlowChart));

            // ?I = MyUniverse.MyCheatSheet.LastiSAMNumberIndex

            CheckForAnySortNeeded("", 248);
            if (MyCheckIndex_long("FlowChart", IndexFlowChartX1, FlowChart_File_X2_Rotation, ref FlowChart_iSAM_X1) == false)
                return false;
            IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, Information.UBound(FlowChart_iSAM_X1));

            // Why does the following line error out? It works the first few times
            // ?
            // Lets make sure we are at the geggining of the first isam(index)
            if (InvalidIndex(IndexFlowChart, FlowChart_FileX1, ref FlowChart_iSAM_X1))
                return false;
            while (FlowChart_TableX1(FlowChart_iSAM_X1[IndexFlowChartX1 - 1]) < FlowChart_TableX1(IndexFlowChart))
            {
                MyDoEvents();
                IndexFlowChartX1 += 1;
                if (IndexFlowChartX1 >= TopOfFile("FlowChart"))
                    break;
            }

            while (FlowChart_TableX1(FlowChart_iSAM_X1[IndexFlowChartX1 - 1]) == FlowChart_TableX1(IndexFlowChart))
            {
                MyDoEvents();
                IndexFlowChartX1 -= 1;
            }

            // If FindIndex_In_TableNetLinks(IndexFlowChart ) > 0 Then Return False ' already in a net
            // Already in a net 
            while (InvalidIndex(IndexFlowChartX1, FlowChart_FilePathSymbolName) == false & FlowChart_TableX1(FlowChart_iSAM_X1[IndexFlowChartX1]) <= FlowChart_TableX1(IndexFlowChart))
            {
                // {
                MyDoEvents();
                I = FlowChart_iSAM_X1[IndexFlowChartX1];
                if (IndexFlowChart != IndexFlowChartX1)
                {
                    switch (Strings.LCase(FlowChart_TableCode(I)))
                    {
                    case "/path":
                    {
                        if (IndexFlowChart != I)
                        {
                            CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                            if (MyInListOfNumbers(IndexFlowChart) == true)
                            {
                            }
                            else
                            {
                                // Check The first point
                                if (XY.Xx == FlowChart_TableX1(I))
                                {
                                    if (XY.Yy == FlowChart_TableY1(I))
                                    {
                                        CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                                        // Start new tree search
                                        if (FindAllPaths(I, MyPoint1XY(FlowChart_TableX1(I), FlowChart_TableY1(I)), Pathname) == true)
                                        {
                                            if (FindAllPaths(I, MyPoint2XY(FlowChart_TableX2(I), FlowChart_TableY2(I)), Pathname) == true)
                                                return true;
                                        }
                                    }
                                }
                                // Check The Second point
                                if (XY.Xx == FlowChart_TableX2(I))
                                {
                                    if (XY.Yy == FlowChart_TableY2(I))
                                    {
                                        CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                                        ConnectPaths(I, IndexFlowChart, Pathname);
                                        // Start new tree search
                                        if (FindAllPaths(I, MyPoint1XY(FlowChart_TableX1(I), FlowChart_TableY1(I)), Pathname) == true)
                                        {
                                            if (FindAllPaths(I, MyPoint2XY(FlowChart_TableX2(I), FlowChart_TableY2(I)), Pathname) == true)
                                                return true;
                                        }
                                    }
                                }
                            }
                        }

                        break;
                    }

                    case "/use"// ignore
                        :
                    {
                        break;
                    }

                    case "/error" // ignore
                        :
                    {
                        break;
                    }

                    case "/origin" // ignore
                        :
                    {
                        break;
                    }

                    case "/constant" // ignore
                        :
                    {
                        break;
                    }

                    default:
                    {
                        AInfo(628, "not a /path", MyShowFlowChartRecord(I), MyShowFlowChartRecord(IndexFlowChart));
                        break;
                    }
                    }
                }
                // '                FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
                CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                // MyMsgCtr(1247, "FindAllPaths", IndexFlowChart .ToString, FlowChart_TableCompiledMacroCodeText(IndexFlowChart ), Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart )), "", "", "", "", "", "")
                IndexFlowChartX1 += 1;
                if (IndexFlowChartX1 != MyMinMax(IndexFlowChartX1, 1, TopOfFile("flowchart")))
                    break;

                IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfFile("flowchart"));
                while (InvalidIndex(IndexFlowChartX1, FlowChart_FileX1, ref FlowChart_iSAM_X1))
                {
                    Abug(281, "FindAllPaths() invalid index:", IndexFlowChartX1, MyShowFlowChartRecord(IndexFlowChartX1));
                    IndexFlowChartX1 += 1;
                    if (IndexFlowChartX1 > TopOfFile("Flowchart"))
                        break;
                    if (IndexFlowChartX1 != MyMinMax(IndexFlowChartX1, 1, TopOfFile("flowchart")))
                        IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfFile("flowchart"));
                }
                if (IndexFlowChartX1 != MyMinMax(IndexFlowChartX1, 1, TopOfFile("flowchart")))
                    IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfFile("flowchart"));
            }
            // Got here cause this XY is not anywhere else 
            // '            FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
            CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
            // AInfo(1249, "FindAllPaths", MyShowFlowChartRecord(IndexFlowChart), Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart))) ', "", "", "", "", "", "", "")
            return true;
        }




        void FindAllPaths_2(long IndexFlowChart, long LineNumber, string PathName) // This does findallpaths()  but by name
        {
            // ***************** Yes I know that it causes recursion loop that will never stop, I'll fix it later - Really I will
            // Find all of the points to this location and return as a  string of the index to that path
            long Index;
            long Jdex;
            PathName = CheckThisPathName(PathName, IndexFlowChart);
            if (IndexFlowChart < 1)
                return;
            if (IndexFlowChart > TopOfFile("FlowChart"))
                return;
            if (Strings.LCase(FlowChart_TableCode(IndexFlowChart)) != "/path")
                return;

            // ****************************** I can speed it up later
            CheckForAnySortNeeded("", 249);
            Jdex = FindiSAM_IN_Table("FlowChart", "DoNotAdd", ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, FlowChart_TablePath_Name(IndexFlowChart));
            CheckForAnySortNeeded("", 249);
            if (MyCheckIndex_String("FlowChart", Jdex, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name) == false)
                return;
            // above is all extra and dow not work right( I used it wrongly)


            // Get the index in the isam of the start
            Jdex = FindIndexIniSAMTable("FlowChart", "DoNotAdd", ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, FlowChart_TablePath_Name(IndexFlowChart));

            Index = MyUniverse.MyCheatSheet.LastiSAMNumberIndex; // Is this what I want? and not jdex (ie set jdex to this )


            // hack to add Z when it returns nothing
            while (FlowChart_TablePathName(FlowChart_iSAM_Name[Jdex]) + "z" < FlowChart_TablePathName(IndexFlowChart) & Jdex < Information.UBound(FlowChart_iSAM_Name))
                Jdex += 1;

            while (FlowChart_TablePathName(FlowChart_iSAM_Name[Jdex - 1]) == FlowChart_TablePathName(IndexFlowChart) & Jdex > 1)
                Jdex -= 1;

            while (FlowChart_TablePathName(FlowChart_iSAM_Name[Jdex]) <= FlowChart_TablePathName(IndexFlowChart))
            {
                ainfo2(19);
                Index = FlowChart_iSAM_Name[Jdex];
                if (InvalidIndex(Index, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                    // AInfo1(777, "The index for the flowchart is invalid ", Index, Jdex)
                    break;
                switch (Strings.LCase(FlowChart_TableCode(Index)))
                {
                case "/path":
                {
                    if (IndexFlowChart != Index)
                    {
                        CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                        if (MyInListOfNumbers(IndexFlowChart) == true)
                        {
                        }
                        else
                            // Check The first point
                            if (FlowChart_TablePathName(IndexFlowChart) == FlowChart_TablePathName(Index))
                            {
                                ainfo2(20);
                                CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                                // ' FlowChart_TableCompiledMacroCodeText(IndexFlowChart , CleanListOfNets(IndexFlowChart ))
                                // This name is not in the list of path links , so lets connect them together
                                ainfo2(21);
                                MakePaths(IndexFlowChart, Index, LineNumber);
                                ainfo2(22);
                                // FLOW10' Causes recursion never ending 'UpDateFlowChartLinks(Index, LineNumber)
                                // ainfo2(23)
                                PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart, IndexFlowChart);
                                ainfo2(24);
                                PaintAll(FlowChartScreen.PictureBox1, Index, Index);
                                ainfo2(25);
                            }
                    }
                    CleanListOfNet_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                    break;
                }
                }
                Jdex += 1;

                if (InvalidIndex(Index, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                {
                    Abug(283, "The index for the flowchart is invalid ", Index, 0);
                    break;
                }
            }
        }





        long NewFlowChartRecord()
        {
            NewFlowChartRecord = NewTopOfFile("flowchart");
            FlowChart_FilePathSymbolName[NewFlowChartRecord] = "?"; // just to make no errors 
            FlowChart_iSAM_Name[NewFlowChartRecord] = NewFlowChartRecord;
            FlowChart_iSAM_X1[NewFlowChartRecord] = NewFlowChartRecord;
            FlowChart_iSAM_Y1[NewFlowChartRecord] = NewFlowChartRecord;
            FlowChart_iSAM_X2[NewFlowChartRecord] = NewFlowChartRecord;
            FlowChart_iSAM_Y2[NewFlowChartRecord] = NewFlowChartRecord;
        }



        // returns true if the IndexFlowChart  is in the list of number in symbol table data
        // returns false if not, or issue
        bool MyInListOfNumbers(long IndexFlowChart)
        {
            string Temp, Numbers;
            long indexNetLinks;
            Numbers = "";
            Temp = FD + IndexFlowChart + FD; // create a  string to search for - Make sure the comma before and after so that it only find the complete number
            // hack I think that this is not used this way anymore, but that it should be getting the net_links of a pointer from ?????
            // stop here, somehow it is return an index beyond the end of the _filelinks 
            indexNetLinks = FindIndex_In_TableNetLinks(IndexFlowChart);
            // Check that the index is inside the netlinks bounds (If not then it is to be addd as the next one.
            if (indexNetLinks > Information.LBound(Net_FileLinks))
            {
                if (indexNetLinks <= Information.UBound(Net_FileLinks))
                    Numbers = Net_TableLinks(indexNetLinks); // indexnetlinks is a valid pointer to get the netlink information
                else
                {
                    Abug(284, "Should never happen here ", indexNetLinks, Information.UBound(Net_FileLinks));
                    MakeNew_NetLinks(IndexFlowChart, FlowChart_TablePathName(IndexFlowChart));
                }
            }
            else if (indexNetLinks < Information.UBound(Net_FileLinks))
                Numbers = Net_TableLinks(indexNetLinks);
            else
            {
                Abug(285, "Should never happen here ", indexNetLinks, Information.UBound(Net_FileLinks));
                Numbers = Net_TableLinks(indexNetLinks);
            }

            if (Strings.InStr(Numbers, Temp) > 0)
                return true;

            // We should never get here 
            // todo al of the above to get to here to          see if the IndexFlowChart  already exist in a net
            Temp = Numbers;
            while (Strings.Len(Temp) > 0)
            {
                if (PopValue(ref Temp) == IndexFlowChart)
                    return true;
            }
            return false;
        }



        // This will return the index in netlink() of this index
        long CleanListOfNet_TableLinks(long IndexNetLinks) // always return index to netlinks
        {
            long I, K;
            string CleanList;
            long[] MyList = new long[2];
            if (IndexNetLinks < 1)
                return constantMyErrorCode;
            if (IndexNetLinks > Information.UBound(Net_FileLinks))
            {
                var oldNet_FileLinks = Net_FileLinks;
                Net_FileLinks = new string[IndexNetLinks + 1 + 1];
                if (oldNet_FileLinks != null)
                    Array.Copy(oldNet_FileLinks, Net_FileLinks, Math.Min(IndexNetLinks + 1 + 1, oldNet_FileLinks.Length));
                var oldNet_FileNames = Net_FileNames;
                Net_FileNames = new string[IndexNetLinks + 1 + 1];
                if (oldNet_FileNames != null)
                    Array.Copy(oldNet_FileNames, Net_FileNames, Math.Min(IndexNetLinks + 1 + 1, oldNet_FileNames.Length));
            }

            CleanList = Net_TableLinks(IndexNetLinks);

            MyList[1] = 0;
            while (Strings.Len(CleanList) > 0)
            {
                var oldMyList = MyList;
                MyList = new int[Information.UBound(MyList) + 1 + 1];
                if (oldMyList != null)
                    Array.Copy(oldMyList, MyList, Math.Min(Information.UBound(MyList) + 1 + 1, oldMyList.Length));
                K = PopValue(ref CleanList);
                if (K != 0)
                    MyList[Information.UBound(MyList) - 1] = K;
            }
            for (I = 1; I <= Information.UBound(MyList); I++)
            {
                if (MyList[I] != 0)
                {
                    for (K = I + 1; K <= Information.UBound(MyList); K++)
                    {
                        if (MyList[I] == MyList[K])
                            MyList[I] = 0;// Delete the duplicate
                    }
                }
            }

            for (I = 1; I <= Information.UBound(MyList) - 1; I++)
            {
                if (MyList[I] != 0)
                {
                    if (CleanList == "")
                        CleanList = FD; // changes to only have it if there is going to be something.
                    CleanList = CleanList + MyList[I] + FD;
                }
            }
            if (CleanList == "")
                AInfo(629, " Cleaned up the list and it is now nothing ", "Was ->" + Net_TableLinks(IndexNetLinks) + "<-", "");
            Net_TableLinks(IndexNetLinks, CleanList); // Update this path List
            return IndexNetLinks;
        }

        void ChangeOptionScreenSelectedIndex(string MyTable, ToolStripDropDownButton T, string WhatToSelect)
        {
            long I;
            CheckForAnySortNeeded("", 250);
            I = FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, MyUniverse.ProgramOptions.SelectedColor);
            CheckForAnySortNeeded("", 251);
            if (I == constantMyErrorCode)
            {
                Abug(286, "The selected color is not found in the color table ", I, MyUniverse.ProgramOptions.SelectedColor);
                return;
            }
            // MyUnEnum(Color_TableStyle(I), OptionScreen.ComboBoxLineStyle, 2)



            // Error needs To be fixed
            // Temp = Color_TableStyle(I)



            SymbolScreen.ToolStripDropDownPathLineStyle.Text = I.ToString(); // Color_TableStyle(I)
            SymbolScreen.ToolStripDropDownPathStart.Text = MyUnEnum(Color_TableStartCap(I), SymbolScreen.ToolStripDropDownPathStart, 0);
            SymbolScreen.ToolStripDropDownPathEnd.Text = MyUnEnum(Color_TableEndCap(I), SymbolScreen.ToolStripDropDownPathEnd, 1);
        }



        // The following is to preview and print pages
        // Dim objCallback As System.Drawing.Image.GetThumbnailImageAbort = New System.Drawing.Image.GetThumbnailImageAbort(AddressOf ThumbnailCallback)
        // Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click
        // Dim printer As PrintDocument = New PrintDocument
        // AddHandler() printer.PrintPage, AddressOf PrintImage
        // printer.Print()
        // End Sub
        // Private Sub PrintImage(ByVal sender As Object, ByVal e As PrintPageEventArgs)
        // Dim img As Image = PictureBox1.Image
        // img = img.GetThumbnailImage(300, 300, objCallback, IntPtr.Zero)
        // e.Graphics.DrawImage(img, 0, 0)
        // End Sub
        // Function ThumbnailCallback() As Boolean
        // Return false
        // End Function
        // ***************************************** Another Example to print ***************************
        //   Sub printImage()
        // Dim objPrint As New PrintDocument
        // AddHandler() objPrint.PrintPage, AddressOf PrintImage_PrintPage
        // objPrint.Print()
        // End Sub
        // Private Sub PrintImage_PrintPage(ByVal sender As Object, ByVal e As PrintPageEventArgs)
        // e.Graphics.DrawImage(PictureBox1.Image, 0, 0, PictureBox1.Width, PictureBox1.Height)
        // End Sub



        void RouterTicked()
        {
            MyDoEvents(); // required always
            Timer_MoveNextSymbol(TimerFlowChartIndexCounter);
            MyDoEvents();
            if (Timer_MoveNextPath(TimerFlowChartIndexCounter) == true)
            {
                MyDoEvents();
                Timer_ReROUTERNextPath(TimerFlowChartIndexCounter);
            }
            MyDoEvents();
            TimerFlowChartIndexCounter += 1;
            if (TimerFlowChartIndexCounter > TopOfFile("FlowChart"))
                TimerFlowChartIndexCounter = 1;
        }



        void TimerTicked(EventArgs e)
        {
            MyDoEvents(); // required always
            Timer_MoveNextSymbol(TimerFlowChartIndexCounter);
            MyDoEvents();
            if (Timer_MoveNextPath(TimerFlowChartIndexCounter) == true)
            {
                MyDoEvents();
                Timer_ReROUTERNextPath(TimerFlowChartIndexCounter);
            }
            MyDoEvents();
            TimerFlowChartIndexCounter += 1;
            if (TimerFlowChartIndexCounter > TopOfFile("FlowChart"))
                TimerFlowChartIndexCounter = 0;
        }

        void Timer_MoveNextSymbol(long Idex) // always get the next to work on
        {
            long Jdex;
            Idex = MyMinMax(Idex, 1, TopOfFile("FlowChart"));
            if (FlowChart_TableCode(Idex) != "/use")
                return; // cause we only want to work on symbol right now.
            for (Jdex = Idex + 1; Jdex <= TopOfFile("FlowChart"); Jdex++)
            {
                if (FlowChart_TableCode(Idex) == "/use")
                {
                    if (SymbolOnTop(Idex, Jdex) == true)
                        // move one of the symbols
                        MoveSymbolAndAllPaths(FlowChartScreen.PictureBox1, Idex, MyPoint1XY(MyUniverse.SysGen.Constants.constantSymbolCenter + MyUniverse.SysGen.Constants.constantSymbolCenter, 0));// move over in the X the distance of this
                }
            }
        }
        bool Timer_MoveNextPath(long idex)
        {
            long Jdex;
            MyLineStructure Line1, Line2;
            Timer_MoveNextPath = false;
            idex = MyMinMax(idex, 1, TopOfFile("FlowChart"));
            MyDoEvents();
            if (FlowChart_TableCode(idex) != "/path")
                return; // cause we only want to work on paths right now
            MyDoEvents();
            for (Jdex = idex + 1; Jdex <= TopOfFile("FlowChart"); Jdex++)
            {
                MyDoEvents();
                if (FlowChart_TableCode(idex) == "/path")
                {
                    Line1 = MyLine1(idex);
                    Line2 = MyLine2(Jdex);
                    if (PathOnTop(Line1, Line2) == true)
                        // move one of the symbols
                        Timer_MoveNextPath = true;
                    MyDoEvents();
                }
            }
            MyDoEvents();
        }


        void Timer_ReROUTERNextPath(long Idex)
        {
            Idex = MyMinMax(Idex, 1, TopOfFile("FlowChart"));
            MyDoEvents();
            if (FlowChart_TableCode(Idex) == "/path")
                return; // cause we only want to work on paths right now
            MyDoEvents();
            MoveSymbolAndAllPaths(FlowChartScreen.PictureBox1, Idex, MyPoint1XY(MyUniverse.SysGen.Constants.constantSymbolCenter, 0)); // move over in the X the distance of this
            MyDoEvents();
        }



        string Net_TableNames(long IndexNet)
        {
            if (IndexNet < Information.LBound(Net_FileNames) | IndexNet > Information.UBound(Net_FileNames))
                return null; // Need to show an error 
            return Net_FileNames[IndexNet];
        }
        void Net_TableNameS(long IndexNet, string Value)
        {
            if (IndexNet < 0 | IndexNet > Information.UBound(Net_FileNames))
                return; // Need to show an error 
            Net_FileNames[IndexNet] = Value;
        }


        string Net_TableLinks(long Index)
        {
            if (Index < 1 | Index > Information.UBound(Net_FileLinks))
                return null; // Need to show an error 
            return Net_FileLinks[Index];
        }
        void Net_TableLinks(long Index, string Value)
        {
            if (Index < 1 | Index > Information.UBound(Net_FileLinks))
                return; // Need to show an error 
            Net_FileLinks[Index] = Value;
        }





        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableSymbolName(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableSymbolName = null;
                return;
            }
            Named_TableSymbolName = Named_FileSymbolName[Index];
        }

        void Named_TableSymbolName(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileSymbolName[Index] = Value;
            MyUniverse.MyCheatSheet.NamedSorted += 1;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableMicroCodeText(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableMicroCodeText = null;
                return;
            }
            Named_TableMicroCodeText = Named_Filemicrocodetext[Index];
        }

        void Named_TableMicroCodeText(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_Filemicrocodetext[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableOpCode(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableOpCode = null;
                return;
            }
            Named_TableOpCode = Named_FileOpCode[Index];
        }

        void Named_TableOpCode(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileOpCode[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Named_TableSymbolIndexes(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableSymbolIndexes = default(Integer);
                return;
            }
            Named_TableSymbolIndexes = Named_FileSymbolIndexes[Index];
        }



        void Named_TableSymbolIndexes(long Index, long value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileSymbolIndexes[Index] = value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableStroke(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableStroke = null;
                return;
            }
            Named_TableStroke = Named_FileStroke[Index];
        }



        void Named_TableStroke(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileStroke[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableNameofFile(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableNameofFile = null;
                return;
            }
            Named_TableNameofFile = Named_FileNameOfFile[Index];
        }


        void Named_TableNameOfFile(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileNameOfFile, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileNameOfFile[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableNotes(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableNotes = null;
                return;
            }
            Named_TableNotes = Named_FileNotes[Index];
        }

        void Named_TableNotes(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileNotes[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableAuthor(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableAuthor = null;
                return;
            }
            Named_TableAuthor = Named_FileAuthor[Index];
        }


        void Named_TableAuthor(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileAuthor[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableVersion(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableVersion = null;
                return;
            }
            Named_TableVersion = Named_FileVersion[Index];
        }


        void Named_TableVersion(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileVersion[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Named_TableSintax(long Index)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
            {
                Named_TableSintax = null;
                return;
            }
            Named_TableSintax = Named_FileSintax[Index];
        }


        void Named_TableSintax(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM))
                return;
            Named_FileSintax[Index] = Value;
        }

        long FindInputOutputIndex(string InputOutputName)
        {
            long I;
            string Temp;
            for (I = 0; I <= SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Count - 1; I++)
            {
                Temp = SymbolScreen.ToolStripDropDownInputOutput.DropDownItems(I).Text;
                if (InputOutputName == Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters))
                    return I;
            }
            return constantMyErrorCode;
        }

        long FindDataTypeIndex(string DataTypeName)
        {
            long I;
            I = FindIndexIniSAMTable("datatype", "DoNotAdd", ref DataType_FileName, ref DataType_Name_iSAM, DataTypeName);
            if (I == constantMyErrorCode)
                return constantMyErrorCode;
            return I;
        }

        long FindColorIndexFromName(string ColorName)
        {
            return FindIndexIniSAMTable("Color", "DoNotAdd", ref Color_FileName, ref Color_Name_iSAM, ColorName);
        }

        string FindColorFromDataType(string DataTypeName)
        {
            if (Strings.Len(DataTypeName) == 0)
                return null;
            return Color_TableName(DataType_TableColorIndex(FindDataTypeIndex(DataTypeName)));
        }


        long FindWidthFromDataType(string DataTypeName)
        {
            long I2;
            long Idex, Kdex, Jdex;
            long ErrorCount;
            // MyTrace(285, "FindWidthFromDataType", 633 - 576)

            Kdex = TopOfFile("DataType");
            Idex = System.Convert.Tolong(Kdex / (double)2);
            Jdex = System.Convert.Tolong((Idex - 4) / (double)2);
            ErrorCount = 2048;
            FindWidthFromDataType = 0;
            while (ErrorCount > 0)
            {
                ErrorCount -= 1;
                switch (MyCompared3(DataType_TableName(DataType_Name_iSAM[Idex]), DataTypeName, DataType_TableName(DataType_Name_iSAM[Idex + 1])))
                {
                    case -5 // Test 9 A > C unsorted list error
                        :
                    {
                        Abug(291, DataType_TableName(DataType_Name_iSAM[Idex]), DataTypeName, DataType_TableName(DataType_Name_iSAM[Idex + 1]));
                        FindWidthFromDataType = 1; // default min datatype/line width
                        Idex -= Jdex;
                        break;
                    }

                    case -4 // Test 5 & 7  both A=nothing and b = c then only A=nothing
                        :
                    {
                        FindWidthFromDataType = 0;
                        // todo should this one be + or -?
                        Idex += 1;
                        break;
                    }

                    case -3 // test 11 A>b
                        :
                    {
                        FindWidthFromDataType = 1; // default min datatype/line width
                        Idex -= Jdex;
                        break;
                    }

                    case -2 // test 12  b>C
                        :
                    {
                        FindWidthFromDataType = 1; // default min datatype/line width
                        Idex += Jdex;
                        break;
                    }

                    case -1 // Test 3 -> A = b
                        :
                    {
                        return DataType_TableWidth(Idex);
                    }

                    case 0 // Test 2 & 10 A and C are both null or nothing then A<b<C not in list
                        :
                    {
                        FindWidthFromDataType = 0;
                        break;
                        break;
                    }

                    case 1 // Test 4 -> b=C so move forward just one.
                        :
                    {
                        FindWidthFromDataType = DataType_TableWidth(Idex);
                        Idex += 1;
                        break;
                    }

                    case 2 // test 14 A<b
                        :
                    {
                        FindWidthFromDataType = DataType_TableWidth(Idex);
                        Idex += Jdex;
                        break;
                    }

                    case 3 // test 13 b < C
                        :
                    {
                        FindWidthFromDataType = DataType_TableWidth(Idex);
                        Idex += Jdex;
                        break;
                    }

                    case 4 // test 6 & 8 ->>> C is nothing and b > A then C=nothing
                        :
                    {
                        FindWidthFromDataType = 0;
                        break;
                        break;
                    }

                    case 5 // Test 1 & 15 -> b=nothing then no other test works (Error)
                        :
                    {
                        Abug(292, DataType_TableName(DataType_Name_iSAM[Idex]), "searching for" + HighLight(DataTypeName), DataType_TableName(DataType_Name_iSAM[Idex + 1]));
                        return 1;
                    }
                }
                if (Idex == 0 & Jdex == 1)
                    break;
                Idex = MyMinMax(Idex, 1, Kdex);
                Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
            }
            for (I2 = 1; I2 <= TopOfFile("DataType"); I2++)
            {
                if (Strings.LCase(Strings.Trim(DataTypeName)) == Strings.LCase(Strings.Trim(DataType_TableName(I2))))
                {
                    Abug(293, "Failed binary search for width", DataTypeName, "");
                    return DataType_TableWidth(I2);
                }
            }
            return 1;
        }


        // returns if the colors have changed.
        long TestIfColorStandardMicroSoftColorName(long IndexColor)
        {
            long I;
            long R1, R2, G1, G2, B1, B2, A1, A2, LastIndex;
            long long LastDistance, Distance;
            string ThisColor, ThatColor;

            if (Strings.Len(Color_TableName(IndexColor)) == 0)
                return constantMyErrorCode;
            // ?LastIndex = LBound(Color_FileName)
            MyGetPen_Static(Color_TableName(IndexColor), "");
            ThisColor = GetMyPen.Color.Name.ToString;

            if (ThisColor == Color_TableName(IndexColor))
                return IndexColor;
            ThatColor = Color_TableName(IndexColor);
            // todo if this color matches then we do not need to find the closest
            Abug(679, "Color Name Error: " + HighLight(ThisColor) + "<>" + HighLight(ThatColor) + " Index= " + IndexColor, Color_TableName(IndexColor), GetMyPen.Color.Name.ToString);

            R1 = GetMyPen.Color.R;
            G1 = GetMyPen.Color.G;
            B1 = GetMyPen.Color.B;
            A1 = GetMyPen.Color.A;
            // go through all of the pens to see if this one is there.

            LastDistance = 32000;
            LastIndex = 1;

            for (I = 1; I <= Information.UBound(Color_FileName); I++)
            {
                if (Strings.Len(Color_FileName[I]) != 0)
                {
                    MyGetPen_Static(Color_TableName(I), "");
                    ThatColor = GetMyPen.Color.Name.ToString;
                    // Th color is unknown so find the closest
                    // go through all of the pens to see if this one is there.
                    R2 = GetMyPen.Color.R;
                    G2 = GetMyPen.Color.G;
                    B2 = GetMyPen.Color.B;
                    A2 = GetMyPen.Color.A;
                    Distance = MyABS64(R1 - R2);
                    Distance += MyABS64(G1 - G2);
                    Distance += MyABS64(B1 - B2);
                    Distance += MyABS64(A1 - A2);
                    if (Distance < LastDistance)
                    {
                        LastIndex = I;
                        LastDistance = Distance;
                    }
                    if (ThatColor == ThisColor)
                        return I;// names match
                }
            }
            // This is the closest they come
            return LastIndex;
        }




        // ***********************************************************************
        // returns the index of the name of the color
        long FindColor(string Clr)
        {
            long I;
            long Idex, Kdex, Jdex;
            // MyTrace(286, "FindColor", 95 - 37)

            if (Information.IsNothing(Clr))
            {
                FindColor = constantMyErrorCode; return;
            }
            if (Strings.Trim(Clr) == "")
            {
                FindColor = constantMyErrorCode; return;
            }
            Kdex = TopOfFile("Color");
            Idex = System.Convert.Tolong(Kdex / (double)2);
            Jdex = System.Convert.Tolong((Idex - 4) / (double)2);
            while (1 == 1)
            {
                switch (MyCompared3(Color_TableName(Color_Name_iSAM[Idex]), Clr, Color_TableName(Color_Name_iSAM[Idex + 1])))
                {
                    case -5 // Test 9 A > C unsorted list error
                        :
                    {
                        Abug(294, Color_TableName(Color_Name_iSAM[Idex]), Clr, Color_TableName(Color_Name_iSAM[Idex + 1]));
                        Idex -= Jdex;
                        break;
                    }

                    case -4 // Test 5 & 7  both A=nothing and b = c then only A=nothing
                        :
                    {
                        FindColor = 1;
                        return;
                    }

                    case -3 // test 11 A>b
                        :
                    {
                        Idex -= Jdex;
                        break;
                    }

                    case -2 // test 12  b>C
                        :
                    {
                        Idex += Jdex;
                        break;
                    }

                    case -1 // Test 3 -> A = b
                        :
                    {
                        FindColor = Idex;
                        return;
                    }

                    case 0 // Test 2 & 10 A and C are both null or nothing then A<b<C not in list
                        :
                    {
                        FindColor = constantMyErrorCode;
                        return;
                    }

                    case 1 // Test 4 -> b=C so move forward just one.
                        :
                    {
                        Idex += 1;
                        break;
                    }

                    case 2 // test 14 A<b
                        :
                    {
                        Idex += Jdex;
                        break;
                    }

                    case 3 // test 13 b < C
                        :
                    {
                        Idex += Jdex;
                        break;
                    }

                    case 4 // test 6 & 8 ->>> C is nothing and b > A then C=nothing
                        :
                    {
                        FindColor = Idex; // end of the file
                        return;
                    }

                    case 5 // Test 1 & 15 -> b=nothing then no other test works (Error)
                        :
                    {
                        if (Information.IsNothing(Clr))
                            break;
                        if (Strings.Trim(Clr) == "")
                            break;
                        if (Clr == FD)
                            break;
                        Abug(295, "Finding Color returns 5, meaning out of order", Color_TableName(Color_Name_iSAM[Idex]) + " : " + Clr + " : " + Color_TableName(Color_Name_iSAM[Idex + 1]), 0);
                        FindColor = constantMyErrorCode;
                        return;
                    }
                }
                if (Idex == 0 & Jdex == 1)
                    break;
                Idex = MyMinMax(Idex, 1, Kdex);
                Jdex = MyMinMax(System.Convert.Tolong(Jdex / (double)2), 1, Kdex);
            }
            // FindColor = -1
            // Exit Function

            // failed so try everything loop

            for (I = 1; I <= Information.UBound(Color_FileName); I++)
            {
                if (Strings.LCase(Strings.Trim(Clr)) == Strings.LCase(Strings.Trim(Color_TableName(I))))
                {
                    Abug(296, "FindColor() Failed to find it but a search of each and every one turned it up", I, Clr);
                    FindColor = I;
                    return;
                }
            }
            AInfo(631, "FindColor():", Clr, 0);
            FindColor = constantMyErrorCode;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Color_TableName(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return null;
            Color_TableName = Color_FileName[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableName(long Index, string Value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileName[Index] = Value;
            MyUniverse.MyCheatSheet.ColorsSorted += 1;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Color_TableStartCap(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableStartCap = default(Integer);
                return;
            }
            Color_TableStartCap = Color_FileStartCap[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Color_TableEndCap(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableEndCap = default(Integer);
                return;
            }
            Color_TableEndCap = Color_FileEndCap[Index];
        }


        // ***********************************************************************
        // this returns the line style from the line number type
        Drawing2D.DashStyle Color_TableStyle(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableStyle = null/* TODO Change to default(_) if this is not a reference type */;
                return;
            }

            switch (My_INT(MyUnEnum(Color_FileStyle[Index], SymbolScreen.ToolStripDropDownPathLineStyle, 1)))
            {
            case 0:
            {
                return Drawing2D.DashStyle.Solid;
            }

            case 1:
            {
                return Drawing2D.DashStyle.Dash;
            }

            case 2:
            {
                return Drawing2D.DashStyle.DashDot;
            }

            case 3:
            {
                return Drawing2D.DashStyle.DashDotDot;
            }

            case 4:
            {
                return Drawing2D.DashStyle.Dot;
            }

            default:
            {
                return Drawing2D.DashStyle.Solid;
            }
            }
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        __int8  Color_TableAlpha(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableAlpha = default(__int8);
                return;
            }
            Color_TableAlpha = Color_FileAlpha[Index];
        }
        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        __int8  Color_TableRed(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableRed = default(__int8);
                return;
            }
            Color_TableRed = Color_FileRed[Index];
        }
        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        __int8  Color_TableGreen(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableGreen = default(__int8);
                return;
            }
            Color_TableGreen = Color_FileGreen[Index];
        }
        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        __int8  Color_TableBlue(long Index)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
            {
                Color_TableBlue = default(__int8);
                return;
            }
            Color_TableBlue = Color_FileBlue[Index];
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableStartCap(long Index, long value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileStartCap[Index] = System.Convert.ToByte(MyMinMax(value, 0, 255));
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableEndCap(long Index, long value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileEndCap[Index] = System.Convert.ToByte(MyMinMax(value, 0, 255));
        }

        // *******************************************************************
        // This saves the style of color index in the drop down 
        // one for  string input 
        void Color_TableStyle(long Index, string value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileStyle[Index] = System.Convert.ToByte(MyMinMax(MyEnumValue(Strings.Trim(value), SymbolScreen.ToolStripDropDownPathLineStyle), 0, 255));
        }
        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        // one for DataType_FileNumberOfBytes input
        void Color_TableStyle(long Index, long value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileStyle[Index] = System.Convert.ToByte(MyMinMax(value, 0, 255));
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableAlpha(long Index, long Value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileAlpha[Index] = System.Convert.ToByte(MyMinMax(Value, 0, 255));
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableRed(long Index, long Value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileRed[Index] = System.Convert.ToByte(MyMinMax(Value, 0, 255));
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableGreen(long Index, long Value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileGreen[Index] = System.Convert.ToByte(MyMinMax(Value, 0, 255));
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Color_TableBlue(long Index, long Value)
        {
            if (InvalidIndex(Index, ref Color_FileName, ref Color_Name_iSAM))
                return;
            Color_FileBlue[Index] = System.Convert.ToByte(MyMinMax(Value, 0, 255));
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableCode(long Index, byte value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileCoded[Index] = value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableCode(long Index, string value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileCoded[Index] = MyKeyword_2_Byte(value);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Symbol_TableSymbolName(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_TableSymbolName = constantMyErrorCode.ToString();
                return;
            }
            Symbol_TableSymbolName = Symbol_FileSymbolName[Index];
        }



        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableSymbolName(long Index, string value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileSymbolName[Index] = value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Symbol_TableCoded_String(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_TableCoded_String = null;
                return;
            }
            Symbol_TableCoded_String = MyKeyword2String(Symbol_FileCoded[Index]);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        __int8  Symbol_TableCoded_Byte(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_TableCoded_Byte = default(__int8);
                return;
            }
            Symbol_TableCoded_Byte = Symbol_FileCoded[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Symbol_TableX1(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_TableX1 = default(Integer);
                return;
            }
            Symbol_TableX1 = Symbol_FileX1[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableX1(long Index, long value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileX1[Index] = value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Symbol_TableY1(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_TableY1 = default(Integer);
                return;
            }
            Symbol_TableY1 = Symbol_FileY1[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableY1(long Index, long value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileY1[Index] = value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Symbol_TableX2(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_TableX2 = constantMyErrorCode;
                return;
            }
            Symbol_TableX2 = Symbol_FileX2_io[Index];
        }

        string DataType_Table(long index)
        {
            if (InvalidIndex(index, DataType_FileName))
                return null;
            return DataType_FileName[index];
        }

        string Symbol_Table_InputOutput(long Index)
        {
            string Temp;
            long Temp1; // hack

            if (InvalidIndex(Index, Symbol_File_NameOfPoint))
                return null;

            Temp = Symbol_FileX2_io[Index]; // hack
            if (Temp > SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Count - 1)
                return null;
            if (Temp < 0)
                return null;

            Temp1 = Symbol_FileX2_io[Index]; // hack
            if (Temp1 > SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Count - 1)
                return null;
            if (Temp1 < 0)
                return null;

            Temp = SymbolScreen.ToolStripDropDownInputOutput.DropDownItems(Symbol_FileX2_io[Index]).Text;
            Symbol_Table_InputOutput = Pop(ref Temp, MyUniverse.SysGen.Constants.ConstantDelimeters);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableX2(long Index, long value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileX2_io[Index] = value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_Table_InputOutput(long Index, string value)
        {
            long jdex;
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            jdex = FindInputOutputIndex(value);
            Symbol_FileX2_io[Index] = jdex;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long Symbol_TableY2(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                // todo then return if it is a unenum.
                Abug(297, "This should not happen, invalid index on Y2/Datatype=", Index, "");
                return constantMyErrorCode;
            }
            // todo, should return a  string of the datatype if less than ?
            return Symbol_FileY2_dt[Index];
        }
        string Symbol_Table_DataType(long IndexSymbol)
        {
            if (InvalidIndex(IndexSymbol, Symbol_FileSymbolName))
            {
                Abug(298, "This should not happen, invalid index on Y2/Datatype=", IndexSymbol, "");
                return null;
            }
            // If Len(DataType_TableName(Symbol_TableY2(IndexSymbol))) = 0 Then
            // Return Nothing
            // End If
            return DataType_Table(Symbol_TableY2(IndexSymbol));
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_TableY2(long Index, long value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_FileY2_dt[Index] = value;
        }

        // ***********************************************************************
        // forces it to be a number
        long Dont_Use_NumberOrDT(long Y2_DT)
        {
            return Y2_DT; // Assumed it is a Value
        }


        // ***********************************************************************
        // forces it to find the index number
        long Dont_use_NumberOrDT(string Y2_DT)
        {
            long TempValue;
            TempValue = FindIndexIniSAMTable("DataType", "Do Not Add", ref DataType_FileName, ref DataType_Name_iSAM, Y2_DT);
            if (TempValue == constantMyErrorCode)
                return My_INT(Y2_DT);
            else
                return TempValue;// Assumed it is a Value
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_Table_DataType(long Index, string Value) // Assumed Datatype if passing a string
        {
            long Idex;
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Idex = FindIndexIniSAMTable("DataType", "DoNotAddadd", ref DataType_FileName, ref DataType_Name_iSAM, Value);
            if (Idex < 0)
            {
                if (Strings.Len(Value) == 0)
                    Idex = 0;
                else
                {
                    Idex = FindIndexIniSAMTable("DataType", "DoNotAddadd", ref DataType_FileName, ref DataType_Name_iSAM, "errored");
                    if (Idex < 0)
                        Idex = 0;
                    Abug(301, "Unable to find the data type " + HighLight(Value), "Forced to be errored", "");
                }
            }
            Symbol_TableY2(Index, Idex); // Save the number of the index into the Y of this symbol record (/point)
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string Symbol_Table_NameOfPoint(long Index)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
            {
                Symbol_Table_NameOfPoint = null;
                return;
            }
            Symbol_Table_NameOfPoint = Symbol_File_NameOfPoint[Index];
        }



        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void Symbol_Table_NameOfPoint(long Index, string value)
        {
            if (InvalidIndex(Index, Symbol_FileSymbolName))
                return;
            Symbol_File_NameOfPoint[Index] = value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string FlowChart_TableCode(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName))
            {
                // A I N F O 2 (996)
                FlowChart_TableCode = null;
                return;
            }
            FlowChart_TableCode = MyKeyword2String(FlowChart_FileCoded[IndexFlowChart]);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        // converts it from a  string (name or number passed as a styring) to save.
        void FlowChart_TableCode(long IndexFlowChart, string Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;
            switch (Strings.LCase(Value))
            {
            case "/use":
            case "5":
            {
                FlowChart_FileCoded[IndexFlowChart] = 5;
                break;
            }

            case "/path":
            case "6":
            {
                FlowChart_FileCoded[IndexFlowChart] = 6;
                break;
            }

            case "/delete":
            case "14":
            {
                FlowChart_FileCoded[IndexFlowChart] = 14;
                break;
            }

            case "/constant":
            case "15":
            {
                FlowChart_FileCoded[IndexFlowChart] = 15;
                break;
            }

            case "/error":
            case "13":
            {
                FlowChart_FileCoded[IndexFlowChart] = 13;
                break;
            }

            default:
            {
                FlowChart_FileCoded[IndexFlowChart] = 0; // unknown
                Abug(302, "FlowChart_TableCode():", "Unknown code ", Value);
                break;
            }
            }
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string FlowChart_TableSymbol_Name(long IndexFlowChart)
        {
            if (FlowChart_TableCode(IndexFlowChart) != "/use")
                Abug(484, "using a /use for a " + FlowChart_TableCode(IndexFlowChart), "", "");
            return FlowChart_Table_Path_SymbolName(IndexFlowChart);
        }
        string FlowChart_TablePath_Name(long IndexFlowChart)
        {
            return FlowChart_Table_Path_SymbolName(IndexFlowChart);
        }
        string FlowChart_TableOther_Name(long IndexFlowChart)
        {
            if (FlowChart_TableCode(IndexFlowChart) == "/path" | FlowChart_TableCode(IndexFlowChart) == "/use")
                Abug(488, "using a /path for a " + FlowChart_TableCode(IndexFlowChart), "", "");
            return FlowChart_Table_Path_SymbolName(IndexFlowChart);
        }

        string FlowChart_Table_Path_SymbolName(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
            {
                FlowChart_Table_Path_SymbolName = null;
                return;
            }

            FlowChart_Table_Path_SymbolName = FlowChart_FilePathSymbolName[IndexFlowChart];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void FlowChart_TablePathSymbolName(long IndexFlowChart, string Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;

            if (Strings.InStr(Value, MyUniverse.SysGen.Constants.RMStart) != 0)
            {
                Abug(299, "Path and symbol names should not have a ", MyUniverse.SysGen.Constants.RMStart, Value);
                Value = NameOfPointOnly(Value);
            }
            FlowChart_FilePathSymbolName[IndexFlowChart] = Value;
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
        }



        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long FlowChart_TablePathNumber(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return default(Integer);
            if (FlowChart_TableCode(IndexFlowChart) != "/path")
                return default(Integer);
            FlowChart_TablePathNumber = UseNetLinksNumber(IndexFlowChart);
        }

        // ***********************************************************************
        // cross between _pathnumber and net_names)
        string FlowChart_TablePathName(long IndexFlowChart)
        {
            long Temp;
            if (IndexFlowChart == MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart)
                return MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName;
            // AInfo1( 9 9 9 , "StackOverflow?", IndexFlowChart , "")
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return null;
            if (FlowChart_TableCode(IndexFlowChart) == "/path")
            {
                Temp = FindIndex_In_TableNetLinks(IndexFlowChart);
                if (Temp != 0)
                {
                    if (FlowChart_FilePathSymbolName[IndexFlowChart] != Net_TableNames(Temp))
                    {
                        Abug(304, "The name of the path is not the name of the linked path", IndexFlowChart, FindIndex_In_TableNetLinks(IndexFlowChart));
                        // FindingMyBugsFlowChart()
                        return "NOT_" + Temp.ToString() + FlowChart_FilePathSymbolName[IndexFlowChart];
                    }
                    else
                    {
                        // ainfo2(26)
                        FlowChart_TablePathName = FlowChart_FilePathSymbolName[IndexFlowChart];
                        MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName = FlowChart_FilePathSymbolName[IndexFlowChart];
                        MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart = IndexFlowChart;
                        return;
                    }
                }
            }
            else
                return null;
            Temp = FindIndex_In_TableNetLinks(IndexFlowChart);
            if (Temp == 0)
                MakeNew_NetLinks(IndexFlowChart, FlowChart_FilePathSymbolName[IndexFlowChart]);
            FlowChart_TablePathName = FlowChart_FilePathSymbolName[IndexFlowChart];
            MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName = FlowChart_FilePathSymbolName[IndexFlowChart];
            MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart = IndexFlowChart;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        // Removed           Shared Function FlowChart_TableCompiledMacroCodeText(IndexFlowChart  As long) As String
        // Removed             FlowChart_TableCompiledMacroCodeText = ""
        // Removed             If InvalidIndex(IndexFlowChart , FlowChart_FilePathSymbolName, FlowChart_iSAM_Name) Then
        // Removed                 Exit Function
        // Removed             End If
        // Removed             FlowChart_TableCompiledMacroCodeText = FlowChart_FileCompiledMacroCodeText(IndexFlowChart )
        // Removed         End Function


        // Removed  Shared Sub FlowChart_TableCompiledMacroCodeText(IndexFlowChart  As long, Value As String)
        // RemovedIf InvalidIndex(IndexFlowChart , FlowChart_FilePathSymbolName, FlowChart_iSAM_Name) Then
        // RemovedExit Sub
        // RemovedEnd If
        // RemovedIf IsNothing(Value) Then
        // RemovedAInfo(632, "NOT Saving nothing thing", CStr(IndexFlowChart ), HighLight(Value) & MyShowFlowChartRecord(IndexFlowChart ))
        // RemovedExit Sub
        // RemovedEnd If
        // RemovedFlowChart_FileCompiledMacroCodeText(IndexFlowChart ) = Value
        // Removed        End Sub

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long FlowChart_TableX1(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
            {
                FlowChart_TableX1 = default(Integer);
                return;
            }
            FlowChart_TableX1 = FlowChart_FileX1[IndexFlowChart];
            // FindingMyBUgXY(IndexFlowChart)
            Tracing(IndexFlowChart, FlowChart_TableX1);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void FlowChart_TableX1(long IndexFlowChart, long Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;

            FlowChart_FileX1[IndexFlowChart] = Value;
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
            // FindingMyBUgXY(IndexFlowChart)
            Tracing(IndexFlowChart, Value);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long FlowChart_TableY1(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
            {
                FlowChart_TableY1 = default(Integer);
                return;
            }
            FlowChart_TableY1 = FlowChart_FileY1[IndexFlowChart];
            // FindingMyBUgXY(IndexFlowChart)
            Tracing(IndexFlowChart, FlowChart_TableY1);
        }



        void FlowChart_TableY1(long IndexFlowChart, long Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;
            if (Value == 0)
                Abug(809, "Can Not have Y1 = 0", Value, "");
            FlowChart_FileY1[IndexFlowChart] = Value;
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
            // FindingMyBUgXY(IndexFlowChart)
            Tracing(IndexFlowChart, Value);
        }



        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string FlowChart_Table_Rotation(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return null;
            FlowChart_Table_Rotation = MyUnEnum(FlowChart_TableX2(IndexFlowChart), SymbolScreen.ToolStripDropDownRotation, 0);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long FlowChart_TableX2(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return default(Integer);
            FlowChart_TableX2 = FlowChart_File_X2_Rotation[IndexFlowChart];
            Tracing(IndexFlowChart, FlowChart_TableX2);
        }
        void FlowChart_TableX2(long IndexFlowChart, long Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;
            FlowChart_File_X2_Rotation[IndexFlowChart] = Value;
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
            Tracing(IndexFlowChart, Value);
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void FlowChart_Table_Rotation(long IndexFlowChart, string Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;
            FlowChart_File_X2_Rotation[IndexFlowChart] = FindInDropDownButton(Value, SymbolScreen.ToolStripDropDownRotation);
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long FlowChart_TableY2(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return default(Integer);
            FlowChart_TableY2 = FlowChart_File_Y2_Option[IndexFlowChart];
            Tracing(IndexFlowChart, FlowChart_TableY2);
        }


        string FlowChart_TableOption(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return null;
            if (FlowChart_File_Y2_Option[IndexFlowChart] > MyUniverse.MySystem.FlowChartOptions.Length)
                return null;
            if (FlowChart_File_Y2_Option[IndexFlowChart] < 0)
                return null;
            FlowChart_TableOption = MyUniverse.MySystem.FlowChartOptions[FlowChart_File_Y2_Option[IndexFlowChart]].OptionNames;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void FlowChart_TableY2(long IndexFlowChart, long Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                // FlowChart_TableY2_Option = Nothing
                return;
            FlowChart_File_Y2_Option[IndexFlowChart] = Value;
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
            Tracing(IndexFlowChart, Value);
        }
        void FlowChart_TableOption(long IndexFlowChart, string Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return;
            FlowChart_File_Y2_Option[IndexFlowChart] = FindInDropDownButton(Value, FlowChartScreen.ToolStripDropDownSelectSymbol);
            MyUniverse.MyCheatSheet.FlowChartSorted += 1;
            FindingMyBUgXY(IndexFlowChart);
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string FlowChart_Table_DataType(long IndexFlowChart)
        {
            // check if we are inside the limits of the table
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                return null;
            FlowChart_Table_DataType = FlowChart_File_DataType[IndexFlowChart];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void FlowChart_Table_DataType(long IndexFlowChart, string Value)
        {
            if (InvalidIndex(IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name))
                // FlowChart_Table_DataType = Nothing
                return;
            FlowChart_File_DataType[IndexFlowChart] = Value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string DataType_TableName(long Index)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
            {
                DataType_TableName = null;
                return;
            }
            DataType_TableName = DataType_FileName[Index];
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void DataType_TableName(long Index, string Value)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
                return;
            DataType_FileName[Index] = Value;
            MyUniverse.MyCheatSheet.DataTypeSorted += 1;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string DataType_Color(long Index) // returns the name of this color number in the color table
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
            {
                DataType_Color = null;
                return;
            }
            DataType_Color = Color_FileName[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        long DataType_TableColorIndex(long Index)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
                return -1;
            DataType_TableColorIndex = DataType_FileColorIndex[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void DataType_TableColorIndex(long Index, long Value)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
                return;
            if (Value < 1)
                Abug(305, "This datatype does not have a valid color set ", Value.ToString(), Index.ToString());
            DataType_FileColorIndex[Index] = Value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string DataType_TableDescribtion(long Index)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
            {
                DataType_TableDescribtion = null;
                return;
            }
            DataType_TableDescribtion = DataType_FileDescribtion[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void DataType_TableDescribtion(long Index, string Value)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
                return;
            DataType_FileDescribtion[Index] = Value;
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        __int8  DataType_TableWidth(long Index)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
            {
                DataType_TableWidth = default(__int8);
                return;
            }
            DataType_TableWidth = DataType_FileWidth[Index];
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void DataType_TableWidth(long Index, __int8  Value)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
                return;
            DataType_FileWidth[Index] = Value;
        }


        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        string DataType_TableNumberOfBytes(long Index)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
            {
                DataType_TableNumberOfBytes = null;
                return;
            }
            DataType_TableNumberOfBytes = System.Convert.ToString(DataType_FileNumberOfBytes[Index]);
        }

        // ***********************************************************************
        // This is to isolate the actual data from the program (So that it can be converted later versions)
        void DataType_TableNumberOfBytes(long Index, long Value)
        {
            if (InvalidIndex(Index, ref DataType_FileName, ref DataType_Name_iSAM))
                return;
            DataType_FileNumberOfBytes[Index] = Value;
        }


        // ***********************************************************************
        // checks that everything sorted correctly 
        // hack
        // can delete when it no longer finds issues
        bool MyIsValidCheckSortAll_String(string MyTable, string MyArray[], long iSAM[])
        {
            long Idex, Topmost;
            Topmost = TopOfFile(MyTable); // UBound(MyArray) ' Changed 04/09/19 to get a lower number checking
            MyIsValidCheckSortAll_String = true;

            for (Idex = Topmost; Idex >= 2; Idex += -1)
            {
                if (Information.IsNothing(MyArray[Idex]) & iSAM[Idex] != 0)
                {
                    MyMsgCtr(1385, "MyIsValidCheckSortAll_String", Idex.ToString(), iSAM[Idex].ToString(), "Data Set to Nothing", "", "", "", "", "", "");
                    MyIsValidCheckSortAll_String = false; // Can not index nothing?
                }
                if (iSAM[Idex] <= 0 | iSAM[Idex] > Information.UBound(MyArray))
                {
                    MyIsValidCheckSortAll_String = false;
                    break;
                }

                // If two iSAMs equal each other then we have major issues with the iSAM
                if (iSAM[Idex] != 0 & iSAM[Idex - 1] == iSAM[Idex])
                {
                    // MyMsgCtr(1017, "MyIsValidCheckSortAll_String", Idex - 1, iSAM(Idex - 1).ToString, Idex, iSAM(Idex).ToString, "", "", "", "", "")
                    MyIsValidCheckSortAll_String = false;
                    break;
                }
                if (iSAM[Idex - 1] == iSAM[Idex])
                {
                    MyMsgCtr(1003, "MyIsValidCheckSortAll_String", (Idex - 1).ToString(), Idex.ToString(), MyCompared1_a(MyArray[iSAM[Idex - 1]].ToString(), MyArray[iSAM[Idex]]).ToString(), MyArray[iSAM[Idex - 1]].ToString(), MyArray[iSAM[Idex]].ToString(), "", "", "", "2"); // EXTRA so I can see why it's here
                    MyIsValidCheckSortAll_String = false;
                    FindingMyBugs(10); // hack Least amount of checking here
                    break;
                }
                // Is Array Is out of order (returns 0 if equal, -1 if A < B, 1 if A > B which is an error
                if (MyCompared2(ref MyArray, ref iSAM, Idex - 1, Idex) == 1)
                {
                    MyIsValidCheckSortAll_String = false;
                    switch (Strings.LCase(MyTable))
                    {
                    case "FlowChart":
                    {
                        MyUniverse.MyCheatSheet.FlowChartSorted += 1;
                        break;
                    }

                    case "datatype":
                    {
                        MyUniverse.MyCheatSheet.DataTypeSorted += 1;
                        break;
                    }

                    case "color":
                    {
                        MyUniverse.MyCheatSheet.ColorsSorted += 1;
                        break;
                    }

                    case "named":
                    {
                        MyUniverse.MyCheatSheet.NamedSorted += 1;
                        break;
                    }

                    default:
                    {
                        MyUniverse.MyCheatSheet.FlowChartSorted += 1;
                        MyUniverse.MyCheatSheet.DataTypeSorted += 1;
                        MyUniverse.MyCheatSheet.ColorsSorted += 1;
                        MyUniverse.MyCheatSheet.NamedSorted += 1;
                        break;
                    }
                    }
                    break;
                }
            }
        }
        // ***********************************************************************
        // This is to make sure that all array referances are inside the array
        bool InvalidIndex(long Index, string[] MyArray)
        {
            if (Index < 1)
                return true;// I dont use array zero
            if (Index > Information.UBound(MyArray))
                return true;
            return false;
        }


        // change to be fewer test 2020 09 02
        // '*******************************************************************
        // Checking if the index to the array is inside the bounds or not.
        // It should never be outside, or else there is a programming bug again
        bool InvalidIndex(long Index, string MyArray[], long iSAM[])
        {
            if (Index < 1)
                return true;// Index has not been set yet
            if (Index >= Information.UBound(iSAM) - 1)
                return true;
            if (iSAM[Index] < 1)
                return true;// Isam index has not been set

            if (Information.UBound(MyArray) != Information.UBound(iSAM))
            {
                AInfo1(735, "Invalid index program error the array is not the same size as the index isam", Index.ToString(), "");
                return true;
            }
            if (Index != MyMinMax(Index, 1, Information.UBound(MyArray)))
            {
                AInfo1(736, "Invalid index is not between ", Index.ToString(), "Low=1,High=" + Information.UBound(MyArray).ToString());
                return true;
            }
            if (iSAM[Index] != MyMinMax(iSAM[Index], 1, Information.UBound(iSAM)))
            {
                AInfo1(737, "Invalid ISAM index is not between ", Index.ToString(), "Low=1,High=" + Information.UBound(iSAM).ToString());
                return true;
            }
            return false;
        }


        // ***********************************************************************
        // Checks to see if it is a valid index for this array
        bool InvalidIndex(long Index, long[] MyArrayLong, long iSAM[])
        {
            if (Index < 1)
                return true;
            if (Index > Information.UBound(iSAM))
                return true;
            if (iSAM[Index] < 1)
                return true;
            if (MyArrayLong[Index] == default(Integer))
                return true;
            if (Information.UBound(MyArrayLong) != Information.UBound(iSAM))
            {
                AInfo1(738, "Number array and ISAM is not the same size ", Information.UBound(MyArrayLong).ToString(), Information.UBound(iSAM).ToString());
                return true;
            }
            if (Index != MyMinMax(Index, 1, Information.UBound(MyArrayLong)))
            {
                AInfo1(739, "Index for number is invalid ", Index.ToString(), "low=1,High=" + Information.UBound(MyArrayLong).ToString());
                return true;
            }
            if (iSAM[Index] != MyMinMax(iSAM[Index], 1, Information.UBound(iSAM)))
            {
                AInfo1(741, "ISAM Index for number is invalid ", iSAM[Index].ToString(), "low=1,High=" + Information.UBound(iSAM).ToString());
                return true;
            }
            if (iSAM[Index] != 0 & MyArrayLong[Index] == default(Integer))
            {
                AInfo1(742, "ISAM Index in number Array is not set ", iSAM[Index].ToString(), "");
                return true;
            }
            return false;
        }

        // ***********************************************************************
        // This will replace the  string with it replacement 
        string MyReplaceAll(string InputString, string ChangeFrom, string ChangeTo)
        {
            int I, K, K1, K2;
            MyReplaceAll = InputString;
            I = Strings.InStr(Strings.Chr(179), InputString);
            while (I != 0)
            {
                MyReplaceAll = Strings.Mid(MyReplaceAll, 1, I) + MyUniverse.SysGen.Constants.ConstantGotoNextLine + Strings.Mid(MyReplaceAll, I, Strings.Len(MyReplaceAll));
                K1 = InsertGotoNextLine(ref MyReplaceAll, I, I); // Add it first so that the I does not change
                K2 = InsertCameFromLine(ref MyReplaceAll, I + K1, I); // After the cr
                // need to also add a CameFromLine before the cr and a GotoNextLine after it 
                K = I + Strings.Len(MyFlowChartNameSpace.F_C.MyUniverse.ProgramOptions.C_L_MultiLine) + Strings.Len(MyUniverse.SysGen.Constants.ConstantGotoNextLine) + Strings.Len(MyUniverse.SysGen.Constants.ConstantCameFromLine);
                I = Strings.InStr(K, MyReplaceAll, Strings.Chr(179));
            }
        }

        // ***********************************************************************
        // This sets, or unsets a bit option
        // Level is the number 1-1000, and passed on/off , yes/no, true/false
        void BitSet(long Level, string SetBitTo)
        {
            long MyByte;
            long MyBit;
            if (Level < 9 | Level > 10000 - 1)
            {
                Abug(306, "BitSet() : ", Level, SetBitTo);
                MyMsgCtr(1436, "BitSet", "Invalid Message Error Number " + Level, "ERROR *******", "", "", "", "", "", "", "");
            }
            MyByte = System.Convert.Tolong(Conversion.Fix(Level / (double)8));
            MyByte = MyMinMax(MyByte, 1, Information.UBound(MyMessageBits) - 1);
            MyBit = MyMinMax(Level - (MyByte * 8), 0, 7);

            switch (Strings.LCase(SetBitTo))
            {
            case "yes":
            case "true":
            case "on":
            {
                MyMessageBits[MyByte] = System.Convert.ToByte(MyMessageBits[MyByte] | MyBits[MyBit]);
                break;
            }

            case "no":
            case "false":
            case "off":
            {
                MyMessageBits[MyByte] = System.Convert.ToByte(MyMessageBits[MyByte] & (!MyBits[MyBit]));
                break;
            }

            case "otherthingsxxxx" // Options for the third parameter
                :
            {
                break;
            }

            default:
            {
                MyMsgCtr(1000, "BitSet", "bitset()  Not yes,no, True,False, On,off ", "Set To >" + SetBitTo + "<", " Level=" + Level, " Bit=" + MyBit, " Byte=" + MyByte, "", "", "", "");
                break;
            }
            }
        }

        // ***********************************************************************
        // returns if the bit is set or not
        bool IsBitSet(long Level)
        {
            long MyByte;
            long MyBit;
            long Temp;
            MyByte = System.Convert.Tolong(Conversion.Fix(Level / (double)8));
            MyByte = MyMinMax(MyByte, 1, Information.UBound(MyMessageBits) - 1);
            MyBit = MyMinMax(Level - (MyByte * 8), 0, 7);

            Temp = MyMessageBits[MyByte] & MyBits[MyBit];

            if ((MyMessageBits[MyByte] & MyBits[MyBit]) > 0)
                IsBitSet = true;
            else
                IsBitSet = false;
        }


        // ***********************************************************************
        // NOT USED
        // This returns if the point is closest enough to move (snap grid)

        bool FlowChart_XY_IsClose(long Index, long X1, long Y1, long X2, long Y2)
        {
            long Dist;
            FlowChart_XY_IsClose = false;
            if (Index < 1)
                return;
            Dist = MyDistance(MyPoint1XY(X1, Y1), MyPoint2XY(X2, Y2));
            if (Dist <= MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
                FlowChart_XY_IsClose = true;

            if (MyABS(X1 - X2) < MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
                FlowChart_XY_IsClose = true;

            if (MyABS(Y1 - Y2) < MyUniverse.SysGen.Constants.constantDistanceToMovePaths)
                FlowChart_XY_IsClose = true;
        }


        void CheckAndFixSintax()
        {
            for (var IndexNamed = 1; MyUniverse.MySS.MyIndexEs.IndexNamed <= TopOfFile("named"); MyUniverse.MySS.MyIndexEs.IndexNamed++)
            {
                Named_FileSintax_Isam[MyUniverse.MySS.MyIndexEs.IndexNamed] = MyUniverse.MySS.MyIndexEs.IndexNamed;
                if (Named_TableSintax(MyUniverse.MySS.MyIndexEs.IndexNamed) == "")
                {
                    if (MyTrim(Named_TableMicroCodeText(MyUniverse.MySS.MyIndexEs.IndexNamed)) == "")
                    {
                        Abug(307, "No Program Text", "No Syntax", Named_TableSymbolName(MyUniverse.MySS.MyIndexEs.IndexNamed));
                        Named_TableMicroCodeText(MyUniverse.MySS.MyIndexEs.IndexNamed, MyUniverse.ProgramOptions.C_L_Comment);
                        Named_TableSintax(MyUniverse.MySS.MyIndexEs.IndexNamed, MyUniverse.ProgramOptions.C_L_Comment);
                    }
                    else if (PrintAbleNull(Named_TableSintax(MyUniverse.MySS.MyIndexEs.IndexNamed)) == "_")
                    {
                        MyUniverse.MySS.Inputs.KeyParameters = MyTrim(Named_TableMicroCodeText(MyUniverse.MySS.MyIndexEs.IndexNamed));
                        Pop(ref MyUniverse.MySS.Inputs.KeyParameters, MyUniverse.SysGen.Constants.ConstantDelimeters); // get ride of the sort section of the program text
                        Named_TableSintax(MyUniverse.MySS.MyIndexEs.IndexNamed, Strings.Trim(Convertmicrocodetext2Sintax(ref My_CodeLine_Parsed, MyUniverse.MySS.Inputs.KeyParameters)));
                    }
                }
                MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, MyUniverse.MySS.MyIndexEs.IndexNamed);
                MyReSort("Named", ref Named_FileSintax, ref Named_FileSintax_Isam, TopOfFile("named"));
            }
        }


        // ***********************************************************************
        // Checking if I had forgotten to sort an array?
        void CheckForAnySortNeeded(string WhereFrom, long Level)
        {
            long Idex;
            if (MyUniverse.MyCheatSheet.ColorsSorted != 0)
            {
                ShowSorts("Colors", SortColors()); MyUniverse.MyCheatSheet.ColorsSorted = 0;
            }
            if (MyUniverse.MyCheatSheet.DataTypeSorted != 0)
            {
                ShowSorts("DataType", SortDataType()); MyUniverse.MyCheatSheet.DataTypeSorted = 0;
            }
            if (MyUniverse.MyCheatSheet.NamedSorted != 0)
            {
                ShowSorts("Named", SortNamed());
                // This is just to make sure the symbol table is still in order
                for (Idex = 1; Idex <= TopOfFile("named"); Idex++)
                    GetSelfCorrectingIndexes(Named_TableSymbolName(Idex));
                MyUniverse.MyCheatSheet.NamedSorted = 0;
            }
            if (MyUniverse.MyCheatSheet.FlowChartSorted != 0)
            {
                ShowSorts("FlowChart", SortFlowChart());
                MyUniverse.MyCheatSheet.FlowChartSorted = 0;
            }
        }

        // ***********************************************************************
        // Checking that everything is OK
        // Should be called inside of findingmybugs
        bool MyCheckValidFlowChartRecord(long Index)
        {
            // First check if valid Index
            if (Index < 1)
                // MyMsgCtr(1390, "MyCheckValidFlowChartRecord", Index.ToString, "", "", "", "", "", "", "", "")
                return false;
            if (Index > TopOfFile("FlowChart"))
                // MyMsgCtr(1250, "MyCheckValidFlowChartRecord", Index.ToString, TopOfFile("FlowChart"), "", "", "", "", "", "", "")
                return false;
            // Next check for a valid code
            // Also Then CHeck for the correct information on each type of Record
            switch (Strings.LCase(FlowChart_TableCode(Index)))
            {
            case "/use":
            {
                if (MyCheckValidUse(Index) == false)
                    return false;
                break;
            }

            case "/path":
            {
                if (ConnectPath(Index) == 0)
                    return false;
                break;
            }

            case "/constant":
            {
                break;
            }

            case "/error":
            {
                break;
            }

            default:
            {
                MyMsgCtr(1438, "MyCheckValidFlowChartRecord", FlowChart_TableCode(Index), Index.ToString(), "", "", "", "", "", "", "");
                return false;
            }
            }
            // if it makes all of these test then it must be a good/ok record ?
            return true;
        }

        // ***********************************************************************
        bool MyCheckValidUse(long IndexFlowChart)
        {
            long Temp;
            MyCheckValidUse = false;
            // for now print out all things that are being checked
            // Check if valid index
            if (MyCheckIndex_String("FlowChart", IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name) == false)
                return;
            // if named
            if (Strings.Len(FlowChart_TableSymbol_Name(IndexFlowChart)) < 1)
            {
                MyMsgCtr(1164, "MyCheckValidUse", Conversion.Str(IndexFlowChart), MyShowFlowChartRecord(IndexFlowChart), "", "", "", "", "", "", "");
                return;
            }
            // use code           
            switch (Strings.LCase(FlowChart_TableCode(IndexFlowChart)))
            {
            case "/use":
            {
                break;
            }

            default:
            {
                // MyMsgCtr(1159, "MyCheckValidUse", FlowChart_TableCode(IndexFlowChart), "", "", "", "", "", "", "", "")
                return;
            }
            }
            // Checking that ALL iSAMs are indexed to something. (Should also make sure that it returns a match to what it is searching for
            // name
            Temp = FindIndexIniSAMTable("FlowChart", "DontAdd", ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name, FlowChart_TableSymbol_Name(IndexFlowChart));
            if (Temp < 1)
                MyCheckValidUse = MyCheckIndex_String("FlowChart", IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name);
            // X1
            Temp = FindIndexIniSAMTable("FlowChart", ref "DontAdd", ref FlowChart_FileX1, ref FlowChart_iSAM_X1, ref FlowChart_TableX1(IndexFlowChart));
            if (Temp < 1)
                MyCheckValidUse = MyCheckIndex_String("FlowChart", IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name);
            // Y1
            // ?Temp = FindIndexIniSAMTable("FlowChart", "DontAdd", FlowChart_FileY1, FlowChart_iSAM_Y1, FlowChart_TableY1(IndexFlowChart ))
            if (MyCheckIndex_String("FlowChart", IndexFlowChart, ref FlowChart_FilePathSymbolName, ref FlowChart_iSAM_Name) == false)
                return;
            if (FlowChart_Table_Rotation(IndexFlowChart) == null)
            {
                MyMsgCtr(1163, "MyCheckValidUse", IndexFlowChart.ToString(), "\"", "", "", "", "", "", "", "");
                return;
            }
            // All Else works so it must be OK
            MyCheckValidUse = true;
        }


        // ***********************************************************************
        bool MyCheckIndex_long(string MyTable, long Index, long[] MyArray, long iSAM[]) // returns false if the index is outside the array
        {
            if (Index < 1)
                // MyMsgCtr(1158, "MyCheckIndex_long", Index.ToString, "", "", "", "", "", "", "", "")
                return false;
            if (Index > TopOfFile(MyTable))
                // MyMsgCtr(1256, "MyCheckIndex_long", Str(Index), Str(TopOfFile(MyTable)), "", "", "", "", "", "", "")
                return false;
            if (iSAM[Index] != 0 & iSAM[Index - 1] == iSAM[Index])
            {
                DisplayMyStatus("7845  Index Is wrong  index=" + Index + " iSAM = " + iSAM[Index - 1] + " : " + iSAM[Index]);
                return false;
            }
            if (iSAM[1] != 0 & iSAM[1] == iSAM[2])
            {
                MyMsgCtr(1169, "MyCheckIndex_long", "", "", "", "", "", "", "", "", "");
                return false;
            }
            if (Index == 0)
                // MyMsgCtr(1170, "MyCheckIndex_long", Index.ToString, iSAM(Index).ToString, "", "", "", "", "", "", "Index < 1")
                return false;
            if (iSAM[Index] == 0)
                // MyMsgCtr(1170, "MyCheckIndex_long", Index.ToString, iSAM(Index).ToString, "", "", "", "", "", "", "iSAM(index) < 1")
                return false;
            return true;
        }


        bool MyCheckIndex_String(string MyTable, long Index, string MyArray[], long iSAM[])
        {
            MyCheckIndex_String = false;
            if (Index < 1)
                // MyMsgCtr(1158, "MyCheckIndex_String", Index.ToString, "", "", "", "", "", "", "", "")
                return;
            if (Index > TopOfFile(MyTable))
                // MyMsgCtr(1256, "MyCheckIndex_String", Str(Index), Str(TopOfFile(MyTable)), "", "", "", "", "", "", "")
                return;
            if (iSAM[Index] != 0 & iSAM[Index - 1] == iSAM[Index])
            {
                DisplayMyStatus("7845  Index Is wrong  index=" + Index + " iSAM = " + iSAM[Index - 1] + " : " + iSAM[Index]);
                return;
            }
            if (iSAM[1] != 0 & iSAM[1] == iSAM[2])
            {
                MyMsgCtr(1169, "MyCheckIndex_String", "", "", "", "", "", "", "", "", "");
                return;
            }
            if (Index == 0)
                // MyMsgCtr(1170, "MyCheckIndex_String", Index.ToString, iSAM(Index).ToString, "", "", "", "", "", "", "Index < 1")
                return;
            if (iSAM[Index] == 0)
                // MyMsgCtr(1170, "MyCheckIndex_String", Index.ToString, iSAM(Index).ToString, "", "", "", "", "", "", "iSAM(index) < 1")
                return;
            MyCheckIndex_String = true;
        }


        // **********************************************************************
        // replacement string
        string MyReplace(string InputString, string FindingString, long long ReplacementNumber)
        {
            kljhasdflkj
                convert number to string
                string = new  replacementNumber
        }

        string MyReplace(string InputString, string FindingString, string ReplacementString)
        {
            MyReplace = Strings.Replace(InputString, FindingString, ReplacementString, null/* Conversion error: Set to default value for this argument */, null/* Conversion error: Set to default value for this argument */, CompareMethod.Text);
        }


        string HighLight(string ShowString)
        {
            if (Information.IsNothing(ShowString))
                return ">?<";
            else
                return ">" + ShowString + "<";
        }

        string ShortHighLight(string ShowString)
        {
            if (Information.IsNothing(ShowString))
                return "[nil]";
            else
                return "[" + ShowString + "]";
        }


        // input the "/text"  string (what ever) and return the  string with each line starting with that switch (used for all multi line import/export
        string MyShowMultilineText(string MySwitch, string OutputText)
        {
            string Temp;
            Temp = OutputText;
            MyShowMultilineText = "";
            while (Strings.Len(Temp) > 0)
                MyShowMultilineText = Constants.vbCrLf + MySwitch + "=" + PopLine(ref Temp);

            if (Strings.Len(MyShowMultilineText) > 0)
                MyShowMultilineText += Constants.vbCrLf;
        }


        string MyShowUsePoints(long IndexFlowChart)
        {
            long IndexNamed, IndexSymbol;
            MyPointStructure XY1, XY2;
            MyShowUsePoints = "";
            XY1 = default(MyPointStructure);
            XY1.Xx = FlowChart_TableX1(IndexFlowChart);
            XY1.Yy = FlowChart_TableY1(IndexFlowChart);
            IndexNamed = FindInNamedList(FlowChart_TableSymbol_Name(IndexFlowChart));
            if (IndexNamed < 1)
                return "No Symbol " + HighLight(FlowChart_TableSymbol_Name(IndexFlowChart));
            IndexSymbol = GetSelfCorrectingIndexes(Named_TableSymbolName(IndexNamed));
            if (IndexSymbol < 1)
                return "No Points " + Named_TableSymbolName(IndexNamed);
            MyShowUsePoints = MyShowSymbolPoint(IndexSymbol);
            IndexSymbol += 1; // jump over the name 
            while (IndexSymbol < TopOfFile("Symbol"))
            {
                switch (Symbol_TableCoded_String(IndexSymbol))
                {
                case "/name":
                {
                    return;
                }

                case "/point":
                {
                    XY2 = MyRotated_1(IndexSymbol, XY1, FlowChart_Table_Rotation(IndexFlowChart));
                    MyShowUsePoints += FD + MyShowPoint(XY2);
                    break;
                }

                case "/line" // ignore
                    :
                {
                    break;
                }

                default:
                {
                    MyShowUsePoints += FD + MyShowSymbolPoint(IndexSymbol);
                    break;
                }
                }
                IndexSymbol += 1;
            }
        }


        string MyShowFlowChartRecordX(long IndexFlowChart)
        {
            MyShowFlowChartRecordX = FlowChart_FileCoded[IndexFlowChart] + "=" + FlowChart_TablePath_Name(IndexFlowChart);
            MyShowFlowChartRecordX += FD + FlowChart_FileX1[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_FileY1[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_File_X2_Rotation[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_File_Y2_Option[IndexFlowChart];
            MyShowFlowChartRecordX += FD + PrintAbleNull(FlowChart_FilePathSymbolName[IndexFlowChart]);
            MyShowFlowChartRecordX += FD + PrintAbleNull(FlowChart_File_DataType[IndexFlowChart]);
            MyShowFlowChartRecordX += FD & "\\Index=" + IndexFlowChart.ToString();
            MyShowFlowChartRecordX += FD + FlowChart_iSAM_Name[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_iSAM_X1[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_iSAM_Y1[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_iSAM_X2[IndexFlowChart];
            MyShowFlowChartRecordX += FD + FlowChart_iSAM_Y2[IndexFlowChart];
        }




        string MyShowPath(long idex)
        {
            MyShowPath = FlowChart_TableCode(idex) + " = " + FlowChart_TablePathName(idex);
            MyShowPath += FD + FlowChart_TableX1(idex);
            MyShowPath += FD + FlowChart_TableY1(idex);
            MyShowPath += FD + FlowChart_TableX2(idex);
            MyShowPath += FD + FlowChart_TableY2(idex);
            MyShowPath += FD + FlowChart_Table_DataType(idex);
            if (MyOptionTest(22) == true)
            {
                MyShowPath += FD & "\\Index=" + idex;
                MyShowPath += FD & "\\" + MyShowNetLnks(FindIndex_In_TableNetLinks(idex));
            }
        }

        string MyShowFlowChartRecord(long IndexFlowChart)
        {
            if (InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName))
                return "/error=Invalid Index : " + ShortHighLight(IndexFlowChart.ToString());
            // If PrintAbleNull(FlowChart_TablePathSymbol_Name(IndexFlowChart )) = "_" Then
            // If PrintAbleNull(FlowChart_TablePathName(IndexFlowChart )) = "_" Then
            // Return "/error=Invalid Symbol Name : " & IndexFlowChart 
            // End If
            // End If
            // ainfo2(27)
            switch (FlowChart_TableCode(IndexFlowChart))
            {
            case "/use":
            {
                MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) + "=" + FlowChart_TableSymbol_Name(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableX1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_Table_Rotation(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_Table_DataType(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableOption(IndexFlowChart);
                if (MyOptionTest(22) == true)
                {
                    MyShowFlowChartRecord += FD & "\\Index=" + IndexFlowChart.ToString();
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathName(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart));
                    // todo also output every symbol point where it is at.
                    MyShowFlowChartRecord += FD + MyShowUsePoints(IndexFlowChart);
                }

                break;
            }

            case "/path":
            {
                MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) + "=" + FlowChart_TablePath_Name(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableX1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableX2(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY2(IndexFlowChart);
                MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathName(IndexFlowChart));
                MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart));
                if (MyOptionTest(22) == true)
                {
                    MyShowFlowChartRecord += FD & "\\Index=" + IndexFlowChart.ToString();
                    MyShowFlowChartRecord += FD + "name=" + FlowChart_iSAM_Name[IndexFlowChart];
                    MyShowFlowChartRecord += FD + "x1=" + FlowChart_iSAM_X1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + "y1=" + FlowChart_iSAM_Y1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + "x2=" + FlowChart_iSAM_X2[IndexFlowChart];
                    MyShowFlowChartRecord += FD + "y2=" + FlowChart_iSAM_Y2[IndexFlowChart];
                }

                break;
            }

            case "/error":
            {
                // This is for debugging only need to fix
                // todo make this into the correct inport/export format
                // FormatError = "/error = Code" & FD & " name" & FD & " x1" & FD & " y1" & FD & " Name " & FD & " {other things maybe}"
                MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) + "=" + FindInSymbolList(ref FlowChart_TableOther_Name(IndexFlowChart));
                MyShowFlowChartRecord += "(" + FlowChart_TableX1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY1(IndexFlowChart);
                MyShowFlowChartRecord += ")_(" + FlowChart_TableX2(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY2(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_Table_DataType(IndexFlowChart);
                if (MyOptionTest(22) == true)
                {
                    MyShowFlowChartRecord += FD & "\\index=" + IndexFlowChart.ToString();
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathName(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart));
                    // Removed                     myshowflowchartrecord &= FD &  PrintAbleNull(FlowChart_TableCompiledMacroCodeText(IndexFlowChart ))
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Name[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_X1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_X2[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y2[IndexFlowChart];
                }

                break;
            }

            case "/origin":
            {
                // This is for debugging only need to fix
                // todo make this into the correct inport/export format
                // FormatError = "/error = Code" & FD & " name" & FD & " x1" & FD & " y1" & FD & " Name " & FD & " {other things maybe}"
                MyShowFlowChartRecord = "/" + FlowChart_TableCode(IndexFlowChart) + "=" + FindInSymbolList(ref FlowChart_TableOther_Name(IndexFlowChart));
                MyShowFlowChartRecord += "(" + FlowChart_TableX1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY1(IndexFlowChart);
                MyShowFlowChartRecord += ")_(" + FlowChart_TableX2(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY2(IndexFlowChart);
                if (MyOptionTest(22) == true)
                {
                    MyShowFlowChartRecord += FD & "\\" + IndexFlowChart.ToString();
                        MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathName(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart));
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Name[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_X1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_X2[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y2[IndexFlowChart];
                }

                break;
            }

            case "/constant":
            {
                // todo make this into the correct inport/export format
                // This is for debugging only need to fix
                // formatConstant = "\\Constant=name " & FD & " X" & FD & " Y" & FD & " Value"
                // todo make this into the correct inport/export format
                MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) + "=" + FindInSymbolList(ref FlowChart_TableOther_Name(IndexFlowChart));
                MyShowFlowChartRecord += FD + Constants.vbTab + "/ConstantInfo" + FlowChart_TableCode(IndexFlowChart) + "=" + Net_TableLinks(FindIndex_In_TableNetLinks(IndexFlowChart));
                MyShowFlowChartRecord += FD + "(" + FlowChart_TableX1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FD + FlowChart_TableY1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FD + PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart));
                MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart));
                MyShowFlowChartRecord += FD + FD + FlowChart_TableOption(IndexFlowChart);
                MyShowFlowChartRecord += FD + FD + FlowChart_Table_DataType(IndexFlowChart);
                if (MyOptionTest(22) == true)
                {
                    MyShowFlowChartRecord += FD + FD & "\\index=" + IndexFlowChart.ToString();
                    MyShowFlowChartRecord += FD + FD + PrintAbleNull(FlowChart_TablePathName(IndexFlowChart));
                    MyShowFlowChartRecord += FD + FD + PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart));
                    MyShowFlowChartRecord += FD + FD + FlowChart_iSAM_Name[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FD + FlowChart_iSAM_X1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FD + FlowChart_iSAM_Y1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FD + FlowChart_iSAM_X2[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y2[IndexFlowChart];
                }

                break;
            }

            default:
            {
                MyShowFlowChartRecord = FlowChart_TableCode(IndexFlowChart) + "=" + FindInSymbolList(ref FlowChart_TableOther_Name(IndexFlowChart));
                MyShowFlowChartRecord += FD + FlowChart_TableX1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY1(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableX2(IndexFlowChart);
                MyShowFlowChartRecord += FD + FlowChart_TableY2(IndexFlowChart);
                if (MyOptionTest(22) == true)
                {
                    MyShowFlowChartRecord += FD & "\\index" + IndexFlowChart.ToString();
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_Rotation(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_Table_DataType(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathName(IndexFlowChart));
                    MyShowFlowChartRecord += FD + PrintAbleNull(FlowChart_TablePathNumber(IndexFlowChart));
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Name[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_X1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y1[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_X2[IndexFlowChart];
                    MyShowFlowChartRecord += FD + FlowChart_iSAM_Y2[IndexFlowChart];
                }

                break;
            }
            }
        }

        string MyShowNamed(long IndexNamed)
        {
            string X2;
            if (Strings.Len(Named_TableSymbolName(IndexNamed)) == 0)
                return null;
            MyShowNamed = "";
            if (IndexNamed == constantMyErrorCode)
                return null;
            else
            {
                MyShowNamed += "/name= " + Named_TableSymbolName(IndexNamed);
                if (!Information.IsNothing(Named_TableAuthor(IndexNamed)))
                    MyShowNamed += Constants.vbCrLf + "/Author" + " = " + Named_TableAuthor(IndexNamed);
                if (!Information.IsNothing(Named_TableVersion(IndexNamed)))
                    MyShowNamed += Constants.vbCrLf + "/version" + " = " + Named_TableVersion(IndexNamed);
                if (!Information.IsNothing(Named_TableNameofFile(IndexNamed)))
                    MyShowNamed += Constants.vbCrLf + "/filename" + " = " + Named_TableNameofFile(IndexNamed);
                if (!Information.IsNothing(Named_TableStroke(IndexNamed)))
                    MyShowNamed += Constants.vbCrLf + "/stroke" + " = " + Named_TableStroke(IndexNamed);



                // hack there is a routine that does the multilines that should replace this
                // /Macromicrocodetext 
                X2 = MyTrim(Named_TableMicroCodeText(IndexNamed));
                while (X2 != "")
                    MyShowNamed += Constants.vbCrLf + "/microcodetext" + " = " + MyTrim(PopLine(ref X2));

                X2 = MyTrim(Named_TableSintax(IndexNamed));
                while (X2 != "")
                    MyShowNamed += Constants.vbCrLf + "/Syntax" + " = " + MyTrim(PopLine(ref X2));

                X2 = MyTrim(Named_TableNotes(IndexNamed));
                while (X2 != "")
                    MyShowNamed += Constants.vbCrLf + "/notes" + " = " + MyTrim(PopLine(ref X2));

                X2 = MyTrim(Named_TableOpCode(IndexNamed));
                while (X2 != "")
                    MyShowNamed += Constants.vbCrLf + "/opcode" + " = " + PopLine(ref X2);
            }
        }

        string MyShowSymbolRecords(long IndexSymbol)
        {
            long I;
            long IndexNamed;
            string X2, X3;
            MyShowSymbolRecords = "";

            I = IndexSymbol;

            IndexNamed = FindIndexIniSAMTable("Named", "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, Symbol_TableSymbolName(I));
            if (IndexNamed == constantMyErrorCode)
                IndexNamed = CheckNotInList("Named", ref "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, ref Symbol_TableSymbolName(I));
            else
                MyShowSymbolRecords = MyShowNamed(IndexNamed);

            // ================================== Symbol graphics now for the abve symbol Named data.
            I += 1; // after the name
            do
            {
                switch (Symbol_TableCoded_String(I))
                {
                case "/name":
                {
                    return;
                }

                case "/point":
                {
                    X3 = Symbol_Table_InputOutput(I);
                    X2 = MyUniverse.ProgramOptions.SelectedDataType;
                    X2 = System.Convert.ToString(FindIndexIniSAMTable("Datatype", "Donotadd", ref DataType_FileName, ref DataType_Name_iSAM, MyUniverse.ProgramOptions.SelectedDataType));

                    // /Point=X, Y, Input/Output, Data Type, Name
                    MyShowSymbolRecords += MyShowSymbolGraphic(I);
                    break;
                }

                case "/line":
                {
                    MyShowSymbolRecords += Constants.vbCrLf;
                    MyShowSymbolRecords += MyShowLineRecord(I);
                    break;
                }

                case "/delete":
                {
                    MyShowSymbolRecords += Constants.vbCrLf + "/delete";
                    MyShowSymbolRecords += " = " + Symbol_TableX1(I);
                    MyShowSymbolRecords += FD + Symbol_TableY1(I);
                    MyShowSymbolRecords += FD + Symbol_TableSymbolName(I);
                    MyShowSymbolRecords += FD + Symbol_Table_NameOfPoint(I);
                    break;
                }

                case "/error":
                {
                    MyShowSymbolRecords += Constants.vbCrLf + "/error";
                    MyShowSymbolRecords += " = " + Symbol_TableX1(I);
                    MyShowSymbolRecords += FD + Symbol_TableY1(I);
                    MyShowSymbolRecords += " = " + Symbol_Table_InputOutput(I);
                    MyShowSymbolRecords += FD + Symbol_Table_DataType(I);
                    MyShowSymbolRecords += FD + Symbol_TableY1(I);
                    MyShowSymbolRecords += FD + Symbol_TableSymbolName(I);
                    MyShowSymbolRecords += FD + Symbol_Table_NameOfPoint(I);
                    break;
                }

                default:
                {
                    MyShowSymbolRecords += Constants.vbCrLf + "/Error in program Symbol Data Unknown /error = " + I + FD;
                    MyShowSymbolRecords += Symbol_TableCoded_String(I);
                    MyShowSymbolRecords += FD + Symbol_TableX1(I);
                    MyShowSymbolRecords += FD + Symbol_TableY1(I);
                    MyShowSymbolRecords += FD + Symbol_TableX2(I);
                    MyShowSymbolRecords += FD + Symbol_TableY2(I);
                    MyShowSymbolRecords += FD + Symbol_Table_NameOfPoint(I);
                    MyShowSymbolRecords += FD + Symbol_TableSymbolName(I);
                    break;
                }
                }

                I += 1;
            } while (I < TopOfFile("Symbol"));
        }


        string MyShowPointCounts()
        {
            string RTN;
            RTN = "";
            RTN = RTN + Constants.vbCrLf + "/Ignore a(Total=" + MyUniverse.SymbolAndPath.Total;
            RTN = RTN + " b(path=" + MyUniverse.SymbolAndPath.Path.Total;
            RTN = RTN + " c(?=" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Total;
            RTN = RTN + "d(b" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Both;
            RTN = RTN + "+i " + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Input;
            RTN = RTN + "+o " + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Output;
            RTN = RTN + "+? " + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Other;
            RTN = RTN + ")+ e(L =" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Total;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Other;
            RTN = RTN + ")+ f(Sy=" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Total;
            RTN = RTN + "g(D=" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Both;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Input;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Output;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Other;
            RTN = RTN + ")+ h(L=" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Total;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Other;
            RTN = RTN + ")))) i(?=" + MyUniverse.SymbolAndPath.Path.NumberOfErrors + ")";

            RTN = RTN + Constants.vbCrLf + "/ignore j(Sym=" + MyUniverse.SymbolAndPath.Symbol.Total;
            RTN = RTN + " k(line=" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total;
            RTN = RTN + "l(D=" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other;
            RTN = RTN + ")+ m(L=" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Total;
            RTN = RTN + "n(L=" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Other;

            RTN = RTN + "))+ o(?=" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total;
            RTN = RTN + "p(D=" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other;
            RTN = RTN + ")+ q(L=" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Total;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Other;

            RTN = RTN + ")+ r(Pts=" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total;
            RTN = RTN + ")+ s(D=" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Total;
            RTN = RTN + "t(D=" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other;
            RTN = RTN + ")+ u(L=" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Total;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other;




            RTN = RTN + Constants.vbCrLf + "/ignore v(USE=" + MyUniverse.SymbolAndPath.Uses.Total;
            RTN = RTN + " w(Index " + MyUniverse.SymbolAndPath.Uses.IndexUseSymbol;
            RTN = RTN + "), x(P=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.Total;
            RTN = RTN + " y(line=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Total;
            RTN = RTN + "z(D=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Both;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Input;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Output;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Other;
            RTN = RTN + ")+ zz(T=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Total;
            RTN = RTN + "(L=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Other;

            RTN = RTN + "))+ aa(T=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total;
            RTN = RTN + " bb(T=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total;
            RTN = RTN + "cc(D=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Other;
            RTN = RTN + ")+ dd(T=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Total;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Output;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Other;

            RTN = RTN + ")+ ee(T=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Total;
            RTN = RTN + "ff(D=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Both;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Input;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Output;
            RTN = RTN + " + " + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Other;
            RTN = RTN + ")+ gg(T=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Total;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Both;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Input;
            RTN = RTN + "+" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Output;
            RTN = RTN + "hh(L=" + MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Other;
            RTN = RTN + "))))";

            return RTN;
        }


        // for now only one point per line, until I cange the import to be able to get more than one at a time.
        string MyShowSymbolLines1(long Idex)
        {
            MyShowSymbolLines1 = Symbol_TableCoded_String(Idex);
            MyShowSymbolLines1 += "=" + Symbol_TableX1(Idex);
            MyShowSymbolLines1 += FD + Symbol_TableY1(Idex);
            MyShowSymbolLines1 += FD + Symbol_TableX2(Idex);
            MyShowSymbolLines1 += FD + Symbol_TableY2(Idex);
            MyShowSymbolLines1 += FD + Symbol_FileSymbolName[Idex]; // color of the line
            MyShowSymbolLines1 += FD + Symbol_Table_NameOfPoint(Idex); // Point Name (Not used?)
        }

        string MyShowSymbolLines2(long Idex)
        {
            MyShowSymbolLines2 = Symbol_TableCoded_String(Idex);
            MyShowSymbolLines2 += "=(" + Symbol_TableX1(Idex);
            MyShowSymbolLines2 += FD + Symbol_TableY1(Idex);
            MyShowSymbolLines2 += ")-(" + Symbol_TableX2(Idex);
            MyShowSymbolLines2 += FD + Symbol_TableY2(Idex);
            MyShowSymbolLines2 += ")," + Symbol_FileSymbolName[Idex]; // color of the line
            MyShowSymbolLines2 += FD + Symbol_Table_NameOfPoint(Idex); // Point Name (Not used?)
        }



        string MyShowSymbolPoint(long Idex)
        {

            // todo make sure that this takes care of /name,/linbe,/point, and anything else like /error
            MyShowSymbolPoint = Symbol_TableCoded_String(Idex);
            MyShowSymbolPoint += FD + Symbol_FileSymbolName[Idex];
            MyShowSymbolPoint += FD + Symbol_TableX1(Idex);
            MyShowSymbolPoint += FD + Symbol_TableY1(Idex);
            // should the last be 1 or zero (or even two?)

            MyShowSymbolPoint += FD + Symbol_Table_InputOutput(Idex);
            MyShowSymbolPoint += FD + Symbol_Table_DataType(Idex);
            MyShowSymbolPoint += FD + Symbol_Table_NameOfPoint(Idex); // Point Name
            if (MyOptionTest(22) == true)
                MyShowSymbolPoint += FD & "\\Index= " + Idex;
        }
        string MyShowSymbolGraphic(long Idex)
        {
            if (Strings.Len(Symbol_TableCoded_String(Idex)) == 0)
            {
                MyShowSymbolGraphic = Constants.vbCrLf + "/ignore Invalide symbol code, ->" + Idex;
                return;
            }
            if (Symbol_TableCoded_String(Idex) == "/unknown")
            {
                MyShowSymbolGraphic = Constants.vbCrLf + "/ignore Invalide symbol code, ->" + Idex;
                return;
            }

            MyShowSymbolGraphic = "";
            switch (Symbol_TableCoded_String(Idex))
            {
            case "/point":
            {
                // todo need to change the import to accept the xy input format of (x,y)
                MyShowSymbolGraphic += Constants.vbCrLf;
                MyShowSymbolGraphic += MyShowSymbolPoint(Idex);
                MyShowSymbolGraphic += ",->" + Idex;
                break;
            }

            case "/line":
            {
                // need to change the imports to accept the three formats /line,x1,y1,x2,y2...  and /line=(x,y)_(x,y)...   and /line(x,y)_(x,y)_(X,y)-...
                // then need to make myshowlineS() to output the entire connected line(as long as the end(s) of next one matches the one end of the current one
                MyShowSymbolGraphic = Constants.vbCrLf + MyShowSymbolLines1(Idex); // Version 2 format is /line=(,),(,),........
                MyShowSymbolGraphic += ",->" + Idex;
                break;
            }

            default:
            {
                // 
                // todo need to chagen this to something else.
                MyShowSymbolGraphic = Constants.vbCrLf + "/" + Symbol_TableCoded_String(Idex);
                MyShowSymbolGraphic += " = " + Symbol_TableX1(Idex);
                MyShowSymbolGraphic += FD + Symbol_TableY1(Idex);
                MyShowSymbolGraphic += " = " + Symbol_TableX2(Idex);
                MyShowSymbolGraphic += FD + Symbol_TableY2(Idex);
                MyShowSymbolGraphic += " ,\\PointName " + Symbol_Table_NameOfPoint(Idex); // Point Name
                MyShowSymbolGraphic += Constants.vbTab & ",\\SymbolName = " + Symbol_FileSymbolName[Idex];
                MyShowSymbolGraphic += ",->" + Idex;
                break;
            }
            }
        }



        string MyShowDataType(long Index)
        {
            MyShowDataType = "/datatype" + " = " + DataType_TableName(Index);
            MyShowDataType += FD + DataType_TableNumberOfBytes(Index);
            MyShowDataType += FD + Color_TableName(DataType_TableColorIndex(Index)); // DataType_TableColor( i )
            MyShowDataType += FD + DataType_TableWidth(Index);
            MyShowDataType += FD + PrintAbleNull(Strings.Trim(DataType_TableDescribtion(Index)));
        }

        string MyShowColor(long Indexcolor)
        {
            MyShowColor = "/color" + " = " + Color_TableName(Indexcolor);
            MyGetPen_Static(Color_TableName(Indexcolor), "");
            MyShowColor += FD + Color_TableAlpha(Indexcolor); // PenColor.Color.A
            MyShowColor += FD + Color_TableRed(Indexcolor); // PenColor.Color.R
            MyShowColor += FD + Color_TableGreen(Indexcolor); // PenColor.Color.G
            MyShowColor += FD + Color_TableBlue(Indexcolor); // PenColor.Color.B
            MyShowColor += FD + MyUnEnum(Color_TableStyle(Indexcolor), SymbolScreen.ToolStripDropDownPathLineStyle, 0);
            MyShowColor += FD + MyUnEnum(Color_TableStartCap(Indexcolor), SymbolScreen.ToolStripDropDownPathStart, 0);
            MyShowColor += FD + MyUnEnum(Color_TableEndCap(Indexcolor), SymbolScreen.ToolStripDropDownPathEnd, 0);
            MyShowColor += FD & "\\ignore=" + formatColor;
            MyShowColor += FD & "\\Index=" + Indexcolor.ToString();

            if (Strings.Len(Color_TableName(Indexcolor)) < 1)
            {
                MyShowColor += "/Index=" + Indexcolor + " Invalid Data Type Name at " + Indexcolor.ToString();
                return;
            }
        }


        string MyShowDataTable(long Idex)
        {
            if (Strings.Len(DataType_FileName[Idex]) < 1)
            {
                MyShowDataTable = "/ignore \\Index=" + Idex + " Invalid Data Type Name at " + Idex.ToString();
                return;
            }

            if (DataType_TableColorIndex(Idex) < 1)
            {
                MyShowDataTable = Constants.vbCrLf & "/ignore \\Index=" + Idex + " Invalid color for Data Type Name " + DataType_TableName(Idex);
                return;
            }

            // "/datatype=datatypename" & FD & " Number Of Bytes" & FD & " Color Name" & FD & " Color Width" & FD & " Describtion"

            MyShowDataTable = "/DataType=" + DataType_FileName[Idex];
            MyShowDataTable += FD + DataType_FileNumberOfBytes[Idex];
            MyShowDataTable += FD + FindColorFromDataType(DataType_FileName[Idex]);
            MyShowDataTable += FD + DataType_FileWidth[Idex];
            MyShowDataTable += FD + DataType_FileDescribtion[Idex];
            MyShowDataTable += FD & "\\Index=" + Idex;
            MyShowDataTable += FD + DataType_TableColorIndex(FindDataTypeIndex(DataType_FileName[Idex]));
            MyShowDataTable += FD + MyShowColor(DataType_TableColorIndex(FindDataTypeIndex(DataType_FileName[Idex])));
        }


        string MyShowControl(Control CTL, HelpProvider What)
        {
            const  string Y = Strings.Chr(34) + Constants.vbTab + Strings.Chr(34);
            string X;
            long I;
            X = Constants.vbCrLf + "/Control display : ";
            X = X + Y + " control parent " + CTL.Parent.Name;
            X = X + Y + " control name " + CTL.Name;
            X = X + Y + " Help " + What.ToString;
            X = X + Y + " Help Name Space " + What.HelpNamespace;
            X = X + Y + " Help tag " + What.Tag.ToString;
            X = X + Y + " name " + What.GetType.Name;
            X = X + Y + " fullname " + What.GetType.FullName;
            X = X + Y + " length " + What.GetType.GetEnumNames.Length;
            for (I = 0; I <= What.GetType.GetEnumNames.Length - 1; I++) // 'What.GetType.GetEnumNames.Count - 1
                X = X + Y + " names of : " + What.GetType.GetEnumNames(I).ToString;
            X = X + Y + " namespace " + What.GetType.Namespace;
            X = X + Y + " datatype name " + What.GetType.UnderlyingSystemType.Name;
            return X;
        }


        string MyShowDropDownItems(ToolStripDropDownItem X)
        {
            string A;
            long I;
            A = "";
            A = A + Constants.vbCrLf + "." + X.Name;
            A = A + Constants.vbTab + "." + X.CanSelect;
            A = A + Constants.vbTab + "." + X.OwnerItem.Name;
            A = A + Constants.vbTab + "." + X.Text;
            A = A + Constants.vbTab + "." + X.CanSelect;
            A = A + Constants.vbTab + "." + X.DropDownItems.Count;
            for (I = 0; I <= X.DropDownItems.Count - 1; I++)
            {
                A = A + Constants.vbCrLf + Constants.vbTab + "." + X.DropDownItems.Item(I).Name;
                A = A + Constants.vbTab + Constants.vbTab + "." + X.DropDownItems.Item(I).Text;

                A = A + Constants.vbTab + Constants.vbTab + "Selected?=" + X.DropDownItems.Item(I).Selected;
                if (X.DropDownItems.Item(I).Selected == true)
                    A = A + "**************************";
            }
            return A;
        }



        string MyShowUserInfo()
        {
            MyShowUserInfo = "";

            MyShowUserInfo += Constants.vbCrLf + " Info_AssemblyName= " + HighLight(MyUniverse.MySystem.USER.Info_AssemblyName);
            MyShowUserInfo += Constants.vbCrLf + " Info_CompanyName= " + HighLight(MyUniverse.MySystem.USER.Info_CompanyName);
            MyShowUserInfo += Constants.vbCrLf + " Info_Copyright= " + HighLight(MyUniverse.MySystem.USER.Info_Copyright);
            MyShowUserInfo += Constants.vbCrLf + " Info_Description= " + HighLight(MyUniverse.MySystem.USER.Info_Description);
            MyShowUserInfo += Constants.vbCrLf + " DirectoryPath1= " + HighLight(MyUniverse.MySystem.USER.DirectoryPath1);
            MyShowUserInfo += Constants.vbCrLf + " DirectoryPath2= " + HighLight(MyUniverse.MySystem.USER.DirectoryPath2);
            MyShowUserInfo += Constants.vbCrLf + " Info_ProductName= " + HighLight(MyUniverse.MySystem.USER.Info_ProductName);
            MyShowUserInfo += Constants.vbCrLf + " Info_Title= " + HighLight(MyUniverse.MySystem.USER.Info_Title);
            MyShowUserInfo += Constants.vbCrLf + " Info_Trademark= " + HighLight(MyUniverse.MySystem.USER.Info_Trademark);
            MyShowUserInfo += Constants.vbCrLf + " Info_Version= " + HighLight(MyUniverse.MySystem.USER.Info_Version);
            MyShowUserInfo += Constants.vbCrLf + " Info_WorkingSet= " + HighLight(MyUniverse.MySystem.USER.Info_WorkingSet);
            MyShowUserInfo += Constants.vbCrLf + " MinimumSplashScreenDisplayTime= " + HighLight(MyUniverse.MySystem.USER.MinimumSplashScreenDisplayTime);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_DisplayName= " + HighLight(MyUniverse.MySystem.USER.UICulture_DisplayName);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_EnglishName= " + HighLight(MyUniverse.MySystem.USER.UICulture_EnglishName);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_Name= " + HighLight(MyUniverse.MySystem.USER.UICulture_Name);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_NativeName= " + HighLight(MyUniverse.MySystem.USER.UICulture_NativeName);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_Parent_Name= " + HighLight(MyUniverse.MySystem.USER.UICulture_Parent_Name);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_TwoLetterISOLanguageName= " + HighLight(MyUniverse.MySystem.USER.UICulture_TwoLetterISOLanguageName);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_ThreeLetterWindowsLanguageName= " + HighLight(MyUniverse.MySystem.USER.UICulture_ThreeLetterWindowsLanguageName);
            MyShowUserInfo += Constants.vbCrLf + " UICulture_TwoLetterISOLanguageName= " + HighLight(MyUniverse.MySystem.USER.UICulture_TwoLetterISOLanguageName);
            MyShowUserInfo += Constants.vbCrLf + " Info_CompanyName= " + HighLight(MyUniverse.MySystem.USER.Info_CompanyName);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_CurrentUserApplicationData= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_CurrentUserApplicationData);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_CurrentUserApplicationData= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_CurrentUserApplicationData);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_Desktop= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_Desktop);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_MyDocuments= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_MyDocuments);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_MyMusic= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_MyMusic);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_MyPictures= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_MyPictures);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_ProgramFiles= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_ProgramFiles);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_Programs= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_Programs);
            MyShowUserInfo += Constants.vbCrLf + " FileSystem_SpecialDirectories_Temp= " + HighLight(MyUniverse.MySystem.USER.FileSystem_SpecialDirectories_Temp);
            MyShowUserInfo += Constants.vbCrLf + " Info_AvailablePhysicalMemory= " + HighLight(MyUniverse.MySystem.USER.Info_AvailablePhysicalMemory);
            MyShowUserInfo += Constants.vbCrLf + " Info_AvailableVirtualMemory= " + HighLight(MyUniverse.MySystem.USER.Info_AvailableVirtualMemory);
            MyShowUserInfo += Constants.vbCrLf + " Info_OSFullName= " + HighLight(MyUniverse.MySystem.USER.Info_OSFullName);
            MyShowUserInfo += Constants.vbCrLf + " Info_OSPlatform= " + HighLight(MyUniverse.MySystem.USER.Info_OSPlatform);
            MyShowUserInfo += Constants.vbCrLf + " Info_OSVersion= " + HighLight(MyUniverse.MySystem.USER.Info_OSVersion);
            MyShowUserInfo += Constants.vbCrLf + " Info_TotalPhysicalMemory= " + HighLight(MyUniverse.MySystem.USER.Info_TotalPhysicalMemory);
            MyShowUserInfo += Constants.vbCrLf + " Info_TotalVirtualMemory= " + HighLight(MyUniverse.MySystem.USER.Info_TotalVirtualMemory);
            MyShowUserInfo += Constants.vbCrLf + " Mouse_WheelScrollLines= " + HighLight(MyUniverse.MySystem.USER.Mouse_WheelScrollLines);
            MyShowUserInfo += Constants.vbCrLf + " Mouse_WheelExists= " + HighLight(MyUniverse.MySystem.USER.Mouse_WheelExists);
            MyShowUserInfo += Constants.vbCrLf + " Name= " + HighLight(MyUniverse.MySystem.USER.Name);
            MyShowUserInfo += Constants.vbCrLf + " Network_GetType_FullName= " + HighLight(MyUniverse.MySystem.USER.Network_GetType_FullName);
            MyShowUserInfo += Constants.vbCrLf + " Network_GetType_MemberType= " + HighLight(MyUniverse.MySystem.USER.Network_GetType_MemberType);
            MyShowUserInfo += Constants.vbCrLf + " Network_GetType_Namespace= " + HighLight(MyUniverse.MySystem.USER.Network_GetType_Namespace);
            MyShowUserInfo += Constants.vbCrLf + " Registry_CurrentUser_Name= " + HighLight(MyUniverse.MySystem.USER.Registry_CurrentUser_Name);
            MyShowUserInfo += Constants.vbCrLf + " Registry_LocalMachine_Name= " + HighLight(MyUniverse.MySystem.USER.Registry_LocalMachine_Name);
            MyShowUserInfo += Constants.vbCrLf + " Registry_PerformanceData_Name= " + HighLight(MyUniverse.MySystem.USER.Registry_PerformanceData_Name);
            MyShowUserInfo += Constants.vbCrLf + " User_Name= " + HighLight(MyUniverse.MySystem.USER.User_Name);
            MyShowUserInfo += Constants.vbCrLf + " Screen_DeviceName= " + HighLight(MyUniverse.MySystem.USER.Screen_DeviceName);
            MyShowUserInfo += Constants.vbCrLf + " Screen_BitsPerPixel= " + HighLight(MyUniverse.MySystem.USER.Screen_BitsPerPixel);
            MyShowUserInfo += Constants.vbCrLf + " Screen_Bounds_Size_Width= " + HighLight(MyUniverse.MySystem.USER.Screen_Bounds_Size_Width);
            MyShowUserInfo += Constants.vbCrLf + " Screen_Bounds_Size_Height= " + HighLight(MyUniverse.MySystem.USER.Screen_Bounds_Size_Height);
            MyShowUserInfo += Constants.vbCrLf + " Screen_WorkingArea_Width= " + HighLight(MyUniverse.MySystem.USER.Screen_WorkingArea_Width);
            MyShowUserInfo += Constants.vbCrLf + " Screen_WorkingArea_Height= " + HighLight(MyUniverse.MySystem.USER.Screen_WorkingArea_Height);
            MyShowUserInfo += Constants.vbCrLf + " CurrentPrincipal_Identity_Name= " + HighLight(MyUniverse.MySystem.USER.CurrentPrincipal_Identity_Name);
            MyShowUserInfo += Constants.vbCrLf + " CurrentPrincipal_Identity_GetType_FullName= " + HighLight(MyUniverse.MySystem.USER.CurrentPrincipal_Identity_GetType_FullName);
            MyShowUserInfo += Constants.vbCrLf + " CurrentPrincipal_Identity_GetType_GUID= " + HighLight(MyUniverse.MySystem.USER.CurrentPrincipal_Identity_GetType_GUID);
            MyShowUserInfo += Constants.vbCrLf + " User_Name= " + HighLight(MyUniverse.MySystem.USER.User_Name);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_GUID= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_GUID);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_Assembly_FullName= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_Assembly_FullName);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_Assembly_Location= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_Assembly_Location);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_AssemblyQualifiedName= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_AssemblyQualifiedName);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_Name= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_Name);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_Namespace= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_Namespace);
            MyShowUserInfo += Constants.vbCrLf + " WebServices_GetType_UnderlyingSystemType_FullName= " + HighLight(MyUniverse.MySystem.USER.WebServices_GetType_UnderlyingSystemType_FullName);

            MyShowUserInfo += Constants.vbCrLf + " Info_StackTrace= " + HighLight(MyUniverse.MySystem.USER.Info_StackTrace);
        }


        string MyShow3Points(MyPointStructure XY1, MyPointStructure XY2, MyPointStructure XY3)
        {
            return " (" + XY1.Xx + FD + XY1.Yy + ")" + ShortHighLight(XY1.Named.PathName) + "" + ShortHighLight(XY1.Named.SymbolName) + "" + ShortHighLight(XY1.Named.Pointname) + "" + Constants.vbTab + ",(" + XY2.Xx + FD + XY2.Yy + ")" + ShortHighLight(XY2.Named.PathName) + "" + ShortHighLight(XY2.Named.SymbolName) + "" + ShortHighLight(XY2.Named.Pointname) + "" + Constants.vbTab + ",(" + XY3.Xx + ", " + XY3.Yy + ")" + ShortHighLight(XY3.Named.PathName) + "" + ShortHighLight(XY3.Named.SymbolName) + "" + ShortHighLight(XY3.Named.Pointname) + "" + " Distances[ A&B " + MyShowDistance(XY1, XY2) + " A&C " + MyShowDistance(XY1, XY3) + " B&C " + MyShowDistance(XY2, XY3) + "]";
        }


        string MyShowScale()
        {
            MyUniverse.MySystem.USER.Info_AvailablePhysicalMemory = My.Computer.Info.AvailablePhysicalMemory.ToString;
            MyUniverse.MySystem.USER.Info_AvailableVirtualMemory = My.Computer.Info.AvailableVirtualMemory.ToString;

            MyUniverse.MySystem.USER.Info_AvailablePhysicalMemory = My.Computer.Info.TotalPhysicalMemory.ToString;

            return " Scale Min,IS,max =" + Constants.vbTab + ShortHighLight((ConstantMinFLowChartScale.ToString()) + ShortHighLight(MyUniverse.SysGen.MyFlowChartScale.ToString()) + ShortHighLight(ConstantMaxFlowChartScale.ToString()) + " Memory[Phy=" + ShortHighLight(ShortHighLight(My.Computer.Info.AvailablePhysicalMemory.ToString() + " mb  " + My.Computer.Info.TotalPhysicalMemory.ToString() + " mb  ")) + " VirMem" + ShortHighLight(ShortHighLight(My.Computer.Info.AvailableVirtualMemory.ToString() + " mb  " + My.Computer.Info.TotalVirtualMemory.ToString() + " mb  ")));
        }

        string MyShowDistance(MyPointStructure XY1, MyPointStructure XY2)
        {
            return ShortHighLight(System.Convert.ToString(MyABS(XY1.Xx - XY2.Xx) + MyABS(XY1.Yy - XY2.Yy))) + ShortHighLight(XY1.Named.PathName) + "" + ShortHighLight(XY1.Named.SymbolName) + "" + ShortHighLight(XY1.Named.Pointname) + " , " + ShortHighLight(XY2.Named.PathName) + "" + ShortHighLight(XY2.Named.SymbolName) + "" + ShortHighLight(XY2.Named.Pointname);
        }


        string MyShow3Lines(MyLineStructure a, MyLineStructure b, MyLineStructure c)
        {
            return ShortHighLight(MyShowLine(a)) + Constants.vbTab + ShortHighLight((MyShowLine(b)) + Constants.vbTab + ShortHighLight(MyShowLine(c)));
        }

        string MyShowLineRecord(long IndexSymbol)
        {
            return Symbol_TableCoded_String(IndexSymbol) + FD + Symbol_TableSymbolName(IndexSymbol) + "(" + FD + Symbol_TableX1(IndexSymbol) + FD + Symbol_TableY1(IndexSymbol) + ")" + FD + "(" + Symbol_TableX2(IndexSymbol) + FD + Symbol_TableY2(IndexSymbol) + ")" & "\\index" + IndexSymbol.ToString() + FD + Symbol_Table_NameOfPoint(IndexSymbol) + FD + Symbol_Table_DataType(IndexSymbol) + FD + Symbol_Table_InputOutput(IndexSymbol);
        }

        string MyShowLine(MyLineStructure XY)
        {
            return "(" + XY.a.Xx + FD + XY.a.Yy + ")_(" + XY.b.Xx + FD + XY.b.Yy + ")";
        }

        string MyShowPoint(long IndexFlowChart1)
        {
            return MyShowPoint(MyPoint1XY(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1))) + "-" + MyShowPoint(MyPoint1XY(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1)));
        }

        void MyShowPoint(long X, long Y)
        {
            return MyShowPoint(MyPoint1XY(X, Y));
        }
        string MyShowPoint(MyPointStructure XY)
        {
            return "(" + XY.Xx + FD + XY.Yy + ")" + HighLight(XY.Named.PathName) + " | " + HighLight(XY.Named.SymbolName) + " | " + HighLight(XY.Named.Pointname);
        }

        string MyShowAllNet(long IndexNetLinks)
        {
            long I;
            string X;
            string Del;
            Del = "";
            MyShowAllNet = "[";
            X = Net_TableLinks(IndexNetLinks);
            do
            {
                I = PopNonZeroValue(ref X);
                MyShowAllNet += Del + FlowChart_TablePath_Name(I);
                Del = FD;
            } while (Strings.Len(X) > 0);
            MyShowAllNet += "]";
        }





        string MyShowNetLnks(long IndexNetLink)
        {
            if (InvalidIndex(IndexNetLink, Net_FileLinks) == true)
                return HighLight("nothing @ " + IndexNetLink.ToString());
            return Constants.vbTab + ShortHighLight(" #" + IndexNetLink + " Pathname->" + HighLight(Net_TableNames(IndexNetLink)) + "paths->" + ShortHighLight(Net_TableLinks(IndexNetLink)));
        }


        string MyShowkeyWord(string Switch, string KeyWord)
        {
            return Switch + "=" + KeyWord;
        }

        string MakeStatementReplacements(string CodeLine)
        {
            long Idex;
            string A;
            string[] myarray;
            myarray = new string[257];
            MakeStatementReplacements = "";
            // Idex might be counting twice and missing Syntax
            Idex = 1;
            A = pathnames == MyParse(ref myarray, CodeLine);

            while (PrintAbleNull(myarray[Idex]) != "_")
            {
                A = myarray[Idex];
                switch (No_FieldDelimiter(ThisIsAWhat(A)))
                {
                case "C_L_MultiLine":
                {
                    break;
                }

                case "C_L_Comment":
                {
                    break;
                }

                case "C_L_Extention":
                {
                    break;
                }

                case "C_L_VarChars":
                {
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + MyUniverse.ProgramOptions.C_L_Comment + A);
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + MyUniverse.ProgramOptions.C_L_Comment + A);
                    break;
                }

                case "comment" // Ignore the rest of the line
                    :
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + MyUniverse.ProgramOptions.C_L_Comment + A);// Just add a comment
                    break;
                }

                case "Quote":
                {
                    // Save The First Quote
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + A); // This should be Quote Marks
                    break;
                }

                case "KeyWord":
                case "Function":
                case "Operator":
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + A) + " ";// put space arount any keyword
                    break;
                }

                case "Alpha":
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + MyUniverse.SysGen.Constants.RMStart + A + ".value" + MyUniverse.SysGen.Constants.RMEnd);
                    break;
                }

                case "Number":
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + MyUniverse.SysGen.Constants.RMStart + A + ".value") + MyUniverse.SysGen.Constants.RMEnd + " ";
                    break;
                }

                case "SpecialCharacter":
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + A) + " ";
                    break;
                }

                case "Variable":
                {
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + MyUniverse.SysGen.Constants.RMStart + A + ".name") + MyUniverse.SysGen.Constants.RMEnd + " ";
                    break;
                }

                case "Unknown":
                {
                    Abug(308, "unknown Character Classification", A, ThisIsAWhat(A));
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + A);
                    break;
                }

                default:
                {
                    Abug(309, "program issue", "Did Not take care Of a ThisIsAWhat", ThisIsAWhat(A));
                    MakeStatementReplacements = Strings.Trim(MakeStatementReplacements + " " + A) + " ";
                    break;
                }
                }
                // I need to explain why I did this and am missing a null field?
                Idex += 1;
            }
            if (Strings.Right(MakeStatementReplacements, Strings.Len(FD)) != FD)
                MakeStatementReplacements += FD;
        }



        string MakeStatementSintax(string[] MyArray)
        {
            long Idex;
            string A;
            string Delim;
            MakeStatementSintax = "";
            // Idex might be counting twice and missing Syntax
            Delim = ""; // Do not start with a comma(or what ever the field delimeter is right now
            Idex = 1;
            while (PrintAbleNull(MyArray[Idex]) != "_")
            {
                A = MyArray[Idex];
                switch (No_FieldDelimiter(ThisIsAWhat(A)))
                {
                case "C_L_MultiLine":
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.ProgramOptions.C_L_MultiLine);
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.SysGen.Constants.ConstantGotoNextLine + FD + MakePathName(MyArray[Idex + 1])); // HACK making it a code keyword GOTO, hope the computer language has that as a keyword!!!!!!!
                    Idex += 1;
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.SysGen.Constants.ConstantCameFromLine + FD + MakePathName(MyArray[Idex + 1]) + ":");
                    Idex += 1;
                    break;
                }

                case "C_L_Comment":
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.ProgramOptions.C_L_Comment);
                    break;
                }

                case "C_L_Extention":
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.ProgramOptions.C_L_Extention);
                    break;
                }

                case "C_L_VarChars" // Not so sure about this!!!!!!! ' Possible error
                    :
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.SysGen.Constants.ConstantGotoNextLine);
                    break;
                }

                case "comment" // Ignore the rest of the line
                    :
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + A);
                    break;
                }

                case "Quote":
                {
                    // Save The First Quote
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.SysGen.Constants.ConstantQuotes);
                    break;
                }

                case "KeyWord":
                case "Operator":
                case "Function":
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + A);
                    break;
                }

                case "SpecialCharacter":
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + A);
                    break;
                }

                case "Number":
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MyUniverse.SysGen.Constants.ConstantNumber);
                    break;
                }

                case "Variable":
                case "Alpha":
                case "AlphaNumberic":
                {
                    // todo THis needs to be changed to be {[(VariableName.PATH)]}
                    // MakeStatementSintax = Trim(MakeStatementSintax & Delim & MyUniverse.SysGen.constants.constantVariable)
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MakePathName(A));
                    break;
                }

                case "FieldDelimiter" // donothing
                    :
                {
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax);
                    break;
                }

                case "Unknown":
                {
                    Abug(310, "unknown Character Clasifacition", A, ThisIsAWhat(A));
                    MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + A);
                    break;
                }

                default:
                {
                    if (Strings.InStr(A, ".") != 0)
                    {
                        if (Strings.InStr(A, MyUniverse.SysGen.Constants.RMStart) > 0)
                        {
                            if (Strings.InStr(A, MyUniverse.SysGen.Constants.RMEnd) > 0)
                                MakeStatementSintax = Strings.Trim(MakeStatementSintax + Delim + MakePathName(A));
                            else
                                Abug(311, "Variable is missing the End marker " + MyUniverse.SysGen.Constants.RMEnd, " But has the first marker " + MyUniverse.SysGen.Constants.RMStart, " and has the period");
                        }
                        else
                            Abug(315, "Variable is missing the Start marker " + MyUniverse.SysGen.Constants.RMEnd, "", " and has the period");
                    }
                    else
                        Abug(316, "Unknow what this is", HighLight(A), HighLight(ThisIsAWhat(A)));
                    break;
                }
                }
                // I need to explain why I did this and am missing a null field?
                // While Right(MakeStatementSintax, 2) = Delim & Delim
                // MakeStatementSintax = Left(MakeStatementSintax, Len(MakeStatementSintax) - 1)
                // End While
                // While Left(MakeStatementSintax, 1) = Delim
                // MakeStatementSintax = Mid(MakeStatementSintax, 2, Len(MakeStatementSintax))
                // End While
                Idex += 1;
                Delim = FD; // Now make everthing seperated witha Field delimeter
            }
            if (Strings.Right(MakeStatementSintax, Strings.Len(FD)) != FD)
                MakeStatementSintax += FD;
        }


        long FindSymbolSintax(string Keyline) // This will return the Named_File(index) of the matching Syntax
        {
            string Sintax;
            Sintax = Keyline;
            pathnames = MyParse(ref My_Sintax_Line_Parsed, Sintax);
            Sintax = MakeStatementSintax(My_Sintax_Line_Parsed);
            FindSymbolSintax = TopOfFile("named");
            while (FindSymbolSintax > 0)
            {
                if (Sintax == Named_TableSintax(FindSymbolSintax))
                    return;
                FindSymbolSintax -= 1;
            }
            FindSymbolSintax = constantMyErrorCode;
        }

        string MyCompareSinTax()
        {
            long ParsedItem, MyErrors;
            MyErrors = 1024;
            // for now stupid comparison test
            ParsedItem = 0;
            MyCompareSinTax = "equal";

            while (MyErrors > 1)
            {
                switch (No_FieldDelimiter(ThisIsAWhat(My_Sintax_Line_Parsed[ParsedItem])))
                {
                case "C_L_Comment":
                {
                    break;
                }

                case "C_L_Extention":
                {
                    break;
                }

                case "C_L_MultiLine":
                {
                    break;
                }

                case "C_L_VarChars":
                {
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                {
                    if (!ThisIsACameFromLine(My_CodeLine_Parsed[ParsedItem]))
                    {
                        MyCompareSinTax = "notequal";
                        return;
                    }

                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                {
                    if (!ThisIsAGotoNextLine(My_CodeLine_Parsed[ParsedItem]))
                    {
                        MyCompareSinTax = "notequal";
                        return;
                    }

                    break;
                }

                case "Comment" // The rest is all comment 
                    :
                {
                    if (!ThisIsAComment(My_CodeLine_Parsed[ParsedItem]))
                    {
                        MyCompareSinTax = "notequal";
                        return;
                    }

                    break;
                }

                case "KeyWord":
                case "Function":
                    case "Operator" // must match exactly
                        :
                    {
                        switch (MyCompareSinTax_S(My_Sintax_Line_Parsed[ParsedItem], My_CodeLine_Parsed[ParsedItem]))
                        {
                        case "equal":
                        {
                            MyCompareSinTax = "notequal";
                            return;
                        }

                        case "notequal":
                        {
                            break;
                        }
                        }

                        break;
                    }

                    case "SpecialCharacter" // must match exactly
                        :
                    {
                        switch (MyCompareSinTax_S(My_Sintax_Line_Parsed[ParsedItem], My_CodeLine_Parsed[ParsedItem]))
                        {
                        case "notequal":
                        {
                            MyCompareSinTax = "notequal";
                            return;
                        }

                        case "equal":
                        {
                            break;
                        }
                        }

                        break;
                    }

                    case "Variable":
                    {
                        if (!ThisIsAVariableName(My_CodeLine_Parsed[ParsedItem]))
                        {
                            MyCompareSinTax = "notequal";
                            return;
                        }

                        break;
                    }

                    case "quote":
                    {
                        if (!ThisIsAQuote(My_CodeLine_Parsed[ParsedItem]))
                        {
                            MyCompareSinTax = "notequal";
                            return;
                        }

                        break;
                    }

                    case "Alpha":
                    {
                        if (!ThisIsAnAlpha(My_CodeLine_Parsed[ParsedItem]))
                        {
                            MyCompareSinTax = "notequal";
                            return;
                        }

                        break;
                    }

                    case "Number":
                    {
                        if (!ThisIsANumber(My_CodeLine_Parsed[ParsedItem]))
                        {
                            MyCompareSinTax = "notequal";
                            return;
                        }

                        break;
                    }

                    case null // ran out of Syntax to compare to
                        :
                    {
                        MyCompareSinTax = "notequal";
                        return;
                    }

                    case "Unknown" // dont know what it is but it is not a good suntax
                        :
                    {
                        // If My_CodeLine_Parsed(ParsedItem)) Then
                        MyCompareSinTax = "notequal";
                        return;
                    }
                }
                ParsedItem += 1;
            }
        }

        long MakeUseANDPath(string myCodeLine, string SymbolName, long IndexSymbol, long LineNumber, string PathName)
        {
            long Idex, FCKounter, IndexFlowChart;
            long x1, y1;
            // Dim D As long
            MyPointStructure TempXY;
            long NumberOfPoints;

            if (Strings.Len(SymbolName) < 2)
                SymbolName = MakeNewName("Copy3" + Symbol_TableSymbolName(IndexSymbol), LineNumber, SymbolName);
            if (Strings.Len(PathName) < 3)
                PathName = MakePathName("VV_Path_" + Strings.Right(My_INT(VBMath.Rnd() * 100000000 + 100000000).ToString(), 6)) + FD;

            NumberOfPoints = 1;
            // x1 = MyUniverse.MySymbolPoints(NumberOfPoints).X ' This should be from the symbol !
            // ?y1 = MyUniverse.MySymbolPoints(NumberOfPoints).Y

            // ?Idex = 
            AddFlowChartRecordUse(SymbolName, "/use", MyUniverse.SysGen.Placement.Xx, MyUniverse.SysGen.Placement.Yy, "Default", "", "", "", LineNumber); // no datatype, no links
            FCKounter = TopOfFile("FlowChart") - 1;
            Idex = 1;
            while (PrintAbleNull(My_CodeLine_Parsed[Idex]) != "_")
            {
                // FindingMyBugs(50) 'hack Least amount of checking here
                switch (No_FieldDelimiter(ThisIsAWhat(My_CodeLine_Parsed[Idex])))
                {
                case "C_L_MultiLine":
                {
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                {
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                {
                    break;
                }

                case "C_L_Comment":
                {
                    break;
                }

                case "C_L_Extention":
                {
                    break;
                }

                case "C_L_VarChars":
                {
                    break;
                }

                case "Comment":
                {
                    break;
                }

                case "KeyWord":
                case "Function":
                case "Operator":
                {
                    break;
                }

                case "Quote":
                {
                    break;
                }

                case "Alpha":
                case "Number":
                case "Variable":
                {
                    x1 = MyUniverse.MySymbolPoints[NumberOfPoints].X;
                    y1 = MyUniverse.MySymbolPoints[NumberOfPoints].Y;
                    TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.Xx, MyUniverse.SysGen.Placement.Yy, x1, y1, PathName);
                    NumberOfPoints += 1;
                    // FindingMyBugs(30) 'hack Least amount of checking here

                    // Need to have the line point away from the center of the symbol, not at the center (usex1,usey1) 2020 08 17  "Errored" datatype, since we do not know it yet
                    IndexFlowChart = AddNEWFlowChartRecordPath(My_VariableName(myCodeLine, Idex, LineNumber), "/Path", TempXY.Xx, TempXY.Yy, (MyUniverse.SysGen.Placement.Xx + x1).ToString(), (MyUniverse.SysGen.Placement.Yy + y1).ToString(), "errored", LineNumber);
                    ainfo2(28);
                    UpDateFlowChartLinks(IndexFlowChart, LineNumber, Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)));

                    ConnectPath(IndexFlowChart);
                    FindingMyBugs(30); // hack Least amount of checking here
                    MyPlacement(false);
                    break;
                }

                case "SpecialCharacter":
                case "FieldDelimiter":
                {
                    break;
                }

                case null:
                {
                    break;
                }

                case "Unknown":
                {
                    break;
                }

                default:
                {
                    break;
                }
                }
                Idex += 1;
            }
            return constantMyErrorCode;
        }

        string CreateFileNameFromSintax(string SinTaxLine, long LineNumber)
        {
            string X, Y;
            long I;

            Y = "";
            X = SinTaxLine;
            CreateFileNameFromSintax = "";
            while (Strings.Len(X) > 0)
            {
                switch (No_FieldDelimiter(ThisIsAWhat(X)))
                {
                case "FieldDelimiter":
                {
                    X = Strings.Mid(X, Strings.Len(FD) + 1, Strings.Len(X));
                    break;
                }

                case "C_L_MultiLine":
                {
                    Pop1(ref X, FD);
                    CreateFileNameFromSintax += "a";
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                {
                    CreateFileNameFromSintax += "g";
                    Pop1(ref X, FD);
                    break;
                }

                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                {
                    CreateFileNameFromSintax += "c";
                    Pop1(ref X, FD);
                    break;
                }

                case "C_L_Comment":
                {
                    CreateFileNameFromSintax += "r";
                    Pop1(ref X, FD);
                    break;
                }

                case "C_L_Extention":
                {
                    Y = Pop(ref X, FD); // Save the extension till last
                    CreateFileNameFromSintax += "e";
                    break;
                }

                case "C_L_VarChars":
                {
                    CreateFileNameFromSintax += Pop1(ref X, FD);
                    break;
                }

                case "comment" // Ignore the rest of the line
                    :
                {
                    CreateFileNameFromSintax += "h";
                    PopLine(ref X);
                    break;
                }

                case "Quote":
                {
                    // CreateFileNameFromSintax &=
                    PopQuote(ref X); // Throw quote away???
                    CreateFileNameFromSintax += "q";
                    break;
                }

                case "KeyWord":
                {
                    CreateFileNameFromSintax += Pop(ref X, FD);// Save the actual keyword...
                    break;
                }

                case "Function":
                {
                    CreateFileNameFromSintax += "f";
                    Pop(ref X, FD);
                    break;
                }

                case "Operator":
                {
                    CreateFileNameFromSintax += "o";
                    Pop(ref X, FD);// Save the actual keyword...
                    break;
                }

                case "Alpha":
                {
                    CreateFileNameFromSintax += "l";
                    Pop1(ref X, FD);// should be a variable name
                    break;
                }

                case "Number":
                {
                    Pop(ref X, FD); // treated as a variable name
                    CreateFileNameFromSintax += "3";
                    break;
                }

                case "SpecialCharacter":
                {
                    Pop(ref X, FD);
                    CreateFileNameFromSintax += "_";
                    break;
                }

                case "Variable":
                {
                    CreateFileNameFromSintax += "V";
                    Pop1(ref X, FD);
                    break;
                }

                case "Unknown":
                {
                    CreateFileNameFromSintax += "_";
                    Pop(ref X, FD);
                    break;
                }

                default:
                {
                    if (ThisIsAVariableName(No_FieldDelimiter(ThisIsAWhat(X))) == true)
                        CreateFileNameFromSintax += "V";
                    else
                        CreateFileNameFromSintax += ThisIsAVariableName(No_FieldDelimiter(ThisIsAWhat(X)));
                    Pop1(ref X, FD);
                    break;
                }
                }
            }

            // remove any special characters from the file name
            for (I = 1; I <= Strings.Len(CreateFileNameFromSintax); I++)
            {
                while (ThisIsASpecalCharacter(Strings.Mid(CreateFileNameFromSintax, I, 1)) & PrintAbleNull(Strings.Mid(CreateFileNameFromSintax, I, 1)) != "_")
                    CreateFileNameFromSintax = Strings.Mid(CreateFileNameFromSintax, 1, I - 1) + Strings.Mid(CreateFileNameFromSintax, I + 1, Strings.Len(CreateFileNameFromSintax));
            }
            if (CreateFileNameFromSintax == "" | Information.IsNothing(CreateFileNameFromSintax))
                CreateFileNameFromSintax = MakeNewName("FileName_", LineNumber, SinTaxLine) + ".Symbol";
            else
                // need to know if it will become a symbol or will become program code
                if (Y == "")
                    CreateFileNameFromSintax += ".symbol";
                else
                    CreateFileNameFromSintax += "." + Y;
        }

        void MakeSymbolOutline(string MySymbolName, long LineNumber)
        {
            string MyColorName;
            long I;

            GetSelfCorrectingIndexes(MySymbolName);
            I = MyUniverse.SysGen.Constants.constantSymbolCenter;
            MyColorName = Color_FileName[MyMinMax(TopOfFile("Symbol") % TopOfFile("Color"), 1, TopOfFile("Color"))];
            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, I, I, -I, MyColorName, LineNumber);
            MyColorName = Color_FileName[MyMinMax(TopOfFile("Symbol") % TopOfFile("Color"), 1, TopOfFile("Color"))];
            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, -I, -I, -I, MyColorName, LineNumber);
            MyColorName = Color_FileName[MyMinMax(TopOfFile("Symbol") % TopOfFile("Color"), 1, TopOfFile("Color"))];
            AddNEWSymbolLineRecord(MySymbolName, "/Line", -I, -I, I, -I, MyColorName, LineNumber);
            MyColorName = Color_FileName[MyMinMax(TopOfFile("Symbol") % TopOfFile("Color"), 1, TopOfFile("Color"))];
            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, -I, I, I, MyColorName, LineNumber);
            MyColorName = Color_FileName[MyMinMax(TopOfFile("Symbol") % TopOfFile("Color"), 1, TopOfFile("Color"))];

            AddNEWSymbolLineRecord(MySymbolName, "/Line", I, I, -I, -I, MyColorName, LineNumber);
            MyColorName = Color_FileName[MyMinMax(TopOfFile("Symbol") % TopOfFile("Color"), 1, TopOfFile("Color"))];
            AddNEWSymbolLineRecord(MySymbolName, "/Line", -I, I, I, -I, MyColorName, LineNumber);
        }


        long MakeSymbolFromSinTax(string COdeLine, long LineNumber, string PathName)
        {
            long IndexSymbol, IndexFlowChart, IndexNamed; // , SavedSymbolIndex 
            string MySymbolName;
            string SinTaxLine;
            long I, x1, y1;
            // Dim D As long
            MyPointStructure TempXY;
            long NumberOfPoints;

            // ?MakeSymbolFromSinTax = 0 ' named index


            NumberOfPoints = 1;
            // FindingMyBugs(20) 'hack Least amount of checking here

            SinTaxLine = Convertmicrocodetext2Sintax(ref My_Sintax_Line_Parsed, COdeLine);

            MySymbolName = Strings.Trim(MakeNewName("S_", LineNumber, COdeLine)); // & keyWordForCodeLine(COdeLine)

            // 2020 08 06 added to make a named record first
            AddNewNamedRecord(MySymbolName, COdeLine, "nop", "Made With DeCompile", CreateFileNameFromSintax(SinTaxLine, LineNumber), MyUniverse.ProgramOptions.C_L_LanguageClassName, "FlowChart Decompile", ".01", "", SinTaxLine);
            AddNEWSymbolpointRecord(MySymbolName, "/Name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, My_VariableName(COdeLine, NumberOfPoints, LineNumber), LineNumber);

            // FindingMyBugs(70) 'hack Least amount of checking here
            IndexSymbol = FindInSymbolList(ref MySymbolName);
            x1 = MyUniverse.MySymbolPoints[NumberOfPoints].X;
            y1 = MyUniverse.MySymbolPoints[NumberOfPoints].Y;
            IndexFlowChart = AddFlowChartRecordUse(MySymbolName, "/use", MyUniverse.SysGen.Placement.Xx, MyUniverse.SysGen.Placement.Yy, "Default", "", "errored", "", LineNumber);

            FindingMyBugs(70); // hack Least amount of checking here

            pathnames = MyParse(ref My_CodeLine_Parsed, COdeLine);
            SinTaxLine = MakeStatementSintax(My_Sintax_Line_Parsed);

            // This should decompile a line of code, add a symbol, and lines and a syntax for it.
            // Idex = TopOfFile("Symbol") + 1
            // FindingMyBugs(90) 'hack Least amount of checking here
            IndexSymbol = FindInSymbolList(ref MySymbolName); // Should Never Happen
            // FindingMyBugs(70) 'hack Least amount of checking here
            // MyMsgCtr(1010, "MakeSymbolFromSinTax", MakeStatementReplacements(COdeLine), COdeLine, MySymbolName, My_VariableName(COdeLine, NumberOfPoints, LineNumber), IndexSymbol.ToString, IndexNamed.ToString, "", "", "")
            if (IndexSymbol < 1)
            {
                // FindingMyBugs(10) 'hack Least amount of checking here
                // ?IndexSymbol = NewTopOfFile("Symbol") '20200629 ' extra?
                AddNEWSymbolpointRecord(MySymbolName, "/name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, "", LineNumber); // SinTaxLine) No Options for now ' This is adding a /name that shoule have alreasy been added.
                IndexSymbol = FindInSymbolList(ref MySymbolName); // Should Never Happen
            }
            else
            {
            }
            // SavedSymbolIndex = IndexSymbol
            NumberOfPoints = 0;
            I = 1;
            while (I < Information.UBound(My_Sintax_Line_Parsed))
            {
                // 2020 07 28 change ifthenelse to selectcase
                switch (No_FieldDelimiter(ThisIsAWhat(My_Sintax_Line_Parsed[I])))
                {
                case "Quote":
                case "Alpha":
                case "Number":
                case "Unknown":
                case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                {
                    NumberOfPoints += 1;
                    IndexSymbol += 1;
                    if (NumberOfPoints > Information.UBound(MyUniverse.MySymbolPoints))
                    {
                        Abug(810, "More than 121 points in the syntax, no where else to place pooints", COdeLine, "");
                        break;
                    }
                    x1 = MyUniverse.MySymbolPoints[NumberOfPoints].X;
                    y1 = MyUniverse.MySymbolPoints[NumberOfPoints].Y;
                    AddNEWSymbolpointRecord(MySymbolName, "/Point", x1, y1, "both", "errored", My_VariableName(COdeLine, NumberOfPoints, LineNumber), LineNumber); // errored as the data type
                    TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.Xx, MyUniverse.SysGen.Placement.Yy, x1, y1, PathName);
                    // A I N F O 2 (170)
                    IndexFlowChart = AddFlowChartRecordPath(My_VariableName(COdeLine, NumberOfPoints, LineNumber), "/path", MyUniverse.SysGen.Placement.Xx + x1, MyUniverse.SysGen.Placement.Yy + y1, TempXY.Xx, TempXY.Yy, "logic", My_VariableName(COdeLine, NumberOfPoints, LineNumber), LineNumber);
                    // A I N F O 2 (171)
                    // why am I trying to connect paths here? or even see if it is connected?
                    if (ConnectPath(IndexFlowChart) < 1)
                    {
                    }
                    else
                        AInfo1(783, "Path is connected to something", ConnectPath(IndexFlowChart), "");
                    break;
                }

                case "C_L_MultiLine":
                case "C_L_Comment":
                case "C_L_Extention":
                case "C_L_VarChars":
                {
                    break;
                }

                case "Comment":
                case "keyword":
                case "SpecialCharacter":
                case "Function":
                case "Operator":
                {
                    break;
                }

                case null:
                    case "FieldDelimiter" // no use continueing with nothing there.
                        :
                    {
                        break;
                    }

                    default:
                    {
                        if (ThisIsAVariableName(My_Sintax_Line_Parsed[I]) == true)
                        {
                            // THis is a copy of what's above 
                            NumberOfPoints += 1;
                            IndexSymbol += 1;
                            x1 = MyUniverse.MySymbolPoints[NumberOfPoints].X;
                            y1 = MyUniverse.MySymbolPoints[NumberOfPoints].Y;
                            AddNEWSymbolpointRecord(MySymbolName, "/Point", x1, y1, "both", "errored", My_VariableName(COdeLine, NumberOfPoints, LineNumber), LineNumber); // errored as the data type
                            TempXY = OtherEndOfNewMadePath(MyUniverse.SysGen.Placement.Xx, MyUniverse.SysGen.Placement.Yy, x1, y1, PathName);
                            // A I N F O 2 (170)
                            IndexFlowChart = AddFlowChartRecordPath(My_VariableName(COdeLine, NumberOfPoints, LineNumber), "/path", MyUniverse.SysGen.Placement.Xx + x1, MyUniverse.SysGen.Placement.Yy + y1, TempXY.Xx, TempXY.Yy, "logic", My_VariableName(COdeLine, NumberOfPoints, LineNumber), LineNumber);
                            // A I N F O 2 (171)
                            // why am I trying to connect paths here? or even see if it is connected?
                            if (ConnectPath(IndexFlowChart) < 1)
                            {
                            }
                            else
                                AInfo1(784, "Path is connected to something", ConnectPath(IndexFlowChart), "");
                        }
                        else
                            Abug(324, "Unknown 'ThisIsAWhat()' = " + ThisIsAWhat(My_Sintax_Line_Parsed[I]), My_Sintax_Line_Parsed[I], I);
                        break;
                    }
                }
                I += 1;
            }

            IndexNamed = AddNewNamedRecord(MySymbolName, COdeLine, "nop", COdeLine, CreateFileNameFromSintax(SinTaxLine, LineNumber), MyUniverse.ProgramOptions.C_L_LanguageClassName, "FlowChart", "0.0", "?", SinTaxLine);

            MakeSymbolOutline(MySymbolName, LineNumber);

            ReSortSymbolList();


            Clear_Screen(SymbolScreen.PictureBox1);
            AddSymbolToDropDown(MySymbolName);
            MyDoEvents();
            // Below should redraw the top of the list (providing it is not sorted (Which is is now), if it is, then it has to 
            // be changed to a FindIndexOfComboBoxList.....
            // 2020 07 04 SymbolScreen.ToolStripDropDownButtonSynbolNames.SelectedIndex = MyMinMax(Idex, 1, SymbolScreen.ToolStripDropDownButtonSynbolNames.Items.Count - 1)
            SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, MySymbolName);
            MyDoEvents();
            FindingMyBugsCheckForErrors(IndexFlowChart, IndexNamed, IndexSymbol);
            MyDoEvents();
            CheckSymbolByNamedIndex(IndexNamed);
            return IndexNamed;
        }

        void AddPointNameToDropDown(string MyPointName)
        {
            long I;
            if (PrintAbleNull(MyPointName) == "_")
                return; // nothing in the point name
            for (I = 0; I <= SymbolScreen.ComboBoxPointNameList.Items.Count - 1; I++)
            {
                if (MyPointName == SymbolScreen.ComboBoxPointNameList.Items.Item(I).ToString)
                    return;// Do Not Add it again.
            }
            SymbolScreen.ComboBoxPointNameList.Items.Add(MyPointName);
            FindingMyBugs(100);
        }


        void AddLineNameToDropDown(string MyLineName)
        {
            long I;
            for (I = 0; I <= SymbolScreen.ComboBoxLineNameList.Items.Count - 1; I++)
            {
                if (MyLineName == SymbolScreen.ComboBoxLineNameList.Items.Item(I).ToString)
                    return;// Do Not Add it again.
            }
            SymbolScreen.ComboBoxLineNameList.Items.Add(MyLineName);
            FindingMyBugs(100);
        }


        void AddSymbolToDropDown(string MySymbolName)
        {
            long I;
            bool FlowChartFlag;

            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref FlowChartScreen.ToolStripDropDownSelectSymbol.Text, SymbolScreen.ToolStripDropDownSelectSymbol) == false)
            {
                Abug(325, "flowchart screen selected symbol  does not match symbol screen selected symbol ", HighLight(FlowChartScreen.ToolStripDropDownSelectSymbol.Text), HighLight(SymbolScreen.ToolStripDropDownSelectSymbol.Text));
                if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedSymbolName, SymbolScreen.ToolStripDropDownSelectSymbol) == true)
                {
                    AInfo1(753, "Mismatch Selection Symbol, Flowchart selection text changed", "to " + MyUniverse.ProgramOptions.SelectedSymbolName, " From " + FlowChartScreen.ToolStripDropDownSelectSymbol.Text);
                    SelectInToolStripDropDownButton(FlowChartScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);
                }
                if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedSymbolName, FlowChartScreen.ToolStripDropDownSelectSymbol) == true)
                {
                    AInfo1(754, "Mismatch Selection Symbol, symbol screen selection text changed", "to " + MyUniverse.ProgramOptions.SelectedSymbolName, " From " + SymbolScreen.ToolStripDropDownSelectSymbol.Text);
                    SelectInToolStripDropDownButton(SymbolScreen.ToolStripDropDownSelectSymbol, MyUniverse.ProgramOptions.SelectedSymbolName);
                }
            }


            FlowChartFlag = false;

            if (FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count != SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count)
                Abug(326, "The number Of symbols In the FlowChart And Symbol Screen's do not match", FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count, SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count);

            // This takes way to long, need to change to a .find()
            for (I = 0; I <= FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1; I++)
            {
                if (MySymbolName == FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(I).ToString)
                {
                    FlowChartFlag = true;
                    break; // Do Not Add it again.
                }
            }

            if (FlowChartFlag == false)
            {
                FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Add(MySymbolName);
                // todo need to also add the .changed from flowchart to symbolscreen., to make sure they are both in sync.
                SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Add(MySymbolName);
            }
            FindingMyBugsDropDowns(); // only check the drop downs for errors now.
        }

        MyPointStructure OtherEndOfNewMadePath(long Symbolx1, long Symboly1, long Pointx1, long Pointy1, string PathName)
        {
            OtherEndOfNewMadePath = default(MyPointStructure);
            OtherEndOfNewMadePath.Named.PathName = PathName;
            // AInfo1( 9 9 9, "A" & MyShowPoint(OtherEndOfNewMadePath.Xx, OtherEndOfNewMadePath.Yy), MyShowPoint(Pointx1, Pointy1), MyShowPoint(Symbolx1, Symboly1))
            OtherEndOfNewMadePath.Xx = MySign(Pointx1) * MyUniverse.SysGen.Constants.constantSymbolCenter;
            OtherEndOfNewMadePath.Yy = MySign(Pointy1) * MyUniverse.SysGen.Constants.constantSymbolCenter;

            OtherEndOfNewMadePath.Xx = MySign(Pointx1) * MyUniverse.SysGen.Constants.constantSymbolCenter + Pointx1 + Symbolx1;
            OtherEndOfNewMadePath.Yy = MySign(Pointy1) * MyUniverse.SysGen.Constants.constantSymbolCenter + Pointy1 + Symboly1;
        }

        long MyQuickNumbersort(string MyTable, long[] MyArray_Long, long iSAM[], int minIndex, int maxIndex)
        {
            long med_valueNumber, Med_valueIndex;
            int hiIndex;
            int loIndex;
            int index;
            MyQuickNumbersort = 0;
            if ((iSAM[1] != 0) & (iSAM[1] == iSAM[2]))
            {
                MyMsgCtr(1167, "MyQuickNumberSort", iSAM[1].ToString(), iSAM[2].ToString(), "", "", "", "", "", "", "");
                MyQuickNumbersort += MyReSortAll_long(MyTable, ref MyArray_Long, ref iSAM);
            }
            // If the list has no more than 1 element, it's sorted.
            if (minIndex >= maxIndex)
                return;

            // Pick a dividing item.
            index = System.Convert.Tolong((maxIndex - minIndex + 1) * VBMath.Rnd() + minIndex);
            if (index <= 0)
                MyMsgCtr(1168, "MyQuickNumberSort", index.ToString(), "", "", "", "", "", "", "", "");
            if (index <= 0)
                index = 1;
            med_valueNumber = MyArray_Long[iSAM[index]];
            Med_valueIndex = index;

            // Swap it to the front so we can find it easily.
            // iSAM(index) = iSAM(minIndex)
            MySwapNn(MyTable, MyArray_Long, ref iSAM, index, minIndex);
            MyQuickNumbersort += 1;
            if (MyCheckIndex_long(MyTable, index, MyArray_Long, ref iSAM) == false)
                return;


            // Move the items smaller than this into the left
            // half of the list. Move the others into the right.
            loIndex = minIndex;
            hiIndex = maxIndex;
            do
            {
                // Look down from hi for a value < med_value.
                while (MyArray_Long[iSAM[hiIndex]] >= med_valueNumber)
                {
                    hiIndex -= 1;
                    if (hiIndex <= loIndex)
                        break;
                }

                if (hiIndex <= loIndex)
                {
                    MySwap(MyTable, loIndex, Med_valueIndex);
                    MyQuickNumbersort += 1;
                    MyCheckIndex_long(MyTable, index, MyArray_Long, ref iSAM);
                    break;
                }

                // Swap the lo and hi values.
                MySwapNn(MyTable, MyArray_Long, ref iSAM, loIndex, hiIndex);
                MyQuickNumbersort += 1;
                MyCheckIndex_long(MyTable, index, MyArray_Long, ref iSAM);
                loIndex += 1;
                while (MyArray_Long[iSAM[loIndex]] < med_valueNumber)
                {
                    loIndex += 1;
                    if (loIndex >= hiIndex)
                        break;
                }

                if (loIndex >= hiIndex)
                {
                    loIndex = hiIndex;
                    MySwap(MyTable, hiIndex, Med_valueIndex);
                    MyQuickNumbersort += 1;
                    MyCheckIndex_long(MyTable, index, MyArray_Long, ref iSAM);
                    break;
                }

                // Swap the lo and hi values.
                MySwapNn(MyTable, MyArray_Long, ref iSAM, hiIndex, loIndex);
                MyQuickNumbersort += 1;
                MyCheckIndex_long(MyTable, index, MyArray_Long, ref iSAM);
            } while (true)// hiIndex = hiIndex -1
                ;

            // Sort the two sublists
            MyQuickNumbersort += MyQuickNumbersort(MyTable, MyArray_Long, ref iSAM, minIndex, loIndex - 1);
            MyQuickNumbersort += MyQuickNumbersort(MyTable, MyArray_Long, ref iSAM, loIndex + 1, maxIndex);
            MyCheckIndex_long(MyTable, index, MyArray_Long, ref iSAM);
        }



        int QuickCheckSort(string MyArray[], long iSAM[], long Index)
        {
            QuickCheckSort = 0;
            return; // make it faster
            CheckThisStringArray(16, ref MyArray, ref iSAM, Index);
            if (Index == constantMyErrorCode)
            {
                MyMsgCtr(1399, "QuickCheckSort", Index.ToString(), "", "", "", "", "", "", "", "");
                QuickCheckSort = -1;
                return;
            }
            if (Index < 1L)
            {
                QuickCheckSort = -2;
                return;
            }
            if (Index == 0L)
            {
                // MyMsgCtr(1400, "QuickCheckSort", Index.ToString, "", "", "", "", "", "", "", "")
                QuickCheckSort = -3;
                return;
            }
            if (Index < 1L | Index > Information.UBound(iSAM))
            {
                // MyMsgCtr(1401, "QuickCheckSort", Index.ToString, "", "", "", "", "", "", "", "")
                QuickCheckSort = -4;
                return; // never check an index of zero or below
            }

            if (iSAM[Index] <= 0)
            {
                QuickCheckSort = -5;
                return;
            }

            if (iSAM[Index] == iSAM[Index - 1])
                // MyMsgCtr(1252, "QuickCheckSort",
                // (Index - 1).ToString,
                // iSAM(Index - 1).ToString,
                // MyArray(Index - 1),
                // Index.ToString,
                // iSAM(Index).ToString,
                // MyArray(Index),
                // (Index + 1).ToString,
                // iSAM(Index + 1).ToString,
                // MyArray(Index + 1))

                QuickCheckSort = -6;

            if (iSAM[Index] == iSAM[Index + 1])
            {
                MyMsgCtr(1280, "QuickCheckSort", (Index - 1).ToString(), iSAM[Index - 1].ToString(), MyArray[Index - 1], Index.ToString(), iSAM[Index].ToString(), MyArray[Index], (Index + 1).ToString(), iSAM[Index + 1].ToString(), MyArray[Index + 1]);
                QuickCheckSort = -7;
            }

            if (MyCompared2(ref MyArray, ref iSAM, Index - 1, Index) == 1)
            {
                MyMsgCtr(1395, "QuickCheckSort", ShortHighLight(Index - 1) + ShortHighLight(iSAM[Index - 1]) + HighLight(MyArray[iSAM[Index - 1]]) + ShortHighLight(Index) + ShortHighLight(iSAM[Index]) + HighLight(MyArray[iSAM[Index]]) + ShortHighLight(Index + 1) + ShortHighLight(iSAM[Index + 1]) + HighLight(MyArray[iSAM[Index + 1]]), MyCompared1_a(MyArray[iSAM[Index - 1]], MyArray[iSAM[Index]]).ToString(), MyCompared1_a(MyArray[iSAM[Index]], MyArray[iSAM[Index + 1]]).ToString(), MyCompared1_a(MyArray[iSAM[Index - 1]], MyArray[iSAM[Index]]).ToString(), "", "", "", "", "");
                QuickCheckSort = -8;
            }

            if (MyCompared2(ref MyArray, ref iSAM, Index, Index + 1) == 1)
            {
                MyMsgCtr(1396, "QuickCheckSort", "{" + Index - 1 + "} " + "(" + iSAM[Index - 1] + ")>" + MyArray[iSAM[Index - 1]] + "<", "{" + Index + "} " + "(" + iSAM[Index] + ")>" + MyArray[iSAM[Index]] + "<", "{" + Index + 1 + "} " + "(" + iSAM[Index + 1] + ")>" + MyArray[iSAM[Index + 1]] + "<", MyCompared1_a(MyArray[iSAM[Index - 1]], MyArray[iSAM[Index]]).ToString(), MyCompared1_a(MyArray[iSAM[Index]], MyArray[iSAM[Index + 1]]).ToString(), MyCompared1_a(MyArray[iSAM[Index]], MyArray[iSAM[Index + 1]]).ToString(), "", "", "");
                QuickCheckSort = -9;
            }
        }


        // ***********************************************************************

        // Omit plngLeft & plngRight; they are used internally during recursion
        void QuickSort3(long[] pvarArray, long plngLeft, long plngRight)
        {
            // pvararray was variant
            long lngFirst;
            long lngLast;
            long varMid; // variant
            long lngIndex;
            long varSwap; // variant
            long a;
            long b;
            long c;

            if (plngRight == 0)
            {
                plngLeft = Information.LBound(pvarArray);
                plngRight = Information.UBound(pvarArray);
            }
            lngFirst = plngLeft;
            lngLast = plngRight;
            lngIndex = plngRight - plngLeft + 1;
            a = System.Convert.Tolong(lngIndex * VBMath.Rnd()) + plngLeft;
            b = System.Convert.Tolong(lngIndex * VBMath.Rnd()) + plngLeft;
            c = System.Convert.Tolong(lngIndex * VBMath.Rnd()) + plngLeft;
            if (pvarArray[a] <= pvarArray[b] & pvarArray[b] <= pvarArray[c])
                lngIndex = b;
            else if (pvarArray[b] <= pvarArray[a] & pvarArray[a] <= pvarArray[c])
                lngIndex = a;
            else
                lngIndex = c;
            varMid = pvarArray[lngIndex];
            do
            {
                while (pvarArray[lngFirst] < varMid & lngFirst < plngRight)
                    lngFirst += 1;
                while (varMid < pvarArray[lngLast] & lngLast > plngLeft)
                    lngLast -= 1;
                if (lngFirst <= lngLast)
                {
                    varSwap = pvarArray[lngFirst];
                    pvarArray[lngFirst] = pvarArray[lngLast];
                    pvarArray[lngLast] = varSwap;
                    lngFirst += 1;
                    lngLast -= 1;
                }
            } while (!lngFirst > lngLast)// lngLast = lngLast -1// lngLast = lngLast -1
                ;
            if (lngLast - plngLeft < plngRight - lngFirst)
            {
                if (plngLeft < lngLast)
                    QuickSort3(pvarArray, plngLeft, lngLast);
                if (lngFirst < plngRight)
                    QuickSort3(pvarArray, lngFirst, plngRight);
            }
            else
            {
                if (lngFirst < plngRight)
                    QuickSort3(pvarArray, lngFirst, plngRight);
                if (plngLeft < lngLast)
                    QuickSort3(pvarArray, plngLeft, lngLast);
            }
        }



        //   Shared Sub HeapSort(pvarArray() As String)
        // Dim i As long
        // Dim iMin As long
        // Dim iMax As long
        // Dim varSwap As String
        // MyTrace(408, "HeapSort", 375 - 357)
        // 
        // iMin = LBound(pvarArray)
        // iMax = UBound(pvarArray)
        // For i = CInt((iMax + iMin) / 2) To iMin Step -1
        // Heap1(pvarArray, i, iMin, iMax)
        // Next i
        // For i = iMax To iMin + 1 Step -1
        // varSwap = pvarArray(i)
        // pvarArray(i) = pvarArray(iMin)
        // pvarArray(iMin) = varSwap
        // Heap1(pvarArray, iMin, iMin, i - 1)
        // Next i
        // End Sub'
        // 
        void Heap1(string[] pvarArray, long i, long iMin, long iMax)
        {
            long lngLeaf;
            string varSwap;

            do
            {
                lngLeaf = i + i - (iMin - 1);
                switch (lngLeaf)
                {
                    case object _ when lngLeaf > iMax:
                    {
                        break;
                        break;
                    }

                    case object _ when lngLeaf < iMax:
                    {
                        if (pvarArray[lngLeaf + 1] > pvarArray[lngLeaf])
                            lngLeaf += 1;
                        break;
                    }
                }

                if (pvarArray[i] > pvarArray[lngLeaf])
                    break;
                varSwap = pvarArray[i];
                pvarArray[i] = pvarArray[lngLeaf];
                pvarArray[lngLeaf] = varSwap;
                i = lngLeaf;
            } while (true);
        }

        void MyErrorMessages(string Hiding, long ErrorNumber, string Severity, string Message)
        {
            switch (Strings.LCase(Severity))
            {
            case "wrong":
            {
                break;
            }

            case "information":
            {
                break;
            }

            case "warning":
            {
                break;
            }

            case "error":
            {
                break;
            }

            case "display":
            {
                break;
            }

            case "status":
            {
                break;
            }

            default:
            {
                Abug(329, Severity, 0, 0);
                Interaction.MsgBox("Invalid Message Severity in Error Message", MsgBoxStyle.Information, ErrorNumber + FD + Severity + " : " + Message + Constants.vbCrLf + "Must be :information warning wrong Error checking display");
                break;
            }
            }
            OptionScreen.ComboBoxDebug.Items.Add(ErrorNumber + FD + Severity + FD + Message);
            BitSet(ErrorNumber, Hiding);
        }

        long ReBubbleSortAll(string MyTable, string MyArray[], long iSAM[])
        {
            long Index, Jdex;

            ReBubbleSortAll = 0;
            Jdex = TopOfFile(MyTable);
            for (Index = 1; Index <= Jdex; Index++)
                ReBubbleSortAll += (MyReSort(MyTable, ref MyArray, ref iSAM, Index));
            MyUniverse.MyCheatSheet.ColorsSorted = 0;
        }




        // Numbers
        long ReBubbleSortAt(string MyTable, long[] MyArrayLong, long iSAM[], long IndexInput)
        {
            long Flag, Index;

            ReBubbleSortAt = 0;
            Index = IndexInput;
            while (Index > 2 & iSAM[Index] == 0)
                Index -= 1;

            Flag = 1;
            while (Flag > 0)
            {
                Flag = 0;
                if (iSAM[Index] != 0)
                {
                    while (Index > 2 & MyCompared2(ref MyArrayLong, ref iSAM, Index - 1, Index) > 0) // MyCompared(MyArrayLong(iSAM(Index - 1)), MyArrayLong(iSAM(Index))) > 0
                    {
                        // MyMsgCtr(1016, "ReBubbleSortAt", Str(Index - 1), Str(iSAM(Index - 1)), MyArrayLong(iSAM(Index - 1)).ToString, Str(Index), Str(iSAM(Index)), MyArrayLong(iSAM(Index)).ToString, "", "", "")
                        MySwapNn(MyTable, MyArrayLong, ref iSAM, Index - 1, Index);
                        ReBubbleSortAt += 1;
                        Index -= 1;
                        Flag += 1;
                    }
                }
                Index -= 1;
            }
        }

        // *****************************************************
        // Check if this is something, nothing, or flagged as nothing ('_')
        bool IsNullOrNothing(string StringA)
        {
            IsNullOrNothing = false;
            if (Information.IsNothing(StringA))
                IsNullOrNothing = true;
            else if (StringA == "")
                IsNullOrNothing = true;
            else if (StringA == "_")
                IsNullOrNothing = true;
        }

        MyPointStructure DoesPathNamesMatch(long IndexFlowChart1, long IndexFlowChart2, MyPointStructure XY)
        {
            MyPointStructure Temp;
            Temp = default(MyPointStructure);
            // todo need to change this for case sentive in the future.
            if (IndexFlowChart1 == IndexFlowChart2)
                return ZeroZero; // same so they match
            if (FlowChart_TablePathName(IndexFlowChart1) == FlowChart_TablePathName(IndexFlowChart2))
            {
                if (FindIndex_In_TableNetLinks(IndexFlowChart1) != FindIndex_In_TableNetLinks(IndexFlowChart2))
                {
                    Abug(331, "Two paths with the same name", MyShowFlowChartRecord(IndexFlowChart1), MyShowFlowChartRecord(IndexFlowChart2));
                    Abug(332, "Two paths ", MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart1)), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart2)));
                    ConnectPaths(IndexFlowChart1, IndexFlowChart2, FlowChart_TablePathName(IndexFlowChart2));
                    return default(MyPointStructure);
                }
            }
            else
            {
                if (DoesPathMeet(MyLine1(IndexFlowChart1), MyLine2(IndexFlowChart1)) == true)
                    return XY;
                Abug(836, MyShowPoint(IndexFlowChart1) + MyShowPoint(IndexFlowChart2) + " but different names error ", FlowChart_TablePathName(IndexFlowChart1), FlowChart_TablePathName(IndexFlowChart2));
                // todo This is an error and needs to be corrected, two paths (Different names) at same point 
                MakeErrorAt(FlowChartScreen.PictureBox1, XY, MyErrorList[1016 - 1001] + " " + FlowChart_TablePath_Name(IndexFlowChart1) + " " + FlowChart_TablePath_Name(IndexFlowChart2));
                return XY; // failded because the names do not match
            }
            return default(MyPointStructure);
        }


        MyPointStructure MatchingPointsBetweenTwoPaths(long IndexFlowChart1, long IndexFlowChart2)
        {
            MyPointStructure Temp;
            MatchingPointsBetweenTwoPaths = default(MyPointStructure);
            MatchingPointsBetweenTwoPaths.Xx = 99999999;
            MatchingPointsBetweenTwoPaths.Yy = 99999999;

            Temp = DistanceBetweenTwoPoints(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), FlowChart_TableX2(IndexFlowChart2), FlowChart_TableY2(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return MyPoint1XY(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1));

            Temp = DistanceBetweenTwoPoints(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), FlowChart_TableX2(IndexFlowChart2), FlowChart_TableY2(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return MyPoint1XY(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1));

            Temp = DistanceBetweenTwoPoints(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1), FlowChart_TableX1(IndexFlowChart2), FlowChart_TableY1(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return MyPoint1XY(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1));

            Temp = DistanceBetweenTwoPoints(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1), FlowChart_TableX2(IndexFlowChart2), FlowChart_TableY2(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return MyPoint1XY(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1));

            Abug(676, " Not matching points", MyShowLine(MyLine1(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), FlowChart_TableX2(IndexFlowChart2), FlowChart_TableY2(IndexFlowChart2))), "");
            return default(MyPointStructure);
        }

        MyPointStructure DistanceBetweenTwoPaths(long IndexFlowChart1, long IndexFlowChart2)
        {
            MyPointStructure Temp;
            DistanceBetweenTwoPaths = default(MyPointStructure);
            DistanceBetweenTwoPaths.Xx = 99999999;
            DistanceBetweenTwoPaths.Yy = 99999999;

            Temp = DistanceBetweenTwoPoints(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), FlowChart_TableX1(IndexFlowChart2), FlowChart_TableY1(IndexFlowChart2));
            DistanceBetweenTwoPaths.Xx = MyMin(DistanceBetweenTwoPaths.Xx, Temp.Xx); DistanceBetweenTwoPaths.Yy = MyMin(DistanceBetweenTwoPaths.Yy, Temp.Yy);
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return DoesPathNamesMatch(IndexFlowChart1, IndexFlowChart2, Temp);
            DistanceBetweenTwoPaths.Xx = MyMin(DistanceBetweenTwoPaths.Xx, Temp.Xx); DistanceBetweenTwoPaths.Yy = MyMin(DistanceBetweenTwoPaths.Yy, Temp.Yy);
            Temp = DistanceBetweenTwoPoints(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), FlowChart_TableX2(IndexFlowChart2), FlowChart_TableY2(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return DoesPathNamesMatch(IndexFlowChart1, IndexFlowChart2, Temp);
            DistanceBetweenTwoPaths.Xx = MyMin(DistanceBetweenTwoPaths.Xx, Temp.Xx); DistanceBetweenTwoPaths.Yy = MyMin(DistanceBetweenTwoPaths.Yy, Temp.Yy);
            Temp = DistanceBetweenTwoPoints(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1), FlowChart_TableX1(IndexFlowChart2), FlowChart_TableY1(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return DoesPathNamesMatch(IndexFlowChart1, IndexFlowChart2, Temp);
            DistanceBetweenTwoPaths.Xx = MyMin(DistanceBetweenTwoPaths.Xx, Temp.Xx); DistanceBetweenTwoPaths.Yy = MyMin(DistanceBetweenTwoPaths.Yy, Temp.Yy);
            Temp = DistanceBetweenTwoPoints(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1), FlowChart_TableX2(IndexFlowChart2), FlowChart_TableY2(IndexFlowChart2));
            if (Temp.Xx == 0 & Temp.Yy == 0)
                return DoesPathNamesMatch(IndexFlowChart1, IndexFlowChart2, Temp);
            DistanceBetweenTwoPaths.Xx = MyMin(DistanceBetweenTwoPaths.Xx, Temp.Xx); DistanceBetweenTwoPaths.Yy = MyMin(DistanceBetweenTwoPaths.Yy, Temp.Yy);
            return DistanceBetweenTwoPaths;
        }


        MyPointStructure DistanceBetweenTwoPoints(long X1, long Y1, long X2, long Y2)
        {
            return MyPoint1XY(MyABS(X1 - X2), MyABS(Y1 - Y2));
        }



        // why is this combining two nets with different names?
        void CombineNetLinksInto(long IdexNetLinks, long JdexNetLinks)
        {
            long I, J;
            string Temp;
            if (IdexNetLinks == JdexNetLinks)
                return;

            // Check the links of the two nets
            if (Net_TableNames(IdexNetLinks) != Net_TableNames(JdexNetLinks))
            {
                Abug(333, " Combining nets with different names? Why", MyShowNetLnks(IdexNetLinks), MyShowNetLnks(JdexNetLinks));
                Temp = CombineNames(Net_TableNames(IdexNetLinks), Net_TableNames(JdexNetLinks));
            }
            else
                Temp = Net_TableNames(IdexNetLinks);// since they match, Net_TableLinks(JdexNetLinks))

            // The nets in this list is in Temp
            Net_TableLinks(JdexNetLinks, Net_TableLinks(JdexNetLinks) + Net_TableLinks(IdexNetLinks)); // Combine the two nets
            CleanListOfNet_TableLinks(IdexNetLinks);

            for (I = 1; I <= TopOfFile("FlowChart"); I++)
            {
                if (FlowChart_TableCode(I) == "/path")
                {
                    J = FindIndex_In_TableNetLinks(I);     // index of this /pathindex =I
                    Temp = Net_TableLinks(J);        // The list of links of this path name
                    while (Strings.Len(Temp) > 0)             // loop through all of the paths find this one
                    {
                        J = PopValue(ref Temp);          // Get another /path
                        if (J == IdexNetLinks)
                        {
                            if (I == JdexNetLinks)
                            {
                                if (FindIndex_In_TableNetLinks(J) > 0)
                                {
                                    if (FindIndex_In_TableNetLinks(I) > 1)
                                    {
                                        if (Net_TableNames(I) == Net_TableNames(J))
                                        {
                                            // Finally combine the two nets and get rid of the old, it does not matter which is changed.
                                            Net_TableLinks(I, Net_TableLinks(I) + FD + Net_TableLinks(J));
                                            CleanListOfNet_TableLinks(I);
                                            CleanListOfNet_TableLinks(J);
                                            Net_TableNameS(J, ""); // Erase the old dup
                                            Net_TableLinks(J, ""); // Erase the old dup
                                            return;
                                        }
                                    }
                                    else
                                        Abug(334, "The names are different for the two links", MyShowFlowChartRecord(I), MyShowFlowChartRecord(J));
                                }
                                else
                                {
                                }
                            }
                            else
                            {
                            }
                        }
                        else
                        {
                        }
                    }
                }
            }
        }


        string CombineNames(string A, string B)
        {
            if (Strings.InStr(A, "_&_" + B) > 0)
                return A;
            else if (Strings.InStr(B, "_&_" + A) > 0)
                return B;
            return A + "_&_" + B;
        }


        string RemoveNumberFromTextList(string InputString, long NumberToRemove)
        {
            string Temp;
            long I;
            Temp = FD + NumberToRemove.ToString() + FD;
            I = Strings.InStr(InputString, Temp);
            if (I != 0)
                return Strings.Mid(InputString, 1, I) + FD + Strings.Mid(InputString, I + Strings.Len(Temp), Strings.Len(InputString));
            return InputString;
        }



        long MyROUTERnetIndex(long IndexNet)
        {
            long IndexFlowChart;
            string Temp;
            string DebugTemp;
            MyROUTERnetIndex = 0;

            Temp = Net_TableLinks(IndexNet);
            DebugTemp = Net_TableNames(IndexNet);
            AInfo1(788, "Routing path ", MyShowNetLnks(IndexNet), "");
            while (Strings.Len(Temp) > 0)
            {
                IndexFlowChart = PopNonZeroValue(ref Temp);
                if (IndexFlowChart > 0)
                {
                    if (ROUTERIndex2Net(IndexFlowChart, IndexNet) == true)
                        MyROUTERnetIndex += 1;
                }
            }
        }


        MyLineStructure Line2ScreenScale(MyLineStructure xy)
        {
            Line2ScreenScale.a = Copy2ScreenXY(FlowChartScreen.PictureBox1, xy.a);
            Line2ScreenScale.b = Copy2ScreenXY(FlowChartScreen.PictureBox1, xy.b);
        }

        void MyDrawPaths(long IndexFlowChart1, long IndexFlowChart2, long ColorCode)
        {
            MyDrawPaths(MyLine1(IndexFlowChart1), MyLine2(IndexFlowChart2), MyUniverse.OptionDisplay[ColorCode].ColorName);
        }



        void ROUTERMakePath(long IndexFlowChart1, long InDexFlowChart2)
        {
            // todo Need to get the two closest ends.
            MyLineStructure XY;
            long IndexFlowchart;
            XY = FindClosestPathEnds(IndexFlowChart1, InDexFlowChart2);
            // bug this should not just draw a path, but should route it here
            if (XY.a.Xx != 0 | XY.a.Yy != 0 | XY.b.Xx != 0 | XY.b.Yy != 0)
            {
                // Abug(999, "Needs to route path better", "", MyShowLine(XY))

                AutoROUTERPath(IndexFlowChart1, InDexFlowChart2);
                IndexFlowchart = AddFlowChartRecordPath(FlowChart_TablePathName(IndexFlowChart1), "/path", XY.a.Xx, XY.a.Yy, XY.b.Xx, XY.b.Yy, FlowChart_Table_DataType(IndexFlowChart1), "", MyUniverse.MySS.Inputs.LineNumberIn);
                PaintAll(FlowChartScreen.PictureBox1, IndexFlowchart, IndexFlowchart);
            }
        }
        void RouterMakePath(MyPointStructure myXY1, MyPointStructure MyXy2)
        {
            long IndexFlowChart;
            // If myXY1.Xx <> 0 Or myXY1.Yy <> 0 Or XY.b.Xx <> 0 Or XY.b.Yy <> 0 Then
            if (myXY1.Xx != 0 | myXY1.Yy != 0 | MyXy2.Xx != 0 | MyXy2.Yy != 0)
            {
                AInfo1(789, "Make a path to ", MyShowPoint(myXY1), MyShowPoint(MyXy2));
                // first find net name for this point
                IndexFlowChart = FindPathNameAt(myXY1);
                // then add a new path there 
                AddFlowChartRecordPath(FlowChart_TablePathName(IndexFlowChart), "/path", myXY1.Xx, myXY1.Yy, MyXy2.Xx, MyXy2.Yy, FlowChart_Table_DataType(IndexFlowChart), "", MyUniverse.MySS.Inputs.LineNumberIn);
                PaintAll(FlowChartScreen.PictureBox1, IndexFlowChart, IndexFlowChart);
            }
            else
                AInfo(811, "Not doable ", MyShowPoint(myXY1), MyShowPoint(MyXy2));
        }



        bool ROUTERPointsMatch(MyPointStructure XY1, MyPointStructure XY2)
        {
            if (XY1.Xx == XY2.Xx & XY1.Yy == XY2.Yy)
                return true;
            return false;
        }


        MyPointStructure ROUTERend(long Indexflowchart, MyPointStructure MyXY)
        {
            if (FlowChart_TableCode(Indexflowchart) != "/path")
            {
                Abug(491, "Trying to route to a non /path", MyShowFlowChartRecord(Indexflowchart), "");
                return ZeroZero;
            }
            if (FlowChart_TableX1(Indexflowchart) == MyXY.Xx & FlowChart_TableY1(Indexflowchart) == MyXY.Yy)
                return MyPoint1_1XY(Indexflowchart);
            if (FlowChart_TableX2(Indexflowchart) == MyXY.Xx & FlowChart_TableY2(Indexflowchart) == MyXY.Yy)
                return MyPoint2_1XY(Indexflowchart);
            Abug(492, "Neither end of the path is connected", MyShowFlowChartRecord(Indexflowchart), MyShowPoint(MyXY));
            return ZeroZero;
        }

        void MyDrawPaths(MyLineStructure XY1, MyLineStructure XY2, string ColorName)
        {
            MyLineStructure xy;
            xy = default(MyLineStructure);

            // todo change the search pattern color to be changable.

            xy.a.Xx = XY1.a.Xx; xy.a.Yy = XY1.a.Yy; xy.b.Xx = XY2.a.Xx; xy.b.Yy = XY2.a.Yy; // : xy = Line2ScreenScale(xy)
            // AInfo(768, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartScreen.PictureBox1, ref xy, ColorName, 1);
            xy.a.Xx = XY1.a.Xx; xy.a.Yy = XY1.b.Yy; xy.b.Xx = XY2.a.Xx; xy.b.Yy = XY2.a.Yy; // : xy = Line2ScreenScale(xy)
            // AInfo(769, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartScreen.PictureBox1, ref xy, ColorName, 1);
            xy.a.Xx = XY1.b.Xx; xy.a.Yy = XY1.a.Yy; xy.b.Xx = XY2.b.Xx; xy.b.Yy = XY2.b.Yy; // : xy = Line2ScreenScale(xy)
            // AInfo(770, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartScreen.PictureBox1, ref xy, ColorName, 1);
            xy.a.Xx = XY1.b.Xx; xy.a.Yy = XY1.b.Yy; xy.b.Xx = XY2.b.Xx; xy.b.Yy = XY2.b.Yy; // : xy = Line2ScreenScale(xy)
            // AInfo(771, "Showing where a path can go  ", MyShow3Lines(XY1, xy, XY2), "")
            My_Draw_Line_Or_Path(FlowChartScreen.PictureBox1, ref xy, ColorName, 1);
        }



        // make a list of paths that connect these two
        // trying to connect from the indexflowchart (which is the first in the netlinks list) to anything else in the netlinks list
        bool ROUTERIndex2Net(long IndexFlowChart, long IndexNets)
        {
            string Temp1, Temp2, Temp3; // 1 holds the list not tried (to try others) , 2 holds the list of the one we are trying to ROUTER
            MyLineStructure XY1, XY2;
            long LastDistance, LastIndexFlowChart, Idex;

            // option (19) turns off auto ROUTER
            if (MyOptionTest(19) == false)
            {
                AInfo1(790, "Auto router option is turned off:", "", "");
                return false;
            }

            // AInfo(339, "ROUTER Starting to find a path between ", MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNets))

            LastDistance = 100000000; // really really big number.
            LastIndexFlowChart = -1;
            // First find the closest one
            Temp1 = Net_TableLinks(IndexNets);
            XY1 = FlowChart2Line(IndexFlowChart);

            Temp2 = RemoveNumberFromTextList(Temp1, IndexFlowChart);

            while (Strings.Len(Temp2) > 0)
            {
                Idex = PopNonZeroValue(ref Temp2);
                if (Idex != IndexFlowChart & Idex != 0)
                {
                    AInfo(830, "trying to route between ", MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(Idex));
                    XY2 = FlowChart2Line(Idex);
                    Temp3 = MyShowLine(XY1) + "   " + MyShowLine(XY2);

                    if (FlowChart_TablePathName(IndexFlowChart) != FlowChart_TablePathName(Idex))
                        Abug(493, "trying to connect paths with different names ", MyShowFlowChartRecord(FlowChart_TablePathName(IndexFlowChart)), MyShowFlowChartRecord(FlowChart_TablePathName(Idex)));

                    // MyDrawPaths(XY1, XY2, MyUniverse.OptionDisplay(Idex Mod UBound(MyUniverse.OptionDisplay)).ColorName)

                    if (MyDistancePath(XY1, XY2) < LastDistance)
                    {
                        AInfo1(791, "saving a closer distance to something else", MyDistancePath(XY1, XY2), LastDistance + "     " + MyDistancePath(XY1, XY2));
                        LastDistance = MyDistancePath(XY1, XY2);
                        LastIndexFlowChart = Idex;
                    }
                }
                Temp2 = RemoveNumberFromTextList(Temp2, Idex);
            }

            // This is where the router actually starts to work b etween two paths.
            if (LastIndexFlowChart == constantMyErrorCode)
                return false;
            XY1 = FlowChart2Line(IndexFlowChart);
            XY2 = FlowChart2Line(LastIndexFlowChart);
            MyDrawPaths(XY1, XY2, MyUniverse.OptionDisplay[Idex % Information.UBound(MyUniverse.OptionDisplay)].ColorName);

            // remove this selected from the list

            Idex = LastIndexFlowChart;
            AInfo1(792, "Closest other path to route to.", MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(Idex));
            if (MyOptionTest(14) == true)
            {
                if (IndexFlowChart > 0 & Idex > 0)
                {
                    ROUTERMakePath(IndexFlowChart, Idex);
                    return true;
                }
                else
                {
                    Abug(500, "Trying to route to an invalid index ", MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(Idex));
                    return false;
                }
            }

            // Now should have the two closest together
            if (LastIndexFlowChart != constantMyErrorCode)
            {
                if (ROUTERPath_IsAPathROUTERd(IndexFlowChart, LastIndexFlowChart) == true)
                    return true;
                else if (AutoROUTERPath(IndexFlowChart, LastIndexFlowChart) == false)
                    Abug(341, "Auto route did not find a clear path", MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(LastIndexFlowChart));
                else
                {
                    // todo need to make the path of the auto route success? (or do it in the recurression
                    Abug(342, "Auto Route Worked", "", "");
                    return true;
                }
            }
            return false;
        }


        // have determined that a path needs to be between indexflowchar1 and indexflowchart2

        bool AutoROUTERPath(long IndexFlowChart1, long IndexFlowChart2)
        {
            MyLineStructure TempXY;
            string PathName;
            if (FlowChart_TablePathName(IndexFlowChart1) == FlowChart_TablePathName(IndexFlowChart2))
                PathName = FlowChart_TablePathName(IndexFlowChart1);
            else
                PathName = FlowChart_TablePathName(IndexFlowChart1) + "_" + FlowChart_TablePathName(IndexFlowChart2);
            TempXY = FindClosestPathEnds(IndexFlowChart1, IndexFlowChart2);
            return AutoROUTER_Path(TempXY.a, TempXY.b, PathName);
        }


        // This is to see if the line is clear all the way from a to b with out anything in the way
        // returns zerozero if not doable
        // return the A if recursion is doable
        // returns b when fihished
        // assumes that a path is then made from A to Be if returns B 
        // all the way back to the top
        // Calls itself with a point between A and B going to B till it finds a path
        // First find where the list of the path is in X
        // Why I am only using X, I have no Idea, it should be for X for directions 
        // and when using Y it should be fore directions 
        // Y1 XY2 X3 X4 X5 XY6 Y7 Y8 Y9 XY10 X11 X12 X13 XY14 Y15 Y16
        MyPointStructure ROUTERIsItClearPath(MyPointStructure A, MyPointStructure B)
        {
            long Idex, ZDEX, MyDirZ;
            MyPointStructure MyXYZ0, MyXYZ1, Myxyz2;

            MyDirZ = MyDirection(A, B);
            // Select Case MyDirZ
            // Case 1, 7, 8, 9, 15, 16 'search in Y direction instead
            // Case 2, 6, 10, 14 'specail case search in both directions
            // Case 3, 4, 5, 11, 12, 13
            Idex = FindIndexIniSAMTable("FlowChart", ref "donotadd", ref FlowChart_FileX1, ref FlowChart_iSAM_X1, ref A.Xx);
            if (Idex < 1)
            {
                Idex = 1;
                while (FlowChart_TableX1(FlowChart_iSAM_X1[Idex]) > A.Xx)
                {
                    Idex -= 1;
                    if (Idex < 1)
                        return ZeroZero;
                }
                while (FlowChart_TableX1(FlowChart_iSAM_X1[Idex]) < A.Xx)
                {
                    Idex += 1;
                    if (Idex > TopOfFile("Flowchart"))
                        return ZeroZero;
                }
                Idex -= 1;
            }
            // todo check if there is a path that overlaps this one.
            AInfo1(755, "Recursive find a clear path", MyShowPoint(A) + MyShowPoint(B), "Index in flowchart X1 =" + Idex.ToString());
            // todo this will go through symbols, but I didn't want to subtract myuniverse...symbolcenter for the x1
            do
            {
                MyXYZ1 = ROUTERend(Idex, A);
                if (ROUTERPointsMatch(MyXYZ1, ZeroZero))
                    MyXYZ1 = ROUTERend(Idex, B);
                if (ROUTERPointsMatch(MyXYZ1, ZeroZero) == true & ROUTERPointsMatch(B, ZeroZero) == true)
                {
                    Abug(501, "Make a path here ", MyShowPoint(A), MyShowPoint(MyXYZ1));
                    RouterMakePath(MyXYZ1, B);
                    return MyXYZ1;
                }

                if (ROUTERPointsMatch(MyXYZ1, ZeroZero) == false)
                {
                    Abug(495, "Make a path here ", MyShowPoint(A), MyShowPoint(MyXYZ1));
                    RouterMakePath(MyXYZ1, B);
                    return MyXYZ1;
                }


                // else

                // first try stepping in the right directions
                for (ZDEX = -4; ZDEX <= 4; ZDEX++)
                {
                    MyDirZ = (MyDirection(A, B) + ZDEX + 16) % 16;
                    Myxyz2 = MyXYZ1;
                    Myxyz2.Xx += MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections[MyDirZ, 1, 1]) + MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections[MyDirZ, 1, 2]);
                    Myxyz2.Yy += MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections[MyDirZ, 2, 1]) + MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections[MyDirZ, 2, 2]);
                    MyXYZ0 = ROUTERCheckLinesEndAtEachOther(MyLine1(A, Myxyz2), MyLine1(Myxyz2, B));
                    if (ROUTERPointsMatch(MyXYZ0, ZeroZero) == false)
                    {
                        RouterMakePath(Myxyz2, B);
                        return Myxyz2;
                    }
                }

                Idex += 1;
            } while (Idex < TopOfFile("FlowChart") & FlowChart_TableX1(Idex) == A.Xx)// only trying for first end?// only trying for one end?// // cause we made it to the end ' so tell itself to make a path from a to myxyz1// // cause we made it to the end ' so tell itself to make a path from a to myxyz1// clock step arout the direction of where we are going
                ;
            return ZeroZero;  // return how far it goto below
        }



        // Find a line all the want to match
        // returns A if path found, zerozero if not possible, and B if did not make it to B
        MyPointStructure HowCloseCanYouGet2(MyPointStructure A, MyPointStructure B)
        {
            MyPointStructure XY;
            // Find the longest stright line from a to b
            // First try the longest way
            XY.Xx = B.Xx - A.Xx; // Direction and distance to get from a toward b
            XY.Yy = B.Yy - A.Yy;

            if (ROUTERPointsMatch(ROUTERIsItClearPath(A, B), ZeroZero) == false)
            {
                // getting here means that I need to add a path from A to B
                RouterMakePath(A, B);
                return A;
            }

            // from here on we should step in any direction to find a path
            Abug(499, "Looking for a path here to here.", MyShowPoint(A), MyShowPoint(B));

            if (ROUTERPointsMatch(ROUTERIsItClearPath(A, MyPoint1XY(A.Xx, B.Yy)), ZeroZero) == false)
            {
                RouterMakePath(A, MyPoint1XY(A.Xx, A.Yy + XY.Yy));
                return MyPoint1XY(A.Xx, A.Yy + XY.Yy);
            }

            if (ROUTERPointsMatch(ROUTERIsItClearPath(A, MyPoint1XY(A.Xx + XY.Xx, A.Yy)), ZeroZero) == false)
                return MyPoint1XY(A.Xx + XY.Xx, A.Yy);
            return A;
        }




        // THis tries to find a path from A to B (If fails then save the path that ends  closest to B)
        bool AutoROUTER_Path(MyPointStructure P_A, MyPointStructure P_B, string PathName)
        {
            MyPointStructure NextPointXY;
            // If I can find a point between these two then make a path, and then return true
            // If NOT try again from as close as I got. (Recursive trying) utile it makes it (or is unable to make it.

            // 1.0 try stepping across the longest path looking for one that goes the the X or Y of B
            // Assume that there is already a point where we are starting from.
            // ToDo make it so that it can do 8 directions, (For now just 4)  Angles will be off the grid by half so that they will not interfer with the horx/vert lines..

            // sets the myuniver..... to have the distance you can go in each direction 
            AInfo1(756, "Starting to find a path for " + ShortHighLight(PathName), MyShowPoint(P_A), MyShowPoint(P_B));

            if (P_A.Xx == 0 & P_A.Yy == 0 & P_B.Xx == 0 & P_B.Yy == 0)
                return false;

            NextPointXY = HowCloseCanYouGet2(P_A, P_B); // returns the longest that you can go in the (1-16) directions.
            AInfo1(682, "Found CLosest to end at ", MyShowPoint(NextPointXY), MyShowPoint(P_B));
            if (NextPointXY.Xx == P_B.Xx)
            {
                if (NextPointXY.Yy == P_B.Yy)
                {
                    AInfo1(758, "Finished Found a path from a to b =", MyShowPoint(P_A), MyShowPoint(P_B));
                    AddFlowChartRecordPath(PathName, "/path", NextPointXY.Xx, NextPointXY.Yy, P_B.Xx, P_B.Yy, "DataType", "", 0);
                    return true;
                }
            }
            if ((P_A.Xx == NextPointXY.Xx) & (P_A.Yy == NextPointXY.Yy))
            {
                AInfo1(502, "Failed to route", MyShowPoint(P_A), "");
                return false;
            }
            if (AutoROUTER_Path(NextPointXY, P_B, PathName) == true)
            {
                // So we alhave to add the path before this also (Cause the recursion found the above or the below and is returning here
                AddFlowChartRecordPath(PathName, "/path", P_A.Xx, P_A.Yy, NextPointXY.Xx, NextPointXY.Yy, "DataType", "", 0);
                return true;
            }

            // todo in the future
            // 2.0 try stepping across the shortest path looking for one that goes the the X or Y of B
            Abug(343, "Attempted path not clear", "", "");
            return false;
        }
        MyLineStructure FlowChart2Line(long IndexFlowChart)
        {
            FlowChart2Line = default(MyLineStructure);
            if (FlowChart_TableCode(IndexFlowChart) != "/path")
            {
                Abug(831, "This is not a Path ", MyShowFlowChartRecord(IndexFlowChart), "");
                return ZeroZeroZeroZero;
            }
            FlowChart2Line.a.Xx = FlowChart_TableX1(IndexFlowChart);
            FlowChart2Line.a.Yy = FlowChart_TableY1(IndexFlowChart);
            FlowChart2Line.b.Xx = FlowChart_TableX2(IndexFlowChart);
            FlowChart2Line.b.Yy = FlowChart_TableY2(IndexFlowChart);
        }


        // test all four ends of the two paths to see if they are connected together.
        MyLineStructure FindClosestPathEnds(long IndexFlowChart1, long IndexFlowChart2)
        {
            MyLineStructure XY1, XY2;
            long T1, T2, T3, T4, T5, T6, T7;

            XY1 = FlowChart2Line(IndexFlowChart1);
            XY2 = FlowChart2Line(IndexFlowChart2);
            if (XY1.a.Xx == 0 & XY1.a.Yy == 0)
                Abug(812, "Trying to route to Zero, Zero ", "", "");
            if (XY1.a.Xx == 0 & XY1.a.Yy == 0)
                Abug(813, "Trying to route to Zero, Zero ", "", "");
            if (XY1.a.Xx == 0 & XY1.a.Yy == 0)
                Abug(814, "Trying to route to Zero, Zero ", "", "");
            if (XY1.a.Xx == 0 & XY1.a.Yy == 0)
                Abug(815, "Trying to route to Zero, Zero ", "", "");
            // Test if they are already connected
            T1 = MyDistancePath(XY1, XY2);
            if (T1 == 0)
                return default(MyLineStructure); // do not need to route it, cause they are connected.
            // First find one from each that is the closest 
            T1 = MyDistance(XY1.a, XY2.a);
            T2 = MyDistance(XY1.a, XY2.b);
            T3 = MyDistance(XY1.b, XY2.a);
            T4 = MyDistance(XY1.b, XY2.b);
            T5 = MyMin(T1, T2);
            T6 = MyMin(T3, T4);
            T7 = MyMin(T5, T6);
            if (T7 == T1)
                return MyLine1(XY1.a, XY2.a); // a to a
            if (T7 == T2)
                return MyLine1(XY1.a, XY2.a); // a to b
            if (T7 == T3)
                return MyLine1(XY1.a, XY2.a); // b to a
            if (T7 == T4)
                return MyLine1(XY1.a, XY2.a); // b to b
            return MyLine1(XY1.a, XY2.a);
        }

        // checks if there is a path
        // returns false if the two line segments meet.
        // if the two do not meet then this path is not routed between paths 1 and path 2)
        bool ROUTERPath_IsAPathROUTERd(long IndexFlowChart1, long IndexFlowChart2)
        {
            MyLineStructure XY;
            XY = FindClosestPathEnds(IndexFlowChart1, IndexFlowChart2);
            // Now find a path for the line XY
            if (XY.a.Xx == 0 & XY.a.Yy == 0 & XY.b.Xx == 0 & XY.b.Yy == 0)
                return false;

            AInfo1(759, "Need path for this line", MyShowLine(XY), MyShowFlowChartRecord(IndexFlowChart1) + Constants.vbCrLf + MyShowFlowChartRecord(IndexFlowChart2));
            AutoROUTERPath(IndexFlowChart1, IndexFlowChart2);
            return true;
        }


        void ConnectPaths(long IndexFlowChart1, long IndexFlowChart2, string PathName)
        {
            long I; // look through all of the NetLinks
            long PutIt1, Putit2;
            I = FindIndex_In_TableNetLinks(IndexFlowChart1);
            I = FindIndex_In_TableNetLinks(IndexFlowChart2);
            PathName = CheckThisPathName(PathName, IndexFlowChart1);
            PathName = CheckThisPathName(PathName, IndexFlowChart2);

            if (IndexFlowChart1 == IndexFlowChart2)
                return;
            PutIt1 = 0;
            Putit2 = 0;
            for (I = Information.LBound(Net_FileLinks); I <= Information.UBound(Net_FileLinks); I++)
            {
                if (Strings.InStr(Net_TableLinks(I), FD + IndexFlowChart1 + FD) > 0)
                    PutIt1 = I;
                if (Strings.InStr(Net_TableLinks(I), FD + IndexFlowChart2 + FD) > 0)
                    Putit2 = I;
                if (PutIt1 != 0 & Putit2 != 0)
                    break;
            }

            // Everything is OK
            if (PutIt1 != 0 & Putit2 != 0 & PutIt1 == Putit2)
                return;



            // One not there so add to two
            if (PutIt1 == 0 & Putit2 != 0)
            {
                Net_TableLinks(Putit2, Net_TableLinks(Putit2) + FD + IndexFlowChart1 + FD);
                CleanListOfNet_TableLinks(Putit2);
                return;
            }
            // Two not there so add to one
            if (Putit2 == 0 & PutIt1 != 0)
            {
                Net_TableLinks(PutIt1, Net_TableLinks(PutIt1) + FD + IndexFlowChart2 + FD);
                CleanListOfNet_TableLinks(PutIt1);
                return;
            }

            // If neither one or two is there then add a new netlinks
            if (PutIt1 == 0 & Putit2 == 0)
            {
                I = Information.UBound(Net_FileLinks) + 1;
                var oldNet_FileLinks = Net_FileLinks;
                Net_FileLinks = new string[I + 1];
                if (oldNet_FileLinks != null)
                    Array.Copy(oldNet_FileLinks, Net_FileLinks, Math.Min(I + 1, oldNet_FileLinks.Length));
                var oldNet_FileNames = Net_FileNames;
                Net_FileNames = new string[I + 1];
                if (oldNet_FileNames != null)
                    Array.Copy(oldNet_FileNames, Net_FileNames, Math.Min(I + 1, oldNet_FileNames.Length));
                Net_TableLinks(I, FD + IndexFlowChart1 + FD + IndexFlowChart2 + FD);
                Net_TableNameS(I, PathName); // Add a new path name
                return;
            }

            // Check if they are in different ones, not and fix them.
            if (PutIt1 != 0 & Putit2 != 0 & PutIt1 != Putit2)
                // We have to connect the two nets together. 
                CombineNetLinksInto(PutIt1, Putit2);
            else
            {
            }
        }


        // This tries to combine paths with or without the same name when they both end at the same point
        long ConnectPath(long IndexFlowChart) // Returns the NetIndex that it is in, and cleans up (ignores what it say's it is in for now)
        {
            long IndexFlowChart1, IndexNetLinks1, IndexNetLinks2;
            MyPointStructure Temp;

            if (FlowChartScreen.Visible == false)
                ShowAllForms(ShowScreen1, HideScreen1, HideScreen1, HideScreen1, HideScreen1, HideScreen1);

            IndexFlowChart1 = PathConnectes2(FlowChart_TableCode(IndexFlowChart), IndexFlowChart); // get what else it is connected to (Could return either to another path, or to a symbol or nothing (an error?)
            if (IndexFlowChart1 <= 1)
                return constantMyErrorCode;
            if (IndexFlowChart1 == IndexFlowChart)
                AInfo(832, MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(IndexFlowChart1), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)));

            Temp = DistanceBetweenTwoPaths(IndexFlowChart, IndexFlowChart1);
            if (Temp.Xx != 0 | Temp.Yy != 0)
            {
                AInfo1(785, "These two are not connected." + MyShowPoint(Temp), MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(IndexFlowChart1));
                return constantMyErrorCode;
            }
            Temp = MatchingPointsBetweenTwoPaths(IndexFlowChart, IndexFlowChart1);

            IndexNetLinks1 = FindIndex_In_TableNetLinks(IndexFlowChart); // Get if this is already there
            IndexNetLinks2 = FindIndex_In_TableNetLinks(IndexFlowChart1); // Get if this is already there
            if (Net_TableNames(IndexNetLinks1) != Net_TableNames(IndexNetLinks2))
            {
                Abug(344, "Nets are not the same name " + MyShowPoint(Temp.Xx, Temp.Yy), MyShowAllNet(IndexNetLinks1) + MyShowAllNet(IndexNetLinks2), MyShowNetLnks(IndexNetLinks1) + MyShowNetLnks(IndexNetLinks2));
                MakeErrorAt(FlowChartScreen.PictureBox1, MyPoint1XY(IndexFlowChart), MyErrorList[1016 - 1001] + " " + MyShowFlowChartRecord(IndexFlowChart) + " " + MyShowFlowChartRecord(IndexFlowChart1));
                return constantMyErrorCode;
            }
            if (IndexNetLinks1 != IndexNetLinks2)
            {
                if (IndexNetLinks1 > 0)
                {
                    if (IndexNetLinks2 > 0)
                    {
                        if (FlowChart_TableCode(IndexFlowChart) == "/path")
                        {
                            if (FlowChart_TableCode(IndexFlowChart1) == "/path")
                            {
                                AInfo(637, "Combine two paths because ??", MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNetLinks1) + Constants.vbCrLf + MyShowFlowChartRecord(IndexFlowChart1));
                                // DoesPathNamesMatch(IndexFlowChart , IndexFlowChart1  )
                                CombineNetLinksInto(IndexNetLinks1, IndexNetLinks2); // combine them together and change all of the FlowChart links to point to the new
                                return IndexNetLinks2;
                            }
                            else if (FlowChart_TableCode(IndexFlowChart1) == "/use")
                                AInfo(638, MyShowFlowChartRecord(IndexFlowChart1), MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNetLinks1) + Constants.vbCrLf + MyShowNetLnks(IndexNetLinks2));
                            else
                                AInfo(639, "WARNING Path is connected to Something else might be a /error or a /origin or a /Constant) ", MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNetLinks1) + Constants.vbCrLf + MyShowNetLnks(IndexNetLinks2));
                        }
                        else if (FlowChart_TableCode(IndexFlowChart1) == "/path")
                            AInfo(642, "Symbol is connected to a path", MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNetLinks1) + Constants.vbCrLf + MyShowNetLnks(IndexNetLinks2));
                        else
                            AInfo(643, "Symbol is NOT connected to a path", MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNetLinks1) + Constants.vbCrLf + MyShowNetLnks(IndexNetLinks2));
                    }
                }
            }
            // autoroute path
            if (CountLinks(IndexNetLinks1) > 1)
            {
                AInfo(644, "It should be auto routed here if there is another point the the pathlinks ", "/point=" + MyShowNetLnks(IndexNetLinks1), "/point=" + MyShowNetLnks(IndexNetLinks2));
                if (IndexNetLinks1 > 0 & IndexFlowChart > 0 & IndexFlowChart != IndexNetLinks1)
                {
                    if (ROUTERIndex2Net(IndexFlowChart, IndexNetLinks1) == true)
                        Abug(345, "Path already routed", MyShowNetLnks(IndexNetLinks1), MyShowNetLnks(IndexNetLinks2));
                    else
                        Abug(346, "Needs to do something else", "", "");
                }
            }
            return 0;
        }


        long CountLinks(long IndexNetLinks)
        {
            string Temp;

            // would be faster to count the comma's (FD's)  than decompile the numbers from the list
            CountLinks = 0;
            Temp = Net_TableLinks(IndexNetLinks);

            while (Strings.Len(Temp) > 0)
            {
                if (PopValue(ref Temp) > 0)
                    CountLinks += 1;
            }
        }




        // returns the index of the flowchart atom that it connectes to. (or zero if none)
        // return to what other FlowChart it connect to (either /use or /path)
        long PathConnectes2(string Connectes2, long IndexFlowChart1)
        {
            long IndexFlowChart, IndexNamed, IndexSymbol, MyTopOfFile, X1, Y1;
            MyPointStructure Temp;

            if (InvalidIndex(IndexFlowChart1, FlowChart_FilePathSymbolName) == true)
                return constantMyErrorCode;
            for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
            {
                if (IndexFlowChart == IndexFlowChart1)
                    // We do not check our selfs
                    ainfo2(29);
                else
                    switch ((FlowChart_TableCode(IndexFlowChart)))
                    {
                    case "/use":
                    {
                        if (Connectes2 == "/path")
                        {
                            IndexNamed = GetSelfCorrectingIndexes(FlowChart_TableSymbol_Name(IndexFlowChart)); // make sure the Indexes is updated
                                                                                                               // This is not finding the name ERROR
                                                                                                               // IndexNamed = FindIndexIniSAMTable("named", "Do Not Add", Named_FileSymbolName, Named_FileSymbolName_iSAM, FlowChart_TablePathName(IndexFlowChart )) ' Find the name then
                            if (IndexNamed > 0)
                            {
                                IndexSymbol = Named_TableSymbolIndexes(IndexNamed); // Get the shortcut to the start of the name
                                if (IndexSymbol > 0)
                                {
                                    IndexSymbol += 1; // move over the name
                                    MyTopOfFile = TopOfFile("Symbol"); // For the last symbol in the list
                                    while (Symbol_TableCoded_String(IndexSymbol) != "/name" & IndexSymbol <= MyTopOfFile)
                                    {
                                        switch (Symbol_TableCoded_String(IndexSymbol))
                                        {
                                        case "/point":
                                        {
                                            // bug in bug, myshowsymbol has to have a /name to work.
                                            ainfo2(31);
                                            Temp = MyRotated(IndexSymbol, IndexFlowChart);
                                            X1 = FlowChart_TableX1(IndexFlowChart) + Temp.Xx; // Symbol_TableX1(IndexSymbol)
                                            Y1 = FlowChart_TableY1(IndexFlowChart) + Temp.Yy; // Symbol_TableY1(IndexSymbol)
                                            Temp = DistanceBetweenTwoPoints(FlowChart_TableX1(IndexFlowChart1), FlowChart_TableY1(IndexFlowChart1), X1, Y1);
                                            if (Temp.Xx == 0 & Temp.Yy == 0)
                                            {
                                                AInfo1(778, "This Point connected to this Path A ", MyShowNamed(IndexNamed), MyShowFlowChartRecord(IndexFlowChart));
                                                return IndexFlowChart1;
                                            }
                                            Temp = DistanceBetweenTwoPoints(FlowChart_TableX2(IndexFlowChart1), FlowChart_TableY2(IndexFlowChart1), X1, Y1);
                                            if (Temp.Xx == 0 & Temp.Yy == 0)
                                            {
                                                AInfo1(779, "This Point connected to this Path B ", MyShowNamed(IndexNamed), MyShowFlowChartRecord(IndexFlowChart));
                                                return IndexFlowChart1;
                                            }

                                            break;
                                        }

                                        case null:
                                        {
                                            break;// Must be at the end of the list (last symbol)
                                            break;
                                        }

                                        case "/unknown" // ignore 
                                            :
                                        {
                                            AInfo1(781, "Ignoreing unknown code", MyShowSymbolGraphic(IndexFlowChart1), Symbol_TableCoded_String(IndexFlowChart1));
                                            break;
                                        }

                                        case "/line" // ignore lines
                                            :
                                        {
                                            break;
                                        }

                                        default:
                                        {
                                            AInfo(645, "Should have programmed for ", Symbol_TableCoded_String(IndexSymbol), IndexSymbol);
                                            break;
                                            break;
                                        }
                                        }
                                        IndexSymbol += 1; // Try next
                                    }
                                }
                            }
                            else if (FlowChart_TableCode(IndexFlowChart1) != "/path")
                                AInfo(646, "Symbol not in short cut", MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(IndexFlowChart1));
                        }

                        break;
                    }

                    case "/path":
                    {
                        if (Connectes2 == "/path")
                        {
                            // Check Points
                            Temp = DistanceBetweenTwoPaths(IndexFlowChart1, IndexFlowChart);
                            if (Temp.Xx != 0 | Temp.Yy != 0)
                            {
                            }
                            else
                            {
                                // AInfo(839, "    Connected " & MyShowPoint(Temp), MyShowFlowChartRecord(IndexFlowChart1), MyShowFlowChartRecord(IndexFlowChart))
                                if (FlowChart_TablePath_Name(IndexFlowChart1) != FlowChart_TablePath_Name(IndexFlowChart))
                                {
                                    // FindingMyBUgXY(IndexFlowChart1)
                                    // FindingMyBUgXY(IndexFlowChart)
                                    MakeErrorAt(FlowChartScreen.PictureBox1, MyPoint1XY(FlowChart_TableX1(IndexFlowChart), FlowChart_TableY1(IndexFlowChart)), MyErrorList[1024 - 1001] + FlowChart_TablePath_Name(IndexFlowChart1));
                                    Abug(678, "Two paths with different names are connecter", MyShowFlowChartRecord(IndexFlowChart), MyShowFlowChartRecord(IndexFlowChart1));
                                }
                                // ainfo2(33)
                                return IndexFlowChart;
                            }
                        }

                        break;
                    }

                    case "/error"// ignore
                        :
                    {
                        break;
                    }

                    case "/origin" // ignore
                        :
                    {
                        break;
                    }

                    case "/unknown":
                    {
                        break;
                    }

                    default:
                    {
                        Abug(347, "code not taken care of ", MyShowFlowChartRecord(IndexFlowChart1), "");
                        break;
                    }
                    }
            }
            return 0; // not connected anywhere
        }




        // MyCheckIndexs(IndexFlowChart , IndexSymbol, IndexNamed, indexcolor, indexdatatype)
        void MyCheckIndexs(long IndexFlowChart, long IndexSymbol, long IndexNamed, long IndexColor, long IndexDataType)
        {
            if (IndexSymbol > TopOfFile("Symbol"))
                MyMsgCtr(1433, "MyCheckIndexs 2", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");

            if (IndexNamed > TopOfFile("named"))
                MyMsgCtr(1433, "MyCheckIndexs 3", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");


            if (IndexColor > TopOfFile("Color"))
                MyMsgCtr(1433, "MyCheckIndexs 4", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");

            if (IndexDataType > TopOfFile("DataType"))
                MyMsgCtr(1433, "MyCheckIndexs 5", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");
            if (IndexFlowChart > TopOfFile("FlowChart"))
                MyMsgCtr(1433, "MyCheckIndexs 1", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");

            // Also Check these
            if (FlowChart_iSAM_X1[IndexFlowChart] > TopOfFile("FlowChart"))
                MyMsgCtr(1433, "MyCheckIndexs 1", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");
            if (FlowChart_iSAM_Y1[IndexFlowChart] > TopOfFile("FlowChart"))
                MyMsgCtr(1433, "MyCheckIndexs 1", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");
            if (FlowChart_iSAM_X2[IndexFlowChart] > TopOfFile("FlowChart"))
                MyMsgCtr(1433, "MyCheckIndexs 1", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");
            if (FlowChart_iSAM_Y2[IndexFlowChart] > TopOfFile("FlowChart"))
                MyMsgCtr(1433, "MyCheckIndexs 1", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");
            if (FlowChart_iSAM_Name[IndexFlowChart] > TopOfFile("FlowChart"))
                MyMsgCtr(1433, "MyCheckIndexs 1", IndexFlowChart + " : " + TopOfFile("FlowChart") + Constants.vbCrLf, IndexSymbol + " : " + TopOfFile("Symbol") + Constants.vbCrLf, IndexNamed + " : " + TopOfFile("named") + Constants.vbCrLf, IndexColor + " : " + TopOfFile("Color") + Constants.vbCrLf, IndexDataType + " : " + TopOfFile("DataType") + Constants.vbCrLf, "", "", "", "");
        }




        void MyDoEvents()
        {
            // todo there is a direct call to do events burried inside some system... or my.computer... or forms...
            // Application.DoEvents()
            System.Windows.Forms.Application.DoEvents();
        }



        void MySortHints()
        {
            long I, Flag;
            string Temp;
            // todo bug, it does not trickle the list down if there is a blank made from deleting the hint number
            do
            {
                Flag = 0;
                for (I = 0; I <= Information.UBound(MyUniverse.MyStaticData.Hints) - 1; I++)
                {
                    if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I]) == "_" & PrintAbleNull(MyUniverse.MyStaticData.Hints[I + 1]) == "_")
                        break;
                    if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I]) == "_" & PrintAbleNull(MyUniverse.MyStaticData.Hints[I + 1]) != "_")
                    {
                        Temp = MyUniverse.MyStaticData.Hints[I];
                        MyUniverse.MyStaticData.Hints[I] = MyUniverse.MyStaticData.Hints[I + 1];
                        MyUniverse.MyStaticData.Hints[I + 1] = Temp;
                        Flag += 1;
                    }
                }
            } while (Flag != 0);
            do
            {
                Flag = 0;
                for (I = 0; I <= Information.UBound(MyUniverse.MyStaticData.Hints) - 1; I++)
                {
                    if (FlowChartScreen.Visible == true)
                    {
                        if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I]) == "_")
                            break;
                        else
                            // ignore it if it is a blank
                            if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I + 1]) == "_")
                                break;
                            else if (MyUniverse.MyStaticData.Hints[I] < MyUniverse.MyStaticData.Hints[I + 1])
                            {
                                Temp = MyUniverse.MyStaticData.Hints[I];
                                MyUniverse.MyStaticData.Hints[I] = MyUniverse.MyStaticData.Hints[I + 1];
                                MyUniverse.MyStaticData.Hints[I + 1] = Temp;
                                Flag += 1;
                            }
                    }
                    else if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I]) == "_")
                        break;
                    else
                        // ignore it if it is a blank
                        if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I + 1]) == "_")
                            break;
                        else if (MyUniverse.MyStaticData.Hints[I] > MyUniverse.MyStaticData.Hints[I + 1])
                        {
                            // Temp = MyUniverse.MyStaticData.Hints(I + 1)
                            Temp = MyUniverse.MyStaticData.Hints[I];
                            MyUniverse.MyStaticData.Hints[I] = MyUniverse.MyStaticData.Hints[I + 1];
                            MyUniverse.MyStaticData.Hints[I + 1] = Temp;
                            Flag += 1;
                        }
                }
            } while (Flag != 0);
        }


        // This is to show the last 10 hints (ie something wrong, and needs to be changed.
        long AHint(long MyBugNumber, string ScreenName, string A, string B, string C)
        {
            // todo need to change this so that it takes hints out when the conditions are men (with negitive bug number ie: no longer a bug/info/hint)
            // need to display the status when a hint  is deleted.
            const  string Seperator = ":::";
            var oldMyUniverse.MyStaticData.Hints = MyUniverse.MyStaticData.Hints;
            MyUniverse.MyStaticData.Hints = new string[11];
            if (oldMyUniverse.MyStaticData.Hints != null)
                Array.Copy(oldMyUniverse.MyStaticData.Hints, MyUniverse.MyStaticData.Hints, Math.Min(11, oldMyUniverse.MyStaticData.Hints.Length));
            long I, Flag;
            MyDoEvents();
            AHint = 0; // Where all of the errors are added from here

            // First make sure that this is not already there (and deelte it if it not suppose to be
            // see if it is already there
            for (I = 0; I <= 10; I++)
            {
                if (MyBugNumber > 0)
                {
                    if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I]) == "_")
                        break;
                    if (MyUniverse.MyStaticData.Hints[I] == MyBugNumber.ToString() + Seperator + HighLight(A) + HighLight(B) + HighLight(C))
                    {
                        DisplayMyStatus(MyUniverse.MyStaticData.Hints[0]);
                        return;
                    }
                }
                else if (Strings.InStr(MyUniverse.MyStaticData.Hints[I], System.Convert.ToString(-MyBugNumber) + Seperator) != 0)
                {
                    MyUniverse.MyStaticData.Hints[I] = ""; // Delete This hint, as it is no longer valid
                    MySortHints();
                    // todo only display the hint (for now) needs to change
                    DisplayMyStatus(MyUniverse.MyStaticData.Hints[0]);
                    // DisplayMyStatus(MyUniverse.MyStaticData.Hints(0))
                    break;
                }
            }

            // next we move everthing to fill it from zero to the end
            Flag = 1;
            while (Flag != 0)
            {
                Flag = 0;
                for (I = 0; I <= 9; I++)
                {
                    // todo this needs to be change to move from the (one) up till the last, OR AN EMPTY IS FILLED
                    if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I]) == "_")
                    {
                        if (PrintAbleNull(MyUniverse.MyStaticData.Hints[I + 1]) != "_")
                        {
                            MyUniverse.MyStaticData.Hints[I] = MyUniverse.MyStaticData.Hints[I + 1];
                            MyUniverse.MyStaticData.Hints[I + 1] = null;
                            Flag += 1; // untill we do not move any more.
                        }
                    }
                }
            }

            if (MyBugNumber < 0)
                return;
            // next move everything up if you can 
            for (I = 10; I >= 1; I += -1)
                MyUniverse.MyStaticData.Hints[I] = MyUniverse.MyStaticData.Hints[I - 1];

            // last we add this hint to the first spot (And move every thing else up out of the way.
            MyUniverse.MyStaticData.Hints[0] = MyBugNumber.ToString() + Seperator + HighLight(A) + HighLight(B) + HighLight(C);
            // Dump3(35, "Hint: Added " & MyUniverse.MyStaticData.Hints(0))
            // MyDoEvents()
            MySortHints();
        }

        void ainfo2(long I)
        {
            System.Diagnostics.Debug.Write("{" + I.ToString() + ")" + CountStack());
        }

        void AInfo0(long MyBugNumber, object AA, object BB, object CC)
        {
            string A, B, C;
            if (Information.IsNothing(AA))
                A = "(nil)";
            else
                A = Constants.vbTab + AA.ToString();
            if (Information.IsNothing(BB))
                B = "(nil)";
            else
                B = Constants.vbTab + BB.ToString();
            if (Information.IsNothing(CC))
                C = "(nil)";
            else
                C = Constants.vbTab + CC.ToString();
            if (MyOptionTest(26) == false)
                System.Diagnostics.Debug.Write(Constants.vbCrLf + Constants.vbCrLf + DateTime.Now() + Constants.vbTab + CountStack() + Constants.vbTab + "Info0 " + MyBugNumber.ToString() + Constants.vbCrLf + " =a>" + A + Constants.vbCrLf + " =b>" + B + Constants.vbCrLf + " =c>" + C);
            Dump3(30, Constants.vbCrLf + DateTime.Now() + Constants.vbTab + CountStack() + Constants.vbTab + "Info0: #" + Constants.vbTab + MyBugNumber.ToString() + Constants.vbTab + A + Constants.vbTab + B + Constants.vbTab + C + ".");
        }


        void AInfo1(long MyBugNumber, object AA, object BB, object CC)
        {
            string A, B, C;
            if (Information.IsNothing(AA))
                A = "(nil)";
            else
                A = Constants.vbTab + AA.ToString();
            if (Information.IsNothing(BB))
                B = "(nil)";
            else
                B = Constants.vbTab + BB.ToString();
            if (Information.IsNothing(CC))
                C = "(nil)";
            else
                C = Constants.vbTab + CC.ToString();
            if (MyOptionTest(26) == false)
                System.Diagnostics.Debug.Write(Constants.vbCrLf + DateTime.Now() + Constants.vbTab + CountStack() + RemoveTheseLetters(" ------->Info1:" + MyBugNumber.ToString() + " =a>" + A + " =b>" + B + " =c>" + C, Constants.vbCrLf + Constants.vbTab + Constants.vbFormFeed + Constants.vbVerticalTab));
            Dump3(30, Constants.vbCrLf + "Info1: #" + MyBugNumber.ToString() + Constants.vbTab + CountStack() + Constants.vbTab + Constants.vbTab + A + Constants.vbTab + B + Constants.vbTab + C + ".");
        }

        long AInfo(long MyBugNumber, object AA, object BB, object CC)
        {
            string A, B, C;
            // todo make sure that the bug number is in the range of bug numbers.
            MyDoEvents();
            if (Information.IsNothing(AA))
                A = "(nil)";
            else
                A = AA.ToString();
            if (Information.IsNothing(BB))
                B = "(nil)";
            else
                B = BB.ToString();
            if (Information.IsNothing(CC))
                C = "(nil)";
            else
                C = CC.ToString();
            AInfo = 0; // Where all of the errors are added from here
            if (MyOptionTest(26) == false)
                System.Diagnostics.Debug.Write(Constants.vbCrLf + DateTime.Now() + Constants.vbTab + CountStack() + " --->Info:" + MyBugNumber.ToString() + Constants.vbCrLf + "===a>" + A + Constants.vbCrLf + "===b>" + B + Constants.vbCrLf + "===c>" + C);
            MyDoEvents();
            Dump3(31, Constants.vbCrLf + "Info: #" + MyBugNumber.ToString() + Constants.vbTab + CountStack() + Constants.vbCrLf + Constants.vbCrLf + A + Constants.vbCrLf + B + Constants.vbCrLf + C + ".");
        }
        // ****************************************
        // highest info or bug number is 
        // ****************************************
        long Abug(long MyBugNumber, object AA, object BB, object CC)
        {
            string A, B, C;
            MyPointStructure Location;
            Location = default(MyPointStructure);
            Abug = 1; // Where all of the errors are added from here
            MyUniverse.MyCheatSheet.BugsCounted += 1;
            if (Information.IsNothing(AA))
                A = " (nil) ";
            else
                A = AA.ToString();
            if (Information.IsNothing(BB))
                B = " (nil) ";
            else
                B = BB.ToString();
            if (Information.IsNothing(CC))
                C = " (nil) ";
            else
                C = CC.ToString();

            // hack cause I want to watch memory

            MyDoEvents();
            if (IsBitSet(MyBugNumber) == true)
            {
                Location.Xx = 50;
                Location.Yy = 50;
                Windows.Forms.Help.ShowPopup(FlowChartScreen.PictureBox1, "Help on " + MyBugNumber, ConvertPoint2MyPointStruct(Location));
                Windows.Forms.Help.ShowPopup(SymbolScreen.PictureBox1, "Help on " + MyBugNumber, ConvertPoint2MyPointStruct(Location));
                switch (Interaction.MsgBox(Constants.vbCrLf + DateTime.Now() + "====> Bug:" + MyBugNumber.ToString() + Constants.vbTab + CountStack() + Constants.vbCrLf + "===a>" + A + Constants.vbCrLf + "===b>" + B + Constants.vbCrLf + "===c>" + C + Constants.vbCrLf, MsgBoxStyle.YesNoCancel, "Yes =Display Help / No = continue / Cancel to ignore this message"))
                {
                case MsgBoxResult.Yes:
                {
                    if (FlowChartScreen.Visible == true)
                    {
                    }
                    else if (SymbolScreen.Visible == true)
                        Windows.Forms.Help.ShowHelp(SymbolScreen, MyUniverse.ProgramOptions.Helpurl, HelpNavigator.Find, MyBugNumber.ToString());
                    break;
                }

                case MsgBoxResult.Cancel:
                {
                    if (MyBugNumber > 1 & MyBugNumber <= 998)
                        BitSet(MyBugNumber, "off");
                    break;
                }

                case MsgBoxResult.No:
                {
                    break;
                }
                }
            }

            if (MyOptionTest(26) == false)
                System.Diagnostics.Debug.Write(Constants.vbCrLf + DateTime.Now() + Constants.vbTab + CountStack() + Constants.vbCrLf + "===a>" + C + Constants.vbCrLf + "===b>" + B + Constants.vbCrLf + "===c>" + A + Constants.vbCrLf + " =====> Bug:" + MyBugNumber.ToString());
            Dump3(29, "Bug:" + MyBugNumber.ToString() + Constants.vbCrLf + A + Constants.vbCrLf + B + Constants.vbCrLf + C + ".");
        }

        // *********************************************************************************
        // Part of finding internal bugs that I think should never happen (See FindingMyBugs)
        long FindingSymbolOutOfXYSizeBugs(long Idex) // Checks symbol record Idex if it is more then the allowed size. (if /point or /line)
        {
            long NumberOfNames, NumberOfPoints, NumberOfLines;

            FindingSymbolOutOfXYSizeBugs = 0;
            return;

            NumberOfNames = 0;
            NumberOfPoints = 0;
            NumberOfLines = 0;
            switch (Symbol_TableCoded_String(Idex))
            {
            case "/name":
            {
                NumberOfNames += 1;
                break;
            }

            case "/line":
            {
                if (MyABS(Symbol_FileX1[Idex]) > MyUniverse.SysGen.Constants.constantSymbolCenter)
                    FindingSymbolOutOfXYSizeBugs += Abug(351, "FindingMyBugs: The x1 line symbol is out of bounds at ", Idex, Symbol_FileX1[Idex]);
                if (MyABS(Symbol_FileY1[Idex]) > MyUniverse.SysGen.Constants.constantSymbolCenter)
                    FindingSymbolOutOfXYSizeBugs += Abug(352, "FindingMyBugs: The y1 line symbol is out of bounds at ", Idex, Symbol_FileY1[Idex]);
                if (MyABS(Symbol_FileX2_io[Idex]) > MyUniverse.SysGen.Constants.constantSymbolCenter)
                    FindingSymbolOutOfXYSizeBugs += Abug(353, "FindingMyBugs: The x2 line symbol is out of bounds at ", Idex, Symbol_FileX2_io[Idex]);
                if (MyABS(Symbol_FileY2_dt[Idex]) > MyUniverse.SysGen.Constants.constantSymbolCenter)
                    FindingSymbolOutOfXYSizeBugs += Abug(354, "FindingMyBugs: The y2 line symbol is out of bounds at ", Idex, Symbol_FileY2_dt[Idex]);
                NumberOfLines += 1;
                break;
            }

            case "/point":
            {
                if (MyABS(Symbol_FileX1[Idex]) > MyUniverse.SysGen.Constants.constantSymbolCenter)
                    FindingSymbolOutOfXYSizeBugs += Abug(355, "FindingMyBugs: The x1 point symbol is out of bounds at ", Idex, Symbol_FileX1[Idex]);
                if (MyABS(Symbol_FileY1[Idex]) > MyUniverse.SysGen.Constants.constantSymbolCenter)
                    FindingSymbolOutOfXYSizeBugs += Abug(356, "FindingMyBugs: The y1 point symbol is out of bounds at ", Idex, Symbol_FileY1[Idex]);
                NumberOfPoints += 1;
                break;
            }

            case "/unknown":
            {
                AInfo1(762, "Ignoreing unknown code", MyShowSymbolGraphic(Idex), Symbol_TableCoded_String(Idex));
                break;
            }

            default:
            {
                FindingSymbolOutOfXYSizeBugs += Abug(357, "FindingMyBugs: Invalid code inthe symbol table", Symbol_TableCoded_String(Idex), Symbol_TableCoded_String(Idex));
                break;
            }
            }
        }
        bool MyOptionTest(long WhatOption)
        {
            if (OptionScreen.CheckedListBoxOptionSelection.Items.Count < WhatOption)
                return false;
            return OptionScreen.CheckedListBoxOptionSelection.GetItemChecked(WhatOption);
        }
        void Dump3(long DebugLevel, string ErrorMessage) // Dump every possible issues to a saved fdile 
        {
            if (MyFlowChartNameSpace.F_C.ProgramAlive == true)
            {
                if (MyOptionTest(30) == true)
                    System.IO.File.AppendAllText(MyUniverse.MySystem.Dumps.OutputFileName3, Constants.vbCrLf + ShortHighLight(DebugLevel.ToString()) + " " + DateTime.Now() + " " + ErrorMessage); // & My.Application.Info.StackTrace)
                else
                    System.Diagnostics.Debug.Write(Constants.vbCrLf + DateTime.Now() + Constants.vbTab + DateTime.Now + HighLight(ErrorMessage));
            }
        }

        void Dump1() // Dumping only the symbol table for debuging ' extra
        {
            long Idex;
            string Output;
            long MyWriter;
            if (FileSystem.Dir(MyUniverse.MySystem.Dumps.OutputFileName1) != "")
                FileSystem.Kill(MyUniverse.MySystem.Dumps.OutputFileName1);
            // Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyUniverse.MySystem.Dumps.OutputFileName1)
            MyWriter = FileSystem.FreeFile();
            FileSystem.FileOpen(MyWriter, MyUniverse.MySystem.Dumps.OutputFileName1, OpenMode.Output, OpenAccess.Write, OpenShare.LockReadWrite, -1);
            // End Using
            // Else
            // Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyUniverse.MySystem.Dumps.OutputFileName1)
            // End Using
            // End If

            // Using Writer As System.IO.FileStream = System.IO.File.OpenWrite(MyUniverse.MySystem.Dumps.OutputFileName1)
            for (Idex = 1; Idex <= NewTopOfFile("Symbol"); Idex++)
            {
                Output = MyShowSymbolGraphic(Idex);
                FileSystem.WriteLine(MyWriter, Output);
            }

            FileSystem.FileClose(MyWriter);
        }


        // ***********************************************
        // todo need to add the button rules here
        // This is to clear the message text 
        bool ButtonStarted(string ButtonName) // Make sure that no more than X number of buttons deep (or stack over flow)
        {
            long DebugTemp;
            DebugTemp = MyUniverse.SysGen.NumberOfButtonsActive;

            if (MyUniverse.SysGen.NumberOfButtonsActive > 8)
                // todo turn off all button rules
                return false;// can not do any more buttons

            MyUniverse.SysGen.NumberOfButtonsActive += 1;
            return true;
        }

        bool ButtonFinished(string ButtonName)  // Make sure that no more than X number of buttons deep (or stack over flow)
        {
            long DebugTemp;
            MyUniverse.SysGen.NumberOfButtonsActive -= 1;
            DebugTemp = MyUniverse.SysGen.NumberOfButtonsActive;
            if (MyUniverse.SysGen.NumberOfButtonsActive < 0)
                // todo needs to add to the dump the button list of buttons currently active.
                Interaction.MsgBox("Program data error Button pushes counted wrongly needs to report what report", MsgBoxStyle.OkOnly);
            // reset all button rules if all turned off
            // MyButtonsEnableRules()
            return true; // toto for now All finished buttons worked and stopped
        }

        void ClearSymbolDisplay()
        {
            MyUniverse.ProgramOptions.SymbolChanged = false; // Nothing has change from nothing
            SymbolScreen.TextBoxNamedSymbolName.Text = "";
            // SymbolScreen.TextBoxNamedDescription.Text = ""
            SymbolScreen.TextBoxNamedNameOfFile.Text = "";
            SymbolScreen.TextBoxNamedNotes.Text = "";
            SymbolScreen.TextBoxNamedOpCode.Text = "";
            SymbolScreen.TextBoxNamedStroke.Text = "";
            SymbolScreen.TextBoxNamedSyntax.Text = "";
            SymbolScreen.TextBoxNamedProgramText.Text = "";
            SymbolScreen.TextBoxSymbolVersionAuthor.Text = "";
        }

        void DisplaySymbolText(string SymbolName)
        {
            long IndexNamed, IndexSymbol;
            IndexNamed = FindIndexIniSAMTable("Named", "DoNotAdd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            if (IndexNamed == constantMyErrorCode)
            {
                Abug(358, "Did not find symbol name " + HighLight(SymbolName), "", "");
                ClearSymbolDisplay();
            }
            FindingMyBugs(100);
            IndexSymbol = GetSelfCorrectingIndexes(SymbolName);
            if (IndexSymbol == constantMyErrorCode)
            {
                Abug(359, "There is no symbol graphics", "", "");
                ClearSymbolDisplay();
            }
            if (Named_TableSymbolName(IndexNamed) != SymbolName)
                Abug(361, "Looking for symbol NameOf " + HighLight(SymbolName), "Error Integer finding the symname ", Named_TableSymbolName(IndexNamed));

            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedSymbolName.Text = Named_TableSymbolName(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedNameOfFile.Text = Named_TableNameofFile(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedNotes.Text = Named_TableNotes(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedOpCode.Text = Named_TableOpCode(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedStroke.Text = Named_TableStroke(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedSyntax.Text = Named_TableSintax(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxNamedProgramText.Text = Named_TableMicroCodeText(IndexNamed);
            FindingMyBugs(100);
            SymbolScreen.TextBoxSymbolVersionAuthor.Text = Named_TableAuthor(IndexNamed);
            FindingMyBugs(100);
            // todo need to check that the name is matching.
            IndexSymbol += 1; // jump after the name
            SymbolScreen.ComboBoxLineNameList.Items.Clear();
            SymbolScreen.ComboBoxPointNameList.Items.Clear();
            while (Symbol_TableCoded_String(IndexSymbol) != "/Name" & IndexSymbol < TopOfFile("Symbol"))
            {
                FindingMyBugs(100);
                switch (Symbol_TableCoded_String(IndexSymbol))
                {
                case "/Name":
                {
                    return;
                }

                case "/point" // Add to point list
                    :
                {
                    FixSinTaxCode(IndexNamed);
                    SymbolScreen.ComboBoxPointNameList.Items.Add(Symbol_Table_NameOfPoint(IndexSymbol));
                    FindingMyBugs(100);
                    break;
                }

                case "/line" // Add to line list
                    :
                {
                    SymbolScreen.ComboBoxLineNameList.Items.Add(Symbol_Table_NameOfPoint(IndexSymbol));
                    FindingMyBugs(100);
                    break;
                }
                }
                IndexSymbol += 1;
                FindingMyBugs(100);
            }
            FindingMyBugs(100);
        }


        void DisplayStatus(string StatusBox, string Status_Message)
        {
            string Temp;
            if (Information.IsNothing(MyUniverse.MyStaticData.Hints))
                return;

            Temp = SplashScreen.LabelExpireDate.Text + " " + MyUniverse.MyStaticData.Hints[0] + Status_Message;
            if (Information.IsNothing(MyUniverse.MyStaticData.Hints[0]))
            {
                if (StatusBox == Temp)
                    return;
                StatusBox = Temp;
            }
            else
            {
                if (StatusBox == Temp)
                    return;
                StatusBox = Temp;
            }
            MyDoEvents();
        }
        void DisplayStatusOnly(string StatusBox, string StatusMessage)
        {
            StatusBox = StatusMessage;
            MyDoEvents();
        }


        // If the passed index is zero, then those function can not/are not checked
        void FindingMyBugsCheckForErrors(long IndexFlowChart, long IndexNamed, long IndexSymbol) // Checks for common errors
        {
            long BitFlag, Bdex, Cdex;
            long I, J, K;
            string DataType, PointName, SinTax;
            MyPointStructure MyXY = default(MyPointStructure);
            string[] MyArray = new string[257];
            if (MyOptionTest(31) == false)
                return;

            BitFlag = 0;
            Bdex = 0;
            // Cdex = 0

            if (IndexSymbol > 1)
            {
                Cdex = IndexSymbol;
                while (Cdex > 0 & Symbol_TableCoded_String(Cdex) != "/name")
                    Cdex -= 1;// back up to the nead of the symbol
                // Check that the symbol is is the named_ name
                if (IndexNamed > 0)
                {
                    if (Strings.Len(Named_TableSymbolName(IndexNamed)) != 0 & Strings.Len(Symbol_TableSymbolName(Cdex)) != 0)
                    {
                        if (Named_TableSymbolName(IndexNamed) != Symbol_TableSymbolName(Cdex))
                        {
                            Abug(362, "Named and Symbol indexs are messed up ", Named_TableSymbolName(IndexNamed), Symbol_TableSymbolName(Cdex));
                            Bdex = IndexNamed;
                        }
                    }
                }
                Cdex += 1; // move off of the name
                while (Cdex < TopOfFile("Symbol") & Symbol_TableCoded_String(Cdex) != "/name")
                {
                    if (Symbol_TableCoded_String(Cdex) == "/point")
                    {
                        if (Symbol_Table_NameOfPoint(Cdex) == MyUniverse.SysGen.Constants.ConstantCameFromLine)
                            BitFlag = BitFlag & 2;
                        if (Symbol_Table_NameOfPoint(Cdex) == MyUniverse.SysGen.Constants.ConstantGotoNextLine)
                            BitFlag = BitFlag & 4;
                        // 1010 All Points have a valid Datatype
                        J = Symbol_TableY2(Cdex);
                        // DataType = MyUnEnum(J, SymbolScreen.ToolStripDropDownButtonPointDataType, 0)

                        DataType = DataType_FileName[J];

                        I = FindIndexIniSAMTable("Datatype", "Donotadd", ref DataType_FileName, ref DataType_Name_iSAM, DataType);
                        if (I == constantMyErrorCode)
                        {
                            Abug(363, "Invalid Datatype in Symbol ", DataType, J);
                            MyFlowChartErrors(1010, 0, 0, IndexSymbol, " Symbol " + FindSymbolName(IndexSymbol));
                        }
                        else if (I >= 0)
                        {
                            J = FindIndexIniSAMTable("Color", "Donotadd", ref Color_FileName, ref Color_Name_iSAM, DataType_Color(I));
                            if (J == constantMyErrorCode)
                            {
                                Abug(364, "invalid Color for Datatype ", DataType, DataType_Color(I));
                                MyFlowChartErrors(1011, 0, 0, IndexSymbol, " DataType " + DataType);
                            }
                        }
                        // todo not tested for yet
                        // 1012 All Colors are valid (in microsoft, they can only be the assigned colors, and are 'switched if wrong) ?

                        // 1013 All /point names are in either the microcodetext or the Syntax
                        PointName = Symbol_Table_NameOfPoint(Cdex);

                        // todo We need a better check for what this should be checking 2020 09 13
                        switch (ThisIsAWhat(Symbol_Table_NameOfPoint(Cdex)))
                        {
                        case "variable":
                        {
                            if (Strings.InStr(Named_TableSintax(IndexNamed), MyUniverse.SysGen.Constants.RMStart + NameOfPointOnly(Symbol_Table_NameOfPoint(Cdex)) + ".") == 0)
                            {
                                AInfo(647, " Variable " + MyUniverse.SysGen.Constants.RMStart + Symbol_Table_NameOfPoint(Cdex) + "." + " Not found in program code text ", Named_TableSintax(IndexNamed), MyUniverse.SysGen.Constants.RMStart + NameOfPointOnly(Symbol_Table_NameOfPoint(Cdex)) + ".");
                                MyFlowChartErrors(1013, 0, 0, Cdex, " Symbol " + FindSymbolName(IndexSymbol));
                                Named_TableMicroCodeText(IndexNamed, Named_TableMicroCodeText(IndexNamed) + Constants.vbCrLf + MyUniverse.ProgramOptions.C_L_MultiLine + " " + MyUniverse.SysGen.Constants.RMStart + Symbol_Table_NameOfPoint(Cdex) + ".pathname" + MyUniverse.SysGen.Constants.RMEnd);
                            }

                            break;
                        }

                        case object _ when MyUniverse.SysGen.Constants.ConstantGotoNextLine:
                        {
                            break;
                        }

                        case object _ when MyUniverse.SysGen.Constants.ConstantCameFromLine:
                        {
                            break;
                        }

                        case "Quote":
                        {
                            break;
                        }

                        case "Comment":
                        {
                            break;
                        }

                        case "KeyWord":
                        {
                            break;
                        }

                        case "Function":
                        {
                            break;
                        }

                        case "Operator":
                        {
                            break;
                        }

                        case "Number":
                        {
                            break;
                        }

                        case "Alpha":
                        {
                            break;
                        }

                        case "C_L_MultiLine":
                        {
                            break;
                        }

                        case "C_L_Comment":
                        {
                            break;
                        }

                        case "C_L_Extention":
                        {
                            break;
                        }

                        case "C_L_VarChars":
                        {
                            break;
                        }

                        case "SpecialCharacter":
                        {
                            break;
                        }

                        case "Unknown":
                        {
                            break;
                        }

                        default:
                        {
                            if (Strings.InStr(PointName, MyUniverse.SysGen.Constants.ConstantCameFromLine) != 0)
                                // If PointName = "{[(CameFromLine)]}_CameFromLine" Then
                                AInfo1(680, "This is a GotoNextLine line marker  ", Symbol_Table_NameOfPoint(Cdex), PointName);
                            else if (Strings.InStr(PointName, MyUniverse.SysGen.Constants.ConstantGotoNextLine) != 0)
                            {
                            }
                            else if (ThisIsAMarker2(Symbol_Table_NameOfPoint(Cdex)) != "")
                                AInfo1(681, "This is a variable name ", Symbol_Table_NameOfPoint(Cdex), "");
                            else
                                Abug(365, " This is not a variable name", Symbol_Table_NameOfPoint(Cdex), HighLight(ThisIsAWhat(Symbol_Table_NameOfPoint(Cdex))));
                            break;
                        }
                        }
                    }
                    Cdex += 1;
                } // looping through the symbol

                switch (BitFlag)
                {
                    case 0 // No CameFromLine or Goto
                        :
                    {
                        MyFlowChartErrors(1001, 0, Bdex, Cdex, " Symbol " + FindSymbolName(IndexSymbol)); // Error 1001 no CameFromLine or goto
                        MyFlowChartErrors(1002, 0, Bdex, Cdex, " Symbol " + FindSymbolName(IndexSymbol)); // Error 1001 no CameFromLine or goto
                        break;
                    }

                    case 2:
                    {
                        // 1002 Symbol does not have a /point GotoNextLine
                        MyFlowChartErrors(1002, 0, Bdex, Cdex, " Symbol " + FindSymbolName(IndexSymbol));
                        break;
                    }

                    case 4:
                    {
                        // 1001 Symbol does not have a /point CameFromLine
                        MyFlowChartErrors(1001, 0, Bdex, Cdex, " Symbol " + FindSymbolName(IndexSymbol));
                        break;
                    }

                    case 6 // It has them both so this error is ok
                        :
                    {
                        break;
                    }
                } // checking if the symbol has CameFromLine and a GotoNextLine
                // 1014 No Duplicate /point names

                // Check for the named possible errors
                if (IndexNamed > 0)
                {
                    // 1006 That all of the point names are in the syntax
                    if (Named_TableSintax(IndexNamed) == "")
                    {
                        Abug(366, "empty syntax", IndexNamed, 0);
                        if (Named_TableMicroCodeText(IndexNamed) != "")
                        {
                            PathNames = MyParse(ref MyArray, Named_TableMicroCodeText(IndexNamed));
                            SinTax = MakeStatementSintax(MyArray);
                        }
                        MyFlowChartErrors(1006, IndexFlowChart, IndexNamed, IndexSymbol, " Symbol " + FindSymbolName(IndexSymbol));
                    }
                }


                // Check Path
                if (IndexFlowChart > 0)
                {
                    // 1009 All paths must have at least one output or constant
                    switch (FlowChart_TableCode(IndexFlowChart))
                    {
                    case "/use":
                    {
                        MyXY.Xx = FlowChart_TableX1(IndexFlowChart);
                        MyXY.Yy = FlowChart_TableY1(IndexFlowChart);
                        K = MyFindSymbolPoint(MyXY, FlowChart_TableSymbol_Name(IndexFlowChart));
                        if (K == constantMyErrorCode)
                            Abug(367, "Unable to find the Path Name ", FlowChart_TableSymbol_Name(IndexFlowChart), MyShowPoint(MyXY));
                        break;
                    }

                    case "/path":
                    {
                        MyXY.Xx = FlowChart_TableX1(IndexFlowChart);
                        MyXY.Yy = FlowChart_TableY1(IndexFlowChart);
                        K = MyFindPoint(FlowChartScreen.PictureBox1, MyXY, IndexFlowChart);
                        if (K == constantMyErrorCode)
                            Abug(368, "Unable to find the symbol XY ", FlowChart_TablePath_Name(IndexFlowChart), MyShowPoint(MyXY));
                        break;
                    }

                    case "/constant":
                    {
                        break;
                    }

                    case "/error":
                    {
                        break;
                    }

                    default:
                    {
                        break;
                    }
                    }
                }
            }
        }


        void MyFlowChartErrors(long ErrNumber, long IndexFlowChart, long IndexNamed, long IndexSymbol, string ErrMsg)
        {
            MyPointStructure MyXY = default(MyPointStructure);
            string WhatDoIDoWithThis;
            // from the indexs tells where to put the error
            WhatDoIDoWithThis = MyMinMax(IndexFlowChart, 0, 1) + MyMinMax(IndexNamed, 0, 1) + MyMinMax(IndexSymbol, 0, 1);
            switch (WhatDoIDoWithThis)
            {
                case "000" // No Indexes, 
                    :
                {
                    MyXY.Xx = 0;
                    MyXY.Yy = 0;
                    MakeErrorAt(SymbolScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    MyXY.Xx = 1000;
                    MyXY.Yy = 1000;
                    MakeErrorAt(FlowChartScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }

                case "001" // Symbol Index Only (you must be on SymbolScreen)
                    :
                {
                    MyXY.Xx = Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = Symbol_TableY1(IndexSymbol);
                    break;
                }

                case "010" // Named Index Only (you must be on SymbolScreen)
                    :
                {
                    MyXY.Xx = Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = Symbol_TableY1(IndexSymbol);
                    MakeErrorAt(SymbolScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }

                case "011" // Named and Symbol Index (you must be on SymbolScreen)
                    :
                {
                    MyXY.Xx = Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = Symbol_TableY1(IndexSymbol);
                    MakeErrorAt(SymbolScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }

                case "100" // FlowChart index only (you must be on FlowChartScreen)
                    :
                {
                    MyXY.Xx = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol);
                    MakeErrorAt(FlowChartScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }

                case "101" // FlowChart and Symbol index (you must be on FlowChartScreen)
                    :
                {
                    MyXY.Xx = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol);
                    MakeErrorAt(FlowChartScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }

                case "110" // FlowChart and Named (you must be on FlowChartScreen)
                    :
                {
                    MyXY.Xx = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol);
                    MakeErrorAt(FlowChartScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }

                case "111" // FlowChart, Named, Symbol (you must be on FlowChartScreen)
                    :
                {
                    MyXY.Xx = FlowChart_TableX1(IndexFlowChart) + Symbol_TableX1(IndexSymbol); // Assume it is a symbol
                    MyXY.Yy = FlowChart_TableY1(IndexFlowChart) + Symbol_TableY1(IndexSymbol);
                    MakeErrorAt(FlowChartScreen.PictureBox1, MyXY, MyErrorList[ErrNumber - 1001] + " " + ErrMsg);
                    break;
                }
            }
        }


        // This will highlight the button that is the current mode.
        void MySetToolStripHighlight(ToolStripButton a, string Cmd)
        {
            if (MyCmdModeString == Cmd)
                a.BackColor = SystemColors.Highlight;
            else
                a.BackColor = SystemColors.Control;
        }


        void MySetButtonEnable(ToolStripButton A, bool B)
        {
            if (A.Enabled == B)
                return;
            A.Enabled = B;
        }



        void MysetDropDownButtonEnable(ToolStripDropDownButton A, bool B)
        {
            if (A.Enabled == B)
                return;
            A.Enabled = B;
        }


        // right now I am only testing if it is not zero, then I apply the rules to return true if the condition is true or false if not

        void MyButtonsEnableRules()
        {
            // Dim ax As long
            MyDoEvents();
            // ax = 0
            // todo  I am using the screen , but I should have that data defined in MuUniverse.programoptions.
            // missing rules.
            // You can not display the flowchart screen if there is no symbols.

            // Test when one required rule fails, other wise do all of the rules asked for (by non-zero means it has to be visible or enable or has text in it.
            // rule one, change no button while the splash screen is displayed
            if (MyFlowChartNameSpace.F_C.ProgramAlive == false)
                return;

            // ******************************************************************************
            // Now symbol screen buttons

            // rule fourteen You need to have a color selected to add a line
            if (MyFlowChartNameSpace.F_C.ProgramAlive == true)
            {
                if (IsNothing(SymbolScreen.ToolStripDropDownButtonColor.Text))
                {
                    AHint(923, "Symbol", "Need To Select a color from the color tool strip drop down button ", "", "");
                    MySetButtonEnable(SymbolScreen.ToolStripButtonAddLine, false);
                }
                else
                {
                    AHint(-923, "symbol", "", "", "");
                    MySetButtonEnable(SymbolScreen.ToolStripButtonAddLine, true);
                }
            }
            if (MyUniverse.ProgramOptions.SelectedSymbolName != SymbolScreen.ToolStripDropDownSelectSymbol.Text | MyUniverse.ProgramOptions.SelectedSymbolName != FlowChartScreen.ToolStripDropDownSelectSymbol.Text | Strings.Len(MyUniverse.ProgramOptions.SelectedSymbolName) == 0)
            {
                AHint(920, "Symbol", "Need To Select a symbol named from the symbol selection tool strip drop down button ", MyUniverse.ProgramOptions.SelectedSymbolName, SymbolScreen.ToolStripDropDownSelectSymbol.Text);
                MySetButtonEnable(SymbolScreen.ToolStripButtonAddLine, false);
            }
            else
            {
                AHint(-920, "symbol", "", "", "");
                MySetButtonEnable(SymbolScreen.ToolStripButtonAddLine, true);
            }

            // rule fifteen to enable an add a point button you need:
            // to enter the name of the point
            if (Len(SymbolScreen.ComboBoxPointNameList.Text) != 0)
            {
                AHint(-911, "symbol", "", "", "");
                // Next you need a datatype selected
                if (Len(SymbolScreen.ToolStripDropDownDataType.Text) != 0)
                {
                    AHint(-912, "symbol", "", "", "");
                    // rule twenty four
                    if (SymbolScreen.ToolStripDropDownInputOutput.DropDownItems.Count > 0)
                    {
                        MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownInputOutput, true);
                        AHint(-906, "symbol", "", "", "");

                        // next you need if it is input or output

                        if (SymbolScreen.ToolStripDropDownInputOutput.Text != MyUniverse.ProgramOptions.SelectedInputOutput)
                        {
                            if (Strings.Len(MyUniverse.ProgramOptions.SelectedInputOutput) == 0)
                                AHint(919, "Symbol", "Select the input or output to add symbol point", "", "");
                            else
                            {
                                AHint(-919, "Symbol", "", "", "");
                                MyUniverse.ProgramOptions.SelectedInputOutput = SymbolScreen.ToolStripDropDownInputOutput.Text;
                            }
                        }
                        else
                        {
                            MySetButtonEnable(SymbolScreen.ToolStripButtonAddPoint, true);
                            AHint(-910, "symbol", "", "", "");
                            if (Len(SymbolScreen.ToolStripDropDownInputOutput.Text) == 0)
                            {
                                MySetButtonEnable(SymbolScreen.ToolStripButtonAddPoint, false);
                                AHint(910, "symbol", "Select the input/output Option For the data path To this symbol from the input/output toolsrip dropdown button.", "", "");
                            }


                            if (Strings.Len(MyUniverse.ProgramOptions.SelectedInputOutput) != 0)
                            {
                            }
                            else
                            {
                                AHint(906, "symbol", "Program issue, return this error message", "No input/output has been made yet.  ", "");
                                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownInputOutput, true);
                            }
                        }
                    }
                    else
                        Abug(371, "Lost", "", "");
                }
                else
                {
                    AHint(912, "symbol", "Select the data type from the datatype tool strip dropdown button", "", "");
                    MySetButtonEnable(SymbolScreen.ToolStripButtonAddPoint, false);
                }
            }
            else
            {
                AHint(911, "symbol", "You need to enter a name of the point to be added", "", SymbolScreen.ComboBoxPointNameList.Text);
                MySetButtonEnable(SymbolScreen.ToolStripButtonAddPoint, false);
            }

            // rule sixteen The delete object is always available
            // todo. but in a message box, is this what you want to delete.......
            MySetButtonEnable(SymbolScreen.ToolStripButtonDelete, true);

            // rule seventeen  If there are any symbols define then you can go to the flowchart. 
            // Since right now I define one, just to make it always work. doesn't mean that will happen in the future.
            // todo this needs something better, just seeing if start has more than a goto is not good enough
            // NumberOfGraphicsInASymbol(FindInSymbolList("Start"), 0)
            // If MyUniverse.SymbolAndPath.Total > 0 Then
            // AHint(-913, "symbol", "", "", "")
            MySetButtonEnable(SymbolScreen.ToolStripButtonFlowChartForm_FromSymbolScreen, true);
            // Else
            // AHint(913, "symbol", "This symbol needs to have some graphics (points And lines).", ShortHighLight("0"), "")
            // MySetButtonEnable(SymbolScreen.ToolStripButtonFlowChartForm_FromSymbolScreen, False)
            // End If


            // rule eightteen You must have something to move.
            NumberOfGraphicsInASymbol(FindInSymbolList(ref MyUniverse.ProgramOptions.SelectedSymbolName), 0);
            if (MyUniverse.SymbolAndPath.Symbol.Total > 0)
            {
                AHint(-915, "symbol", "", "", "");
                if (MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total + MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total > 0)
                {
                    AHint(-916, "symbol", "", "", "");
                    MySetButtonEnable(SymbolScreen.ToolStripButtonDelete, true);
                    MySetButtonEnable(SymbolScreen.ToolStripButtonMove, true);
                }
                else
                {
                    AHint(916, "symbol", "Select a symbol name", "", "");
                    MySetButtonEnable(SymbolScreen.ToolStripButtonDelete, false);
                    MySetButtonEnable(SymbolScreen.ToolStripButtonMove, false);
                }
            }
            else
                AHint(915, "symbol", "There is no symbol graphics in ", MyUniverse.ProgramOptions.SelectedSymbolName, "Add symbol points and lines.");

            // rule nineteen clearing out an old symbol data is always acceptable.
            MySetButtonEnable(SymbolScreen.ToolStripButtonNewSymbol, true);

            // rule twenty The option screen is always available.
            MySetButtonEnable(SymbolScreen.ToolStripButtonOptionForm_FromSymbolScreen, true);

            // rule twenty one something has to have change to update.
            // todo updateing is not written yet
            if (MyUniverse.ProgramOptions.SymbolChanged == true)
            {
                AHint(-903, "symbol", "", "", "");
                MySetButtonEnable(SymbolScreen.ToolStripButtonUpdateSymbol, true);
            }
            else
            {
                AHint(903, "symbol", " symbolchanged has not been set/reset", "", "");
                MySetButtonEnable(SymbolScreen.ToolStripButtonUpdateSymbol, false);
            }

            // rule twenty two If there is a color available then enable it (assumed for now it has colors, cause I currently define them for the user.
            if (SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Count > 0)
            {
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownButtonColor, true);
                AHint(-904, "symbol", "", "", "");
            }
            else
            {
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownButtonColor, true);
                AHint(904, "symbol", "No color names have been entered or imported.", SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Count, "");
            }


            // rule twenty three if there is some datatype available then allow them to be selected.
            if (SymbolScreen.ToolStripDropDownDataType.DropDownItems.Count > 0)
            {
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownDataType, true);
                AHint(-905, "symbol", "", "", "");
            }
            else
            {
                AHint(905, "symbol", "No data types have been entered or imported.", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownDataType, false);
            }


            // rule twenty five The line width is always on.
            if (SymbolScreen.ToolStripDropDownLineWidth.DropDownItems.Count > 0)
            {
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownLineWidth, true);
                AHint(-907, "symbol", "", "", "");
            }
            else
            {
                AHint(907, "symbol", "program issue, return this error message", "no line widths are available to be selected.", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownLineWidth, false);
            }

            // rule twenty six
            if (SymbolScreen.ToolStripDropDownNumberOfBytes.DropDownItems.Count > 0)
            {
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownNumberOfBytes, true);
                AHint(-908, "symbol", "", "", "");
            }
            else
            {
                AHint(908, "symbol", "program issue, return this error message", "a number of bytes is not available.", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownNumberOfBytes, false);
            }

            // rule twenty seven The start and end are always available. (but has to be re-written)
            // todo make sure that the start/end caps and line styles are available and working
            if (SymbolScreen.ToolStripDropDownPathStart.DropDownItems.Count > 0 & SymbolScreen.ToolStripDropDownPathEnd.DropDownItems.Count > 0 & SymbolScreen.ToolStripDropDownPathLineStyle.DropDownItems.Count > 0)
            {
                AHint(-909, "symbol", "", "", "");
                if (Len(SymbolScreen.ToolStripDropDownPathStart.Text) > 0 & Len(SymbolScreen.ToolStripDropDownPathEnd.Text) > 0 & Len(SymbolScreen.ToolStripDropDownPathLineStyle.Text) > 0)
                {
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathStart, true);
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathEnd, true);
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathLineStyle, true);
                    AHint(-914, "symbol", "", "", "");
                }
                else
                {
                    AHint(914, "symbol", "Select a line style, start, and end", "", "");
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathStart, false);
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathEnd, false);
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathLineStyle, false);
                }
            }
            else
            {
                AHint(909, "symbol", "Either the line style, line start or line end of line drop down does not have a valid list", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathStart, false);
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathEnd, false);
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownPathLineStyle, false);
            }



            // rule twenty eight A list of drop down rotations.
            if (SymbolScreen.ToolStripDropDownRotation.DropDownItems.Count > 0)
            {
                AHint(-921, "symbol", "", "", "");
                if (Len(SymbolScreen.ToolStripDropDownRotation.Text) > 0)
                {
                    AHint(-917, "symbol", "", "", "");
                    MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownRotation, true);
                }
                else
                    AHint(917, "symbol", "Select a rotation for placing the symbol from the rotation drop down button", "", "");
            }
            else
            {
                AHint(921, "symbol", "There is no rotation options in the list", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownRotation, false);
            }


            if (SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count > 0)
            {
                AHint(-918, "symbol", "", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownSelectSymbol, true);
            }
            else
            {
                AHint(918, "symbol", "select a symbol name from the select a symbol drop down button", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownSelectSymbol, false);
            }

            if (SymbolScreen.ToolStripDropDownButtonColor.DropDownItems.Count > 0)
            {
                AHint(-922, "symbol", "", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownButtonColor, true);
            }
            else
            {
                AHint(922, "symbol", "Select a color from the color tool strip drop down button", "", "");
                MysetDropDownButtonEnable(SymbolScreen.ToolStripDropDownButtonColor, false);
            }

            // now back to the flowchart screen


            // rule two you can add a constant if there is no constant text to add
            if (Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) == 0)
            {
                AHint(900, "flowchart", "Enter path name on FlowChart Screen", "To add a constant to the FlowChart", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonAddConstant, false);
            }
            else
            {
                AHint(-900, "flowchart", "", "", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonAddConstant, true);
            }

            // rule three you can not add a path unless it has a name in the text box. 
            // to Need to be able to add paths by connecting/moving the first point to the closest named path if there is no name in the text box
            // If Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) = 0 Then ' no name for this Path
            // AHint(901, "flowchart", "Enter the name of the path in the tool strip text box", "", "")
            // MySetButtonEnable(FlowChartScreen.ToolStripButtonAddPath, False)
            // Else
            // AHint(-901, "flowchart", "", "", "")
            MySetButtonEnable(FlowChartScreen.ToolStripButtonAddPath, true);
            // End If


            // rule four  The delete is always available 
            // todo make it available only if there is something to delete

            // rule five Always available
            // todo Mat move button available only if there is something to move.
            if (TopOfFile("FlowChart") > 3)
            {
                AHint(-952, "flowchart", "", "", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonDeleteobject, true);
                MySetButtonEnable(FlowChartScreen.ToolStripButtonMoveObject, true);
            }
            else
            {
                AHint(952, "flowchart", "No FlowChart graphical information to delete", TopOfFile("FlowChart").ToString(), "3"); // mst have "3" 
                MySetButtonEnable(FlowChartScreen.ToolStripButtonDeleteobject, false);
                MySetButtonEnable(FlowChartScreen.ToolStripButtonMoveObject, false);
            }



            // rule six The Flow Chart screen is only available if there is at least on point defined for the "Start" symbol
            // NumberOfGraphicsInASymbol(FindInSymbolList("Start"), 0)
            // If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Total > 1 And
            // MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Total > 1 Then
            // AHint(-953, "flowchart", "", "", "")
            MySetButtonEnable(FlowChartScreen.ToolStripButtonOpenForm, true);
            // Else
            // AHint(953, "flowchart", "'Start' symbol must have at least one logic and one data point in the symbol. ", "", "")
            MySetButtonEnable(FlowChartScreen.ToolStripButtonOpenForm, true);
            // End If

            // rule seven the button to the option screen is always available
            MySetButtonEnable(FlowChartScreen.ToolStripButtonOptionForm, true);

            // rule eight you can always redraw the screen
            // todo need to always make sure that there is something to redraw, even if moving the referance point to make something appear
            // todo always make sure that a paint all will draw something in the display (by moving it right/left and up/down to a corner being displayed
            // 'todo needs to make sure there is something there do move/delete/redraw
            MySetButtonEnable(FlowChartScreen.ToolStripButtonRedraw, true);

            // rule nine other screens are always available to be displayed
            MySetButtonEnable(FlowChartScreen.ToolStripButtonSymbolForm, true);

            // rule ten the zoom in button is not available when you can not zoom in any move
            if (MyUniverse.SysGen.MyFlowChartScale <= ConstantMinFLowChartScale)
            {
                AHint(-954, "flowchart", "", "", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonZoomOut, false);
            }
            else
            {
                AHint(-954, "flowchart", "The Scale is as small as it can go.", MyUniverse.SysGen.MyFlowChartScale.ToString(), ConstantMinFLowChartScale.ToString());
                MySetButtonEnable(FlowChartScreen.ToolStripButtonZoomOut, true);
            }

            LimitScale();
            // rule eleven the zoom out button is no available when you are zoomed out all of the way.
            if (MyUniverse.SysGen.MyFlowChartScale >= ConstantMaxFlowChartScale)
            {
                AHint(-955, "sysgen", "", "", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonZoomIn, false);
            }
            else
            {
                AHint(-955, "flowchart", "", "", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonZoomIn, true);
            }

            // rule twelve If there are no symbols, then the select a symbol should not be available. 
            if (FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count == 0)
            {
                AHint(956, "flowchart", "There are no symbols defined to select", "", "");
                MysetDropDownButtonEnable(FlowChartScreen.ToolStripDropDownSelectSymbol, false);
            }
            else
            {
                AHint(-956, "flowchart", "", "", "");
                MysetDropDownButtonEnable(FlowChartScreen.ToolStripDropDownSelectSymbol, true);
            }

            // Rule thirteen. the text box is always available. But if it is blank then other buttons can not work
            if (Len(FlowChartScreen.ToolStripTextBoxMyInputText.Text) == 0)
            {
                AHint(902, "flowchart", "Adding Paths requires you To enter a path name", "Constants a Constant value To attach To a path", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonAddConstant, false);
            }
            else
            {
                AHint(-902, "flowchart", "", "", "");
                MySetButtonEnable(FlowChartScreen.ToolStripButtonAddConstant, true);
            }

            AHint(-951, "Symbol", "", "", ""); // take it out, casue it's still showing up. put it back if it needs to be there
            AHint(-951, "flowchart", "", "", ""); // Turn hint off
            MyDoEvents();
            if (MyUniverse.ProgramOptions.C_L_LanguageClassName == "")
            {
                AHint(951, "flowchart", "No buttons allowed until you have selected a computer language", "", "Button Rules");
                // MysetDropDownButtonEnable(OptionScreen.ListBoxComputerLanguage, True)
                MySetButtonEnable(OptionScreen.ToolStripButtonCheckAllData, false);
                MySetButtonEnable(OptionScreen.ToolStripButtonDeleteErrorMsgs, false);
                MySetButtonEnable(OptionScreen.ToolStripButtonDeleteUnusedSymbols, false);
                MySetButtonEnable(OptionScreen.ToolStripButtonDump, false);
                MySetButtonEnable(OptionScreen.ToolStripButtonFlowChartForm_FromOptionScreen, false);
                MySetButtonEnable(OptionScreen.ToolStripButtonSymbolForm_FromOptionScreen, false);
            }
            else
            {
                AHint(-951, "flowchart", "", "", ""); // Turn hint off
                AHint(-951, "Symbol", "", "", "");
                DisplayStatus(ref SymbolScreen.LabelProgramStatus.Text, ""); // now display the next hint
                DisplayStatus(ref FlowChartScreen.LabelProgramStatus.Text, "");
                // MysetDropDownButtonEnable(OptionScreen.ToolStripDropDownComputerLanguage, True)
                MySetButtonEnable(OptionScreen.ToolStripButtonCheckAllData, true);
                MySetButtonEnable(OptionScreen.ToolStripButtonDeleteErrorMsgs, true);
                MySetButtonEnable(OptionScreen.ToolStripButtonDeleteUnusedSymbols, true);
                MySetButtonEnable(OptionScreen.ToolStripButtonDump, true);
                MySetButtonEnable(OptionScreen.ToolStripButtonFlowChartForm_FromOptionScreen, true);
                MySetButtonEnable(OptionScreen.ToolStripButtonSymbolForm_FromOptionScreen, true);
            }

            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonFlowChartToSourceCode, true);
            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonOpenFile, true);
            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonSaveFileAs, true);
            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonShowFlowChart, true);
            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonShowOptionScreen, true);
            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonShowSymbolScreen, true);
            MySetButtonEnable(FileInputOutputScreen.ToolStripButtonSourceCodeToFlowChartCode, true);


            // "cmdmovehand","cmdaddpath", "cmddelete", "cmdaddsymbol", "cmdaddpoint", "cmdaddline", "cmdmove", "cmdaddconstant"
            // "cmdaddconstant", "cmdaddpath", "cmddeleteobject", "cmdmovehand", "cmdmove"

            MySetToolStripHighlight(FlowChartScreen.ToolStripButtonAddConstant, "cmdaddconstant");
            MySetToolStripHighlight(FlowChartScreen.ToolStripButtonAddPath, "cmdaddpath");
            MySetToolStripHighlight(FlowChartScreen.ToolStripButtonDeleteobject, "cmddeleteobject");
            MySetToolStripHighlight(FlowChartScreen.ToolStripButtonMoveHand, "cmdmovehand");
            MySetToolStripHighlight(FlowChartScreen.ToolStripButtonMoveObject, "cmdmove");
            // FlowChartScreen.ToolStripButtonOpenForm 
            // FlowChartScreen.ToolStripButtonOptionForm
            // FlowChartScreen.ToolStripButtonRedraw
            // FlowChartScreen.ToolStripButtonSymbolForm
            // FlowChartScreen.ToolStripButtonZoomIn
            // FlowChartScreen.ToolStripButtonZoomOut
            // FlowChartScreen.ToolStripDropDownSelectSymbol
            // FlowChartScreen.ToolStripFlowChart
            // FlowChartScreen.ToolStripTextBoxMyInputText




            // "cmdmovehand","cmdaddpath", "cmddelete", "cmdaddsymbol", "cmdaddpoint", "cmdaddline", "cmdmove", "cmdaddconstant"
            // "cmdaddconstant", "cmdaddpath", "cmddeleteobject", "cmdmovehand", "cmdmove"
            MySetToolStripHighlight(SymbolScreen.ToolStripButtonAddLine, "cmdaddline");
            MySetToolStripHighlight(SymbolScreen.ToolStripButtonAddPoint, "cmdaddpoint");
            MySetToolStripHighlight(SymbolScreen.ToolStripButtonDelete, "cmddelete");
            // MySetToolStripHighlight(SymbolScreen.ToolStripButtonFlowChartForm_FromSymbolScreen, "cmd")
            MySetToolStripHighlight(SymbolScreen.ToolStripButtonMove, "cmdmove");
        }

        void FixSinTaxCode(long IndexNamed)
        {
            long IndexSymbol;
            string PointName;
            IndexSymbol = Named_TableSymbolIndexes(IndexNamed);
            if (Symbol_TableCoded_String(IndexSymbol) != "/name")
                return;
            IndexSymbol += 1;
            while (Symbol_TableCoded_String(IndexSymbol) != "/name" & IndexSymbol <= TopOfFile("Symbol"))
            {
                if (Symbol_TableCoded_String(IndexSymbol) == "/point")
                {
                    PointName = NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol));
                    if (Strings.Len(PointName) < 1)
                    {
                        if (Len(SymbolScreen.ComboBoxPointNameList.Text) == 0)
                        {
                            Abug(372, "Point name Is Nothing changed To unknown", MyShowNamed(IndexNamed), MyShowSymbolGraphic(IndexSymbol));
                            Symbol_Table_NameOfPoint(IndexSymbol, MakeNewName("Var_", MyUniverse.MySS.Inputs.LineNumberIn, "Var_"));
                        }
                        else
                            // Abug(373, "Point name Is Nothing changed To " & SymbolScreen.ComboBoxPointNameList.text, MyShowNamed(IndexNamed), MyShowSymbolGraphic(IndexSymbol))
                            if (Len(SymbolScreen.ComboBoxPointNameList.Text) > 0)
                            {
                                Symbol_Table_NameOfPoint(IndexSymbol, SymbolScreen.ComboBoxPointNameList.Text);
                                SymbolScreen.ComboBoxPointNameList.Text = ""; // Used this name so erase it
                            }
                            else
                                Symbol_Table_NameOfPoint(IndexSymbol, "unknown2");
                    }
                    else
                        // todo this is failing to find what it should find

                        if (Strings.InStr(Named_TableSintax(IndexNamed), MyUniverse.SysGen.Constants.RMStart + PointName + ".") == 0)
                        {
                            // Todo add the name to the code/syntax/pointnames list
                            Abug(374, HighLight(MyUniverse.SysGen.Constants.RMStart + Symbol_Table_NameOfPoint(IndexSymbol) + ".") + " Point name is not in the micro text", MyShowSymbolPoint(IndexSymbol), MyShowNamed(IndexNamed));
                            if (Strings.Left(Symbol_Table_NameOfPoint(IndexSymbol), Strings.Len(MyUniverse.SysGen.Constants.RMStart)) == MyUniverse.SysGen.Constants.RMStart)
                                Abug(503, "Not sure how I can get here", MyShowSymbolGraphic(IndexSymbol), Symbol_Table_NameOfPoint(IndexSymbol));
                            else
                            {
                                Named_TableSintax(IndexNamed, Named_TableSintax(IndexNamed) + Constants.vbCrLf + MyUniverse.SysGen.Constants.RMStart + Symbol_Table_NameOfPoint(IndexSymbol) + ".PATHName" + MyUniverse.SysGen.Constants.RMEnd);
                                AddPointNameToDropDown(Symbol_Table_NameOfPoint(IndexSymbol)); // If it is already there it will not add it again.
                                SymbolScreen.TextBoxNamedProgramText.Text = Named_TableSintax(IndexNamed);
                                AddPointNameToDropDown(Symbol_Table_NameOfPoint(IndexSymbol));
                            }
                        }
                        else
                        {
                        }
                }
                else
                    AInfo1(794, "Not a point", "", Symbol_TableCoded_String(IndexSymbol));
                IndexSymbol += 1;
            }
        }


        long FindingMyBugsNets()
        {
            long Idex, Jdex, K;
            string TempI, tempJ;

            for (Idex = Information.LBound(Net_FileLinks) + 1; Idex <= Information.UBound(Net_FileLinks); Idex++)
            {
                switch (FlowChart_TableCode(Idex))
                {
                case "/use":
                {
                    break;
                }

                case "error":
                {
                    break;
                }

                case "unknown":
                {
                    break;
                }

                case "/path" // We are only interested in the paths (for now, )
                    :
                {
                    Jdex = FindIndex_In_TableNetLinks(Idex); // make sure that path is in a net
                    if (Jdex == constantMyErrorCode)
                        Abug(807, "Path not in any path link", MyShowFlowChartRecord(Idex), "");
                    else if (FlowChart_TablePath_Name(Idex) != Net_TableNames(FindIndex_In_TableNetLinks(Idex)))
                        Abug(807, " Path name does not match path links name", MyShowNetLnks(Idex), MyShowNetLnks(Jdex));
                    // A I N F O 2 (183)
                    TempI = Net_FileLinks[Idex];
                    for (Jdex = Idex + 1; Jdex <= Information.UBound(Net_FileLinks); Jdex++)
                    {
                        // A I N F O 2 (184)
                        if (Strings.Len(Net_TableNames(Idex)) > 0)
                        {
                            if (Net_TableNames(Idex) == Net_TableNames(Jdex))
                                // A I N F O 2 (172)
                                return Abug(375, " 2 different paths with the same name.", MyShowNetLnks(Idex), MyShowNetLnks(Jdex));
                        }
                        // A I N F O 2 (185)
                        tempJ = Net_FileLinks[Jdex];
                        // A I N F O 2 (186)
                        while (Strings.Len(tempJ) > 0)
                        {
                            // A I N F O 2 (187)
                            K = PopValue(ref tempJ);
                            // search for ,x, in temp1
                            if (Strings.InStr(FD + K.ToString() + FD, TempI) != 0)
                                // A I N F O 2 (173)
                                return Abug(376, "2 path links have the same path", MyShowNetLnks(Idex), MyShowNetLnks(Jdex));
                        }
                    }

                    break;
                }
                }
            }
            // A I N F O 2 (174)
            return 0;
        }




        // todo add this all over the place when something changes (for now it is inside findingmybugs()
        long FindingMyBugsPoints(string SymbolName)
        {
            // This is to find issues when dealing with points
            long IndexNamed, IndexSymbol;
            long PointNumber, LineNumber;
            long IndexDatatype, IndexColor;
            string DataTypeName, ColorName;
            long Kounter;
            // Make sure that we are on the symbol in the symbol screen 
            // because it should then have the points and lines correct
            FindingMyBugsPoints = 0;
            if (Strings.LCase(Strings.Trim(SymbolName)) != Strings.LCase(Strings.Trim(MyUniverse.ProgramOptions.SelectedSymbolName)))
            {
                if (SymbolScreen.Visible == true)
                    AInfo1(757, " This is NOT The selected symbol.", HighLight(SymbolName), HighLight(MyUniverse.ProgramOptions.SelectedSymbolName));
            }
            PointNumber = 0;
            LineNumber = 0;
            // Find the IndexSymbol
            IndexNamed = FindIndexIniSAMTable("named", "Donotadd", ref Named_FileSymbolName, ref Named_FileSymbolName_iSAM, SymbolName);
            IndexSymbol = GetSelfCorrectingIndexes(SymbolName);

            // DOC only if the symbolscreen is visiable do I check if it is valid 
            if (SymbolScreen.Visible == true)
            {
                if (Symbol_TableCoded_String(IndexSymbol) == "/name")
                {
                    // DOC AND if the symbol is selected as the symbol to edit/place
                    if (Symbol_TableSymbolName(IndexSymbol) == SymbolName)
                    {
                        IndexSymbol += 1; // Go past the "/name"

                        NumberOfGraphicsInASymbol(IndexSymbol, 0); // Get a count of all of the points for this symbol

                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total > 0)
                            Abug(377, "Error messages inside this symbol", HighLight(SymbolName), MyShowPointCounts());
                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total < 4)
                            AInfo(648, "Not very many lines", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfLines.ToString());

                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total > 0)
                            Abug(378, "unknown symbol graphics", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfOther.ToString());

                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both > 0)
                            Abug(379, "Logic can only have an input or an output, because a Path can only have one output (destiantion)", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both.ToString());

                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total < 2)
                            AInfo(649, "You are not working on any data for this symbol?", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total.ToString());

                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other < 1)
                            AInfo(651, " no data is being generated.  So what is this suppost to do?", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other.ToString());

                        if (MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other > 0)
                            Abug(381, "unknown point type for data", HighLight(SymbolName), MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other.ToString());

                        // Only If this Is a Then name record Do I check the rest Of the records.
                        while (IndexSymbol < TopOfFile("Symbol"))
                        {
                            // Now go through the symbol and check against everything
                            switch (Strings.LCase(Symbol_TableCoded_String(IndexSymbol)))
                            {
                            case "/name":
                            {
                                return;// Finished checking the symbol
                            }

                            case "/point":
                            {
                                // AInfo(652, "Checking point names ", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed))
                                // todo add the above checks
                                // 1. See if the symbol points is in the syntax
                                if (Strings.InStr(Named_TableSintax(IndexNamed), MyUniverse.SysGen.Constants.RMStart + NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))) != 0)
                                    AInfo(653, "The point name Is In the syntax ", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                                else
                                    AInfo1(683, "The point name Is Not In the syntax With a variable attibute.", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));

                                // 2. see if the symbol point is in the program code line
                                if (Strings.InStr(Named_TableMicroCodeText(IndexNamed), Symbol_Table_NameOfPoint(IndexSymbol)) != 0)
                                    AInfo(655, "The point name Is In the program code", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                                else
                                    FindingMyBugsPoints += Abug(382, "Warning the name Of the point Is Not In the program code.", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));

                                // 3. if the symbol screen is there then make sure that the names of the points are in the right place in the name of the points
                                // DOC does the selected symbol match to this tymbol
                                if (MyUniverse.ProgramOptions.SelectedSymbolName == Symbol_TableSymbolName(IndexNamed))
                                {
                                    // DOC does the symbolname match what is in the symbol screen text box (ie active symbol)
                                    if (Named_TableSymbolName(IndexNamed) == SymbolScreen.TextBoxNamedSymbolName.Text)
                                    {
                                        // DOC is there enough points in the drop down to check this name
                                        if (PointNumber < SymbolScreen.ComboBoxPointNameList.Items.Count - 1)
                                        {
                                            // DOes the names match
                                            if (Symbol_Table_NameOfPoint(IndexSymbol) == SymbolScreen.ComboBoxPointNameList.Items(PointNumber).ToString)
                                                // DOC everything matches so its OK
                                                AInfo(657, MyShowNamed(IndexNamed), MyShowSymbolGraphic(IndexSymbol), " Everything Is OK");
                                            else
                                            {
                                                for (Kounter = 0; Kounter <= SymbolScreen.ComboBoxPointNameList.Items.Count - 1; Kounter++)
                                                    AInfo(658, "Point number " + Kounter + "  " + SymbolScreen.ComboBoxPointNameList.Items.Item(Kounter).ToString, "", "");
                                                AInfo(659, "The symbol point list box, does Not match the order Or point name for point # " + PointNumber, "For Symbol " + Symbol_TableSymbolName(IndexSymbol), " Indexes " + IndexNamed + ": " + IndexSymbol + Constants.vbCrLf + HighLight(Symbol_TableSymbolName(IndexSymbol)) + "          " + HighLight(SymbolScreen.ComboBoxPointNameList.Items(PointNumber).ToString));
                                            }
                                        }
                                        else
                                            // DOC There is not enough points on the symbol point list, (usually because we are not on the symbol screen doing this sub routine.
                                            if (SymbolScreen.ComboBoxPointNameList.Items.Count != 0)
                                            {
                                                for (Kounter = 0; Kounter <= SymbolScreen.ComboBoxPointNameList.Items.Count - 1; Kounter++)
                                                    AInfo(661, "Point number " + Kounter + "  " + SymbolScreen.ComboBoxPointNameList.Items.Item(Kounter).ToString, "", "");
                                                FindingMyBugsPoints += Abug(383, "The symbol screen does not have enough point names in the drop down list.", "need " + PointNumber + 1 + " Have : " + SymbolScreen.ComboBoxPointNameList.Items.Count - 1, "");
                                            }
                                    }
                                    else
                                        // DOC this symbol is not active so can not check if it has what is needed.?
                                        AInfo(662, "This is not the selected symbol", MyShowSymbolGraphic(IndexSymbol), SymbolScreen.TextBoxNamedSymbolName.Text);
                                    AInfo(663, " Symbol, Point names", Symbol_TableSymbolName(IndexSymbol), MyShowSymbolGraphic(IndexSymbol));
                                }
                                else
                                    // DOC this is not the active symbol so not checking
                                    AInfo(664, "This is not the selected symbol", MyShowSymbolGraphic(IndexSymbol), "");

                                // 4 check that this point has a valid data type
                                DataTypeName = Symbol_Table_DataType(IndexSymbol);
                                if (IndexDatatype == constantMyErrorCode)
                                    Abug(384, " invalid datatype ", MyShowSymbolGraphic(IndexSymbol), "");
                                else
                                {
                                    ColorName = FindColorFromDataType(DataTypeName);
                                    if (IndexColor == constantMyErrorCode)
                                        Abug(385, "The datatype table points to an invalid color name", MyShowDataTable(IndexDatatype), MyShowColor(IndexColor));
                                    PointNumber += 1;
                                }

                                break;
                            }

                            case "/line":
                            {
                                AInfo(665, "Checking line colors", MyShowSymbolGraphic(IndexSymbol), MyShowNamed(IndexNamed));
                                // todo add the above check
                                // 3. if the symbol screen is there then make sure that the names of the points are in the right place in the name of the points
                                // 4. and while we are at it, make sure the color of lines in the symbol is in the line color list
                                // 5. make sure that line color names in the line color list is valid colors
                                LineNumber += 1;
                                break;
                            }

                            case "/unknown":
                            {
                                AInfo1(759, "Ignoreing unknown code", MyShowSymbolGraphic(IndexSymbol), Symbol_TableCoded_String(IndexSymbol));
                                if (Symbol_TableCoded_Byte(IndexSymbol) != 0)
                                    AInfo(666, "This record should not be in the symbol graphics table ", MyShowSymbolGraphic(IndexSymbol), "Indexs " + IndexNamed + " : " + IndexSymbol);
                                break;
                            }

                            default:
                            {
                                FindingMyBugsPoints += Abug(386, "This symbol Graphics code is not taken care of", MyShowSymbolGraphic(IndexSymbol), "");
                                break;
                            }
                            }
                            IndexSymbol = +1;
                        }
                    }
                }
            }
        }


        void FindingMyBUgXY(long IndexFlowChart)
        {
            const long X = 1500;
            const long Y = 4250;
            long LastIndexToMatch = 0;
            long DebugX, DebugY;

            DebugX = FlowChart_FileX1[IndexFlowChart];
            DebugY = FlowChart_FileY1[IndexFlowChart];
            if (MyOptionTest(31) == false)
                return;

            // ainfo2(30)
            if (FlowChart_FileX1[IndexFlowChart] == X)
            {
                if (FlowChart_FileY1[IndexFlowChart] == Y)
                {
                    // First Point
                    AInfo0(991, Constants.vbCrLf + ",index=" + IndexFlowChart + ",last=" + LastIndexToMatch + FD + FlowChart_FilePathSymbolName[IndexFlowChart], FlowChart_FileX1[IndexFlowChart] + FD + FlowChart_FileY1[IndexFlowChart] + FD + FlowChart_File_X2_Rotation[IndexFlowChart] + FD + FlowChart_File_Y2_Option[IndexFlowChart], MyShowPoint(DistanceBetweenTwoPoints(FlowChart_FileX1[IndexFlowChart], FlowChart_FileY1[IndexFlowChart], FlowChart_File_X2_Rotation[IndexFlowChart], FlowChart_File_Y2_Option[IndexFlowChart])));
                    LastIndexToMatch = IndexFlowChart;
                }
            }
            if (FlowChart_File_X2_Rotation[IndexFlowChart] == X)
            {
                if (FlowChart_File_Y2_Option[IndexFlowChart] == Y)
                {
                    // second point
                    AInfo0(991, Constants.vbCrLf + ",index=" + IndexFlowChart + ",last=" + LastIndexToMatch + FD + FlowChart_FilePathSymbolName[IndexFlowChart], FlowChart_FileX1[IndexFlowChart] + FD + FlowChart_FileY1[IndexFlowChart] + FD + FlowChart_File_X2_Rotation[IndexFlowChart] + FD + FlowChart_File_Y2_Option[IndexFlowChart], MyShowPoint(DistanceBetweenTwoPoints(FlowChart_FileX1[IndexFlowChart], FlowChart_FileY1[IndexFlowChart], FlowChart_File_X2_Rotation[IndexFlowChart], FlowChart_File_Y2_Option[IndexFlowChart])));
                    LastIndexToMatch = IndexFlowChart;
                }
            }
        }

        string CountStack()
        {
            long Counter, Kounter;
            CountStack = "";
            if (MyOptionTest(31) == false)
                return null;
            Counter = 1;
            Kounter = 0;

            while (Counter != 0)
            {
                Counter += 1;
                Kounter += 1;
                Counter = InStr(Counter, My.Application.Info.StackTrace, Constants.vbCrLf);
            }
            return "[Called=" + Kounter.ToString() + "]";
        }



        // ******************************************************************************
        // hack
        // This routine is here to try and find all of the possible issues that I am aware
        // of that was causing issues in not doing what I thought that it should be doing 
        // what I think the data should be doing.
        // This is to trace down all of my know bug issues And I can put this everwhere 
        long FindingMyBugs(long LevelOfBugChecking) // hack
        {
            FindingMyBugs = 0;
            if (MyOptionTest(31) == false)
                return 0;
            if (MyFlowChartNameSpace.F_C.ProgramAlive == false)
                return 0;
            // doc set flag so that it is not doing this recursively
            if (MyUniverse.SysGen.FindingMyBugsFlag == true)
                return 0;
            MyUniverse.SysGen.FindingMyBugsFlag = true;
            // MyTrace(434, "FindingMyBugs", 922 - 668)

            FindMyBugsROUTER_OnTop();
            FindingMyBugs += FindingMyBugsDropDowns();
            FindingMyBugs += FindingMyBugsSorted();
            FindingMyBugs += FindingMyBugsColor();
            FindingMyBugs += FindingMyBugsDataType();
            FindingMyBugs += FindingMyBugsSymbol();
            FindingMyBugs += FindingMyBugsNamed();
            FindingMyBugs += FindingMyBugsFlowChart();
            FindingMyBugs += FindingMyBugsKeyWord("keyword", Language_KeyWord);
            FindingMyBugs += FindingMyBugsKeyWord("operator", Language_Operator);
            FindingMyBugs += FindingMyBugsKeyWord("function", Language_Function);
            FindingMyBugs += FindingMyBugsNets();



            MyUniverse.SysGen.FindingMyBugsFlag = false;
        }

        long FindingMySortedBugNumber(long[] MyArrayLong, long[] ISAM, long Idex)
        {
            if (MyOptionTest(31) == false)
                return 0;
            if (InvalidIndex(Idex, MyArrayLong, ref ISAM) == true)
                return 1;
            else
                return 0;
        }
        long FindingMySortedBugString(string[] MyArray, long[] ISAM, long Idex)
        {
            if (MyOptionTest(31) == false)
                return 0;
            if (InvalidIndex(Idex, ref MyArray, ref ISAM) == true)
                return 1;
            else
                return 0;
        }


        // Find any and all bugs if there is any left.
        long FindingMyBugsSorted()
        {
            long I;
            FindingMyBugsSorted = 0;
            if (MyOptionTest(31) == false)
                return;
            for (I = 1; I <= Information.UBound(FlowChart_FileCoded); I++)
            {
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_FileX1, FlowChart_iSAM_X1, I);
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_FileY1, FlowChart_iSAM_Y1, I);
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_File_X2_Rotation, FlowChart_iSAM_X2, I);
                FindingMyBugsSorted += FindingMySortedBugNumber(FlowChart_File_Y2_Option, FlowChart_iSAM_Y2, I);
                FindingMyBugsSorted += FindingMySortedBugString(FlowChart_FilePathSymbolName, FlowChart_iSAM_Name, I);
            }


            for (I = 1; I <= Information.UBound(Named_FileSintax_Isam); I++)
            {
                FindingMyBugsSorted += FindingMySortedBugString(Named_FileSymbolName, Named_FileSymbolName_iSAM, I);
                FindingMyBugsSorted += FindingMySortedBugString(Named_FileSintax, Named_FileSintax_Isam, I);
            }



            for (I = 1; I <= Information.UBound(DataType_FileName); I++)
                FindingMyBugsSorted += FindingMySortedBugString(DataType_FileName, DataType_Name_iSAM, I);



            for (I = 1; I <= Information.UBound(Color_FileName); I++)
                FindingMyBugsSorted += FindingMySortedBugString(Color_FileName, Color_Name_iSAM, I);

            for (I = 1 + 1; I <= Information.UBound(Language_KeyWord) - 1; I++)
            {
                if (Language_KeyWord[I - 1] >= Language_KeyWord[I])
                    FindingMyBugsSorted += 1;
                if (Language_KeyWord[I] >= Language_KeyWord[I + 1])
                    FindingMyBugsSorted += 1;
            }

            for (I = 1 + 1; I <= Information.UBound(Language_Operator) - 1; I++)
            {
                if (Language_Operator[I - 1] >= Language_Operator[I])
                    FindingMyBugsSorted += 1;
                if (Language_Operator[I] >= Language_Operator[I + 1])
                    FindingMyBugsSorted += 1;
            }

            for (I = 1 + 1; I <= Information.UBound(Language_Function) - 1; I++)
            {
                if (Language_Function[I - 1] >= Language_Function[I])
                    FindingMyBugsSorted += 1;
                if (Language_Function[I] >= Language_Function[I + 1])
                    FindingMyBugsSorted += 1;
            }
        }

        long FindingMyBugsFlowChart()
        {
            long IndexFlowChart;
            // *************************************************************
            FindingMyBugsFlowChart = 0;
            if (MyOptionTest(31) == false)
                return;


            CheckAllSymbolsOnFlowChart(FlowChartScreen.PictureBox1);
            for (IndexFlowChart = 1; IndexFlowChart <= FlowChart_TableCount; IndexFlowChart++) // Through all of the /use/path records (and others)
            {
                FindingMyBUgXY(IndexFlowChart);
                switch (FlowChart_TableCode(IndexFlowChart))
                {
                case "/use":
                {
                    // todo check that this symbol exist
                    // todo check that it is not negitive ( I might want to use - later as a flag for compiling
                    // Test that the rotation and datatype is valid
                    if (FlowChart_TableX2(IndexFlowChart) > SymbolScreen.ToolStripDropDownRotation.DropDownItems.Count - 1)
                        FindingMyBugsFlowChart += Abug(387, MyShowFlowChartRecord(IndexFlowChart), IndexFlowChart, "Invalid rotation ");
                    if (FlowChart_TableX2(IndexFlowChart) < 0)
                        FindingMyBugsFlowChart += Abug(388, MyShowFlowChartRecord(IndexFlowChart), IndexFlowChart, "might be an Invalid rotation ");
                    // todo Need to check for the future options
                    if (FlowChart_TableY2(IndexFlowChart) != 0)
                        FindingMyBugsFlowChart += AInfo(667, MyShowFlowChartRecord(IndexFlowChart), IndexFlowChart, "This is for future expansion of the /use record");
                    break;
                }

                case "/path" // currently no checks (should check if connected etc...
                    :
                {
                    if (FlowChart_FilePathSymbolName[IndexFlowChart] != Net_TableNames(FindIndex_In_TableNetLinks(IndexFlowChart)))
                        Abug(389, " Problem with names saved ", MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(FindIndex_In_TableNetLinks(IndexFlowChart)));
                    FindingMyBugsFlowChart += FindingMyBugsPath(IndexFlowChart);
                    break;
                }

                case "/constant"// currently no checks, should check that only one per path(s)
                    :
                {
                    break;
                }

                case "/unknown":
                {
                    AInfo(668, "Flowchart has record with a unused code", MyShowFlowChartRecord(IndexFlowChart), "");
                    break;
                }

                case "/error" // Need to recheck all /errors
                    :
                {
                    break;
                }

                case null:
                {
                    FindingMyBugsFlowChart += AInfo(669, "FindingMyBugsFlowChart: invalid code in the symbol table", MyShowFlowChartRecord(IndexFlowChart), "??");
                    break;
                }

                default:
                {
                    FindingMyBugsFlowChart += Abug(391, "FindingMyBugsFlowChart: invalid code in the symbol table", MyShowFlowChartRecord(IndexFlowChart), "??");
                    break;
                }
                }
            }
        }

        long FindingMyBugsSymbol()
        {
            long IndexSymbol, Jndex;
            FindingMyBugsSymbol = 0;
            if (MyOptionTest(31) == false)
                return;
            // *************************************************************
            for (IndexSymbol = 1; IndexSymbol <= NewTopOfFile("Symbol") - 1; IndexSymbol++) // Symbol_TableCount '2020 07 19 replaced count
            {
                FindingMyBugsSymbol += FindingSymbolOutOfXYSizeBugs(IndexSymbol); // Check if the symbol is within the allowed bounds (??,??)
                if (Symbol_TableCoded_String(IndexSymbol) == "/name")
                {
                    for (Jndex = IndexSymbol + 1; Jndex <= NewTopOfFile("Symbol") - 1; Jndex++)
                    {
                        if (Symbol_TableCoded_String(IndexSymbol + 1) == "/name")
                        {
                            if (Symbol_TableSymbolName(IndexSymbol) == Symbol_TableSymbolName(IndexSymbol + 1))
                                FindingMyBugsSymbol += Abug(392, "Duplicate symbol name in the symbol graphics table", MyShowSymbolGraphic(IndexSymbol), MyShowSymbolGraphic(IndexSymbol + 1));
                        }
                    }
                }

                // Test for duplicate names in the symbol table 
                if (Symbol_TableCoded_String(IndexSymbol) == "/name")
                {
                    for (Jndex = IndexSymbol + 1; Jndex <= NewTopOfFile("Symbol"); Jndex++) // from that record to the end (since before has already been checked)
                    {
                        if (Symbol_TableCoded_String(Jndex) == "/name")
                        {
                            if (MyCompared1_a(Symbol_FileSymbolName[IndexSymbol], Symbol_FileSymbolName[Jndex]) == 0)
                            {
                                FindingMyBugsSymbol += Abug(393, "The same symbol name ", MyShowSymbolGraphic(IndexSymbol), MyShowSymbolGraphic(Jndex));
                                Dump1();
                            }
                        }
                    }
                }


                if (Symbol_FileCoded[IndexSymbol] == MyKeyword_2_Byte("/name"))
                {
                    if (Symbol_FileCoded[IndexSymbol + 1] == MyKeyword_2_Byte("/name"))
                    {
                        if (Information.IsNothing(Symbol_FileSymbolName[IndexSymbol]) | Information.IsNothing(Symbol_FileSymbolName[IndexSymbol + 1]))
                        {
                        }
                        else
                        {
                            FindingMyBugsSymbol += Abug(394, "FindingMyBugsSymbol() Two name with no graphics between", MyShowSymbolGraphic(IndexSymbol), MyShowSymbolGraphic(IndexSymbol + 1));
                            if (Symbol_FileSymbolName[IndexSymbol] == Symbol_FileSymbolName[IndexSymbol + 1])
                                FindingMyBugsSymbol += Abug(395, "FindingMyBugsSymbol() Duplicated symbol name ", MyShowSymbolGraphic(IndexSymbol), MyShowSymbolGraphic(IndexSymbol));
                        }
                    }
                }

                // test if Datatype is OK
                if (MyFlowChartNameSpace.F_C.ProgramAlive == true)
                {
                    switch (Symbol_TableCoded_String(IndexSymbol))
                    {
                    case "/name":
                    case "/line":
                        case "/point"// OK, so ignore.
                            :
                        {
                            break;
                        }

                        case "/error":
                        {
                            if (Symbol_TableSymbolName(IndexSymbol) != "" | Symbol_Table_NameOfPoint(IndexSymbol) != "")
                            {
                            }
                            else
                                AInfo1(764, Symbol_TableCoded_String(IndexSymbol) + " in the symbol table should not happen?", MyShowSymbolGraphic(IndexSymbol), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)));
                            break;
                        }

                        case "/unknown":
                        {
                            if (Symbol_TableSymbolName(IndexSymbol) != "" | Symbol_Table_NameOfPoint(IndexSymbol) != "")
                                FindingMyBugsSymbol += Abug(396, Symbol_TableCoded_String(IndexSymbol) + " in the symbol table should not happen?", MyShowSymbolGraphic(IndexSymbol), HighLight(Symbol_Table_NameOfPoint(IndexSymbol)));
                            else
                            {
                            }

                            break;
                        }

                        default:
                        {
                            AInfo(671, HighLight(Symbol_TableCoded_String(IndexSymbol)) + " Not a known code", HighLight(Symbol_TableCoded_String(IndexSymbol)), MyShowSymbolGraphic(IndexSymbol));
                            if (Symbol_Table_DataType(IndexSymbol) == "")
                                FindingMyBugsSymbol += Abug(397, "Invalid data type for " + MyShowSymbolGraphic(IndexSymbol), "", "");
                            break;
                        }
                    }
                }
            }
        }


        long FindingMyBugsDataType()
        {
            long IndexDataType;
            FindingMyBugsDataType = 0;
            if (MyOptionTest(31) == false)
                return;


            for (IndexDataType = 1; IndexDataType <= DataType_TableCount; IndexDataType++)
            {
                if (DataType_Name_iSAM[IndexDataType] > 0)
                {
                    if (DataType_Name_iSAM[IndexDataType] == DataType_Name_iSAM[IndexDataType + 1])
                        FindingMyBugsDataType += Abug(401, "The duplicate Datatype index", MyShowDataTable(IndexDataType), MyShowDataTable(IndexDataType));
                }
                // if the index is wrong then there is a issue, that needs to be fixed (Make it Black?)
                if (DataType_FileColorIndex[IndexDataType] <= 0)
                    FindingMyBugsDataType += Abug(402, "Invalid Datatype Color Index ", MyShowDataTable(IndexDataType), ""); // Was an invalid color
                else if (DataType_FileColorIndex[IndexDataType] > 0)
                {
                    if (DataType_FileColorIndex[IndexDataType] > Information.UBound(Color_FileName))
                        FindingMyBugsDataType += Abug(403, " points to a color name that does exist non existant color : ", MyShowDataTable(IndexDataType), "Maxiumn number of known colors" + " : " + Information.UBound(Color_FileName));
                }
                else
                    FindingMyBugsDataType += Abug(404, "There is no color for this data type : " + MyShowDataTable(IndexDataType), IndexDataType, "");
                // Making sure that the data type is in order

                switch (MyCompared3(DataType_TableName(DataType_Name_iSAM[IndexDataType - 1]), DataType_TableName(DataType_Name_iSAM[IndexDataType]), DataType_TableName(DataType_Name_iSAM[IndexDataType + 1])))
                {
                    case -5 // 9   -5 	A > C 'Unsorted List
                        :
                    {
                        FindingMyBugsDataType += Abug(405, "Datatype is unsorted ERROR ", MyShowDataTable(DataType_Name_iSAM[IndexDataType - 1]) + Constants.vbCrLf + MyShowDataTable(DataType_Name_iSAM[IndexDataType]) + Constants.vbCrLf + MyShowDataTable(DataType_Name_iSAM[IndexDataType - 1]), "");
                        break;
                    }

                    case -4 // beginning of the list so ignore it
                        :
                    {
                        // 5   -4 	A=nothing And b< C
                        // 7   -4 	A=Nothing
                        if (!Information.IsNothing(DataType_TableName(DataType_Name_iSAM[IndexDataType - 1])))
                            FindingMyBugsDataType += Abug(406, "Datatype List Out of order", IndexDataType, "{" + DataType_TableName(DataType_Name_iSAM[IndexDataType - 1]) + "} : {" + DataType_TableName(DataType_Name_iSAM[IndexDataType]) + "} : {" + DataType_TableName(DataType_Name_iSAM[IndexDataType + 1]) + "}");
                        break;
                    }

                    case -3 // 11  -3	    A>b List out of order
                        :
                    {
                        FindingMyBugsDataType += Abug(407, "Datatype List Out of order", IndexDataType, MyShowDataTable(IndexDataType - 1) + Constants.vbCrLf + MyShowDataTable(IndexDataType) + Constants.vbCrLf + MyShowDataTable(IndexDataType + 1));
                        break;
                    }

                    case -2 // 12  -2 	b > C List is out of order
                        :
                    {
                        FindingMyBugsDataType += Abug(408, "Datatype List is out of order ", IndexDataType, MyShowDataTable(IndexDataType - 1) + Constants.vbCrLf + MyShowDataTable(IndexDataType) + Constants.vbCrLf + MyShowDataTable(IndexDataType + 1));
                        break;
                    }

                    case -1 // 3   -1	    A=b
                        :
                    {
                        FindingMyBugsDataType += Abug(409, "Datatype List has a duplicate ", IndexDataType, MyShowDataTable(IndexDataType - 1) + Constants.vbCrLf + MyShowDataTable(IndexDataType) + Constants.vbCrLf + MyShowDataTable(IndexDataType + 1));
                        FindingMyBugsDataType += Abug(411, MyShowDataTable(IndexDataType - 1), MyShowDataTable(IndexDataType), MyShowDataTable(IndexDataType + 1));
                        break;
                    }

                    case 0  // they are equal , which they should never be.  only one name allowed per data type
                        :
                    {
                        break;
                    }

                    case 1 // 4   1  	b=C  Datatype Should never have a duplicate
                        :
                    {
                        FindingMyBugsDataType += Abug(412, "Datatype List has a duplicate ", IndexDataType, MyShowDataTable(IndexDataType - 1) + Constants.vbCrLf + MyShowDataTable(IndexDataType) + Constants.vbCrLf + MyShowDataTable(IndexDataType + 1));
                        break;
                    }

                    case 2                        // 14  2  	A < b The list is ok, so ignore it
                        :
                    {
                        break;
                    }

                    case 3                        // 13  3	    b < C The list is ok, so ignore it
                        :
                    {
                        break;
                    }

                    case 4// end of the list SO IGNORE IT
                        :
                    {
                        break;
                    }

                    case 5 // idex = null Which is not a bug if -1 or +1 is also null
                        :
                    {
                        FindingMyBugsDataType += Abug(413, "The compare of the Datatypes are wrong because they are out of order", IndexDataType, MyShowDataTable(IndexDataType - 1) + Constants.vbCrLf + MyShowDataTable(IndexDataType) + Constants.vbCrLf + MyShowDataTable(IndexDataType + 1));
                        break;
                    }
                }
            }
        }

        long FindingMyBugsColor()
        {
            long indexColor;
            FindingMyBugsColor = 0;
            if (MyOptionTest(31) == false)
                return;


            // *************************************************************
            for (indexColor = 1; indexColor <= Color_TableCount; indexColor++)
            {
                // The color table should never be nothing
                if (!Information.IsNothing(Color_FileName[Color_Name_iSAM[indexColor]]))
                {
                    // The color table should never be nothing
                    if (!Information.IsNothing(Color_FileName[Color_Name_iSAM[indexColor + 1]]))
                    {
                        // Testing if two names are out of order
                        if (Color_FileName[Color_Name_iSAM[indexColor]] > Color_FileName[Color_Name_iSAM[indexColor + 1]])
                            FindingMyBugsColor += Abug(414, Color_FileName[Color_Name_iSAM[indexColor]], "<<==Color Name Not in order ==>", Color_FileName[Color_Name_iSAM[indexColor + 1]]);// unsorted color names
                    }
                }
                // Testing each to see if it is in order and returns correctly
                switch (MyCompared3(Color_FileName[Color_Name_iSAM[indexColor - 1]], Color_FileName[Color_Name_iSAM[indexColor]], Color_FileName[Color_Name_iSAM[indexColor + 1]]))
                {
                    case -5 // 9   -5 	A > C 'Unsorted List
                        :
                    {
                        FindingMyBugsColor += Abug(415, "color table is out of order === ", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}");
                        break;
                    }

                    case -4 // beginning of the list so ignore it
                        :
                    {
                        // 5   -4 	A=nothing And b< C
                        // 7   -4 	A=Nothing
                        if (!Information.IsNothing(Color_FileName[Color_Name_iSAM[indexColor - 1]]))
                            FindingMyBugsColor += Abug(416, "Color Table is out of order ===", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}");// color table is out of order
                        break;
                    }

                    case -3 // 11  -3	    A>b List out of order
                        :
                    {
                        FindingMyBugsColor += Abug(417, "Color Table is out of order ===", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}"); // color table is out of order
                        break;
                    }

                    case -2 // 12  -2 	b > C List is out of order
                        :
                    {
                        FindingMyBugsColor += Abug(418, "Color Table is out of order ===", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}");// color table is out of order
                        break;
                    }

                    case -1 // 3   -1	    A=b
                        :
                    {
                        FindingMyBugsColor += Abug(419, "Color Table  has a duplicate", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}");// color table should never have a duplicate
                        break;
                    }

                    case 0  // they are equal , which they should never be.  only one name allowed per data type
                        :
                    {
                        break;
                    }

                    case 1 // 4   1  	b=C  Color Table Should never have a duplicate
                        :
                    {
                        FindingMyBugsColor += Abug(421, "Color Table has a duplicate ===", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}");
                        break;
                    }

                    case 2                        // 14  2  	A < b The list is ok, so ignore it
                        :
                    {
                        break;
                    }

                    case 3                        // 13  3	    b < C The list is ok, so ignore it
                        :
                    {
                        break;
                    }

                    case 4// end of the list so Ignore it
                        :
                    {
                        break;
                    }

                    case 5 // IndexColor = null Which is not a bug if -1 or +1 is also null
                        :
                    {
                        FindingMyBugsColor += Abug(422, "The Color Table is out of Order ===", indexColor, "{" + Color_FileName[Color_Name_iSAM[indexColor - 1]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor]] + "} < {" + Color_FileName[Color_Name_iSAM[indexColor + 1]] + "}");
                        break;
                    }
                }
            }
        }



        // You ask why are you doing this instead of just a if a = b then
        // 'well I dont have an answer for you ( I guess that I just like to pop things to the stacek
        // (Except that it is easier to put a break point at the return false part to catch this issue
        bool IsTheDropDownText_TheSameAs_TheSelectedText(bool FixIt, string A, ToolStripDropDownButton B)
        {
            if (A == B.Text)
                return true;
            if (FixIt == true)
            {
                if (IsNothing(B.Text))
                {
                    Abug(424, "Selection is B blank", HighLight(A.ToString()), HighLight(B.Text));
                    SelectInToolStripDropDownButton(B, A);
                    return true; // cause it is equal now.
                }
                else if (Information.IsNothing(A))
                {
                    Abug(425, "Selection A is blank", HighLight(A.ToString()), HighLight(B.Text));
                    A = B.Text;
                    return true;
                }
            }
            else
                Abug(426, "Selection and drop downs do not match", HighLight(A.ToString()), HighLight(B.Text));
            return false;
        }



        // find issues with any thing related to the drop downs
        long FindingMyBugsDropDowns()
        {
            long IndexDropDown;
            long Temp1, Temp2;
            if (MyOptionTest(31) == false)
                return 0;


            // need to make sure that they are the same as the dropdown text
            // This is breaking my own rules of not changeing anything in the finding my bugs() not changing anything
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedColor, SymbolScreen.ToolStripDropDownButtonColor) == false)
                Abug(427, "Color", " Not selected correctly.", "");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedDataType, SymbolScreen.ToolStripDropDownDataType) == false)
                Abug(428, "datatype", " Not selected correctly.", "");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedInputOutput, SymbolScreen.ToolStripDropDownInputOutput) == false)
                Abug(429, "intput output r", " Not selected correctly.", "");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedRotation, SymbolScreen.ToolStripDropDownRotation) == false)
                Abug(431, "Rotation", " Not selected correctly.", "");

            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref FlowChartScreen.ToolStripDropDownSelectSymbol.Text, SymbolScreen.ToolStripDropDownSelectSymbol) == false)
                Abug(432, "flowchart screen selected symbol  does not match symbol screen selected symbol ", HighLight(FlowChartScreen.ToolStripDropDownSelectSymbol.Text), HighLight(SymbolScreen.ToolStripDropDownSelectSymbol.Text));
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedSymbolName, SymbolScreen.ToolStripDropDownSelectSymbol) == false)
                Abug(433, "symbol ", " Not selected correctly.", " on the symbol screen");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedSymbolName, FlowChartScreen.ToolStripDropDownSelectSymbol) == false)
                Abug(434, "symbol ", " Not selected correctly.", " on the flowchart screen");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedPathStart, SymbolScreen.ToolStripDropDownPathStart) == false)
                Abug(435, "path start", " Not selected correctly.", "");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedPathEnd, SymbolScreen.ToolStripDropDownPathEnd) == false)
                Abug(436, "path end ", " Not selected correctly.", "");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedPathLineStyle, SymbolScreen.ToolStripDropDownPathLineStyle) == false)
                Abug(437, "path line style ", " Not selected correctly.", "");
            if (IsTheDropDownText_TheSameAs_TheSelectedText(false, ref MyUniverse.ProgramOptions.SelectedNumberOfBytes, SymbolScreen.ToolStripDropDownNumberOfBytes) == false)
                Abug(438, "number of bytes", " Not selected correctly.", "");

            // they are not
            // Assume that the two drop down list are sorted              !!!!!!!!!!!!!

            FindingMyBugsDropDowns = 0;
            if (SymbolScreen.Visible == true)
            {
                for (IndexDropDown = 1; IndexDropDown <= SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1; IndexDropDown++)
                {
                    if (SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text == SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown - 1).Text)
                        FindingMyBugsDropDowns += Abug(439, "Duplicate Symbol name in the startscreen", SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text, "");
                }
                if (SymbolScreen.ToolStripButtonAddLine.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonAddPoint.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonDelete.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonFlowChartForm_FromSymbolScreen.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonMove.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonNewSymbol.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonOptionForm_FromSymbolScreen.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripButtonUpdateSymbol.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownButtonColor.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownDataType.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownInputOutput.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownLineWidth.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownNumberOfBytes.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownPathEnd.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownPathStart.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownPathLineStyle.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownRotation.Enabled == false)
                {
                }
                if (SymbolScreen.ToolStripDropDownSelectSymbol.Enabled == false)
                {
                }


                // TODO make sure that the two list match
                Temp1 = FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count;
                Temp2 = SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count;
                if (Temp1 != Temp2)
                {
                    if (LCase(Trim(SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text)) != LCase(Trim(FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text)))
                        FindingMyBugsDropDowns += Abug(441, "FlowChartScreen Screen and Symbol Screen does not have the same symbol list. " + HighLight(IndexDropDown.ToString()), HighLight(LCase(Trim(SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))) + Len(LCase(Trim(SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))).ToString, HighLight(LCase(Trim(FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))) + Len(LCase(Trim(FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text))));
                }
            }

            if (FlowChartScreen.Visible == true)
            {
                for (IndexDropDown = 1; IndexDropDown <= FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Count - 1; IndexDropDown++)
                {
                    if (FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text == FlowChartScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown - 1).Text)
                        FindingMyBugsDropDowns += Abug(442, "Duplicate Symbol name in the FlowChart screen", SymbolScreen.ToolStripDropDownSelectSymbol.DropDownItems.Item(IndexDropDown).Text, "");
                }
                if (FlowChartScreen.ToolStripButtonAddConstant.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonAddPath.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonDeleteobject.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonMoveObject.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonOpenForm.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonOptionForm.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonRedraw.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonSymbolForm.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonZoomIn.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripButtonZoomOut.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripTextBoxMyInputText.Enabled == false)
                    ainfo2(10);
                if (FlowChartScreen.ToolStripFlowChart.Enabled == false)
                    ainfo2(10);
            }
        }


        long FindingMyBugsNamed()
        {
            long IndexNamed, Jndex;
            long flag;

            FindingMyBugsNamed = 0;
            if (MyOptionTest(31) == false)
                return;
            // *************************************************************
            for (IndexNamed = 1; IndexNamed <= Named_TableCount; IndexNamed++)
            {
                Jndex = IndexNamed - 1;
                if (Jndex > 0)
                {
                    if (Named_TableSymbolName(Jndex) == Named_TableSymbolName(IndexNamed))
                        FindingMyBugsNamed += Abug(443, "Two symbols with the name name", MyShowNamed(Jndex), MyShowNamed(Jndex));
                }

                FindingMyBugsPoints(Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed]));
                // Check for two names in the named file
                if (PrintAbleNull(Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed])) != "_")
                {
                    if (PrintAbleNull(Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed + 1])) != "_")
                    {
                        if (Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed]) >= Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed + 1]))
                            FindingMyBugsNamed += Abug(444, "The Named Table is out of order at " + IndexNamed + " and " + IndexNamed + 1, Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed]), Named_TableSymbolName(Named_FileSymbolName_iSAM[IndexNamed + 1]));
                    }
                }

                // Check for two syntax's being the same 
                if (Strings.Len(Named_TableSintax(IndexNamed)) > 1)
                {
                    for (Jndex = IndexNamed + 1; Jndex <= Named_TableCount; Jndex++) // From the one in the list to the end
                    {
                        if (Named_TableSymbolName(IndexNamed) == Named_TableSymbolName(Jndex))
                            FindingMyBugsNamed += Abug(445, "Two symbols with the name name", MyShowNamed(IndexNamed), MyShowNamed(Jndex));
                        if (Named_TableSintax(IndexNamed) == Named_TableSintax(Jndex))
                        {
                            FindingMyBugsNamed += Abug(446, "Two Symbols with the same syntax ", MyShowNamed(IndexNamed), MyShowNamed(Jndex));
                            MyDoEvents();
                        }
                    }
                }

                // Check for being two Isam's being the same 
                if (Named_FileSymbolName_iSAM[IndexNamed + 1] != 0 & Named_FileSymbolName_iSAM[IndexNamed + 1] == Named_FileSymbolName_iSAM[IndexNamed])
                    FindingMyBugsNamed += Abug(447, "Isam has two index to the same name", MyShowNamed(IndexNamed), MyShowNamed(IndexNamed + 1));

                flag = 0;
                for (Jndex = 1; Jndex <= Named_TableCount; Jndex++)
                {
                    if (Jndex != IndexNamed)
                    {
                        if (Named_FileSymbolName_iSAM[IndexNamed] == Named_FileSymbolName_iSAM[Jndex])
                        {
                            FindingMyBugsNamed += Abug(448, "Named iSam has  " + flag.ToString() + " duplicated index's at: ", MyShowNamed(IndexNamed), MyShowNamed(Jndex));
                            flag += 1;
                        }
                    }
                }

                // Tell how many are duplicated ' Extra
                if (Flag > 0)
                    FindingMyBugsNamed += Abug(449, "Number of times the index's are duplicated", flag, flag);
            }
        }

        long FindingMyBugsKeyWord(string What, string[] MyArray)
        {
            long IndexKeyWord; // Index, 
            string Status;

            FindingMyBugsKeyWord = 0;
            if (MyOptionTest(31) == false)
                return;
            // *************************************************************
            // Check keyWord, Operator and Function
            for (IndexKeyWord = Information.LBound(MyArray) + 1; IndexKeyWord <= Information.UBound(MyArray) - 1; IndexKeyWord++)
            {
                if (PrintAbleNull(MyArray[IndexKeyWord]) != "_")
                {
                    if (MyArray[IndexKeyWord - 1] == MyArray[IndexKeyWord])
                        FindingMyBugsKeyWord += Abug(451, "Program Duplication of key word", IndexKeyWord, HighLight(MyArray[IndexKeyWord - 1]) + HighLight(MyArray[IndexKeyWord]));
                    if (MyArray[IndexKeyWord - 1] > MyArray[IndexKeyWord])
                        FindingMyBugsKeyWord += Abug(452, "Program out of order of key word", IndexKeyWord, HighLight(MyArray[IndexKeyWord - 1]) + HighLight(MyArray[IndexKeyWord]));
                }
                else
                {
                    FindingMyBugsKeyWord += Abug(453, "Void keyword " + IndexKeyWord.ToString(), HighLight(ThisIsAWhat(MyArray[IndexKeyWord])), What);
                    return;
                }

                Status = ThisIsAWhat(MyArray[IndexKeyWord]);
                if (Status != What)
                    FindingMyBugsKeyWord += Abug(454, "Program keyword error >" + MyArray[IndexKeyWord] + "< is not found as an keyword type " + HighLight(What), MyArray[IndexKeyWord], "but thinks is a  " + ThisIsAWhat(MyArray[IndexKeyWord]));
                else if (Strings.Len(Status) != 0)
                {
                }
                else
                    FindingMyBugsKeyWord += Abug(455, HighLight(Status), HighLight(ThisIsAWhat(MyArray[IndexKeyWord])), What + " : " + HighLight(MyArray[IndexKeyWord]));
            }
        }



        long FindingMyBugsPath(long IndexFlowChart)
        {
            long Idex, Jdex, KDex;
            long IndexNamed, IndexSymbol, IndexDataType, IndexNet;
            string Temp;
            FindingMyBugsPath = 0;
            if (MyOptionTest(31) == false)
                return;

            if (FlowChart_TableCode(IndexFlowChart) != "/path")
            {
                FindingMyBugsPath += Abug(456, "This is not a /path", MyShowFlowChartRecord(IndexFlowChart), "");
                return;
            }
            // Check if symbol exist
            IndexSymbol = Named_TableSymbolIndexes(IndexNamed); // Error should be caught in FindingMyBugsNamed()
            IndexDataType = FindDataTypeIndex(FlowChart_File_DataType[IndexFlowChart]);
            if (InvalidIndex(IndexDataType, DataType_FileName) == true)
                FindingMyBugsPath += Abug(457, "Not a valid datatype", MyShowFlowChartRecord(IndexFlowChart), "");

            // Not testing this for now.
            // todo this if this is valid pathlinks or compiled macro code 
            // FlowChart_FilePathLinks_And_CompiledMacroCodeText(IndexFlowChart )


            KDex = FindLowerXY(FlowChart_iSAM_X1[IndexFlowChart], FlowChart_iSAM_X1, FlowChart_FileX1, "ISAM X1", FlowChart_TableX1(FlowChart_iSAM_X1[IndexFlowChart]));
            KDex = FindLowerXY(FlowChart_iSAM_Y1[IndexFlowChart], FlowChart_iSAM_Y1, FlowChart_FileY1, "ISAM Y1", FlowChart_TableY1(FlowChart_iSAM_X1[IndexFlowChart]));
            KDex = FindLowerXY(FlowChart_iSAM_X2[IndexFlowChart], FlowChart_iSAM_X2, FlowChart_File_X2_Rotation, "ISAM X2", FlowChart_TableX2(FlowChart_iSAM_X1[IndexFlowChart]));
            KDex = FindLowerXY(FlowChart_iSAM_Y2[IndexFlowChart], FlowChart_iSAM_Y2, FlowChart_File_Y2_Option, "ISAM Y2", FlowChart_TableX1(FlowChart_iSAM_Y2[IndexFlowChart]));

            // ?Idex = FlowChart_iSAM_Name(IndexFlowChart )

            // todo check if valid datatype
            IndexNet = FindIndex_In_TableNetLinks(IndexFlowChart);

            if (IndexNet != 0)
            {
                if (FlowChart_TableCode(IndexFlowChart) == "/path")
                {
                    if (Net_FileNames[IndexNet] != FlowChart_FilePathSymbolName[IndexFlowChart])
                        Abug(458, "The path name is not in the link list " + IndexFlowChart + ":" + IndexNet, MyShowFlowChartRecord(IndexFlowChart), MyShowNetLnks(IndexNet));
                }
                Temp = NoFD(Net_TableLinks(IndexNet));
                Idex = PopNonZeroValue(ref Temp);
                if (Idex != 0)
                {
                    while (Strings.Len(Temp) > 0)
                    {
                        Temp = NoFD(Temp);
                        Jdex = PopNonZeroValue(ref Temp);
                        if (Jdex != 0)
                        {
                            if (FindingMyBugsCheckNet_TableLinks(Idex, Jdex) == true)
                                AInfo(767, " Paths connected", MyShowFlowChartRecord(Idex), MyShowFlowChartRecord(Jdex));
                            else
                            {
                                Abug(459, "Paths are not connected ", MyShowFlowChartRecord(Idex), MyShowFlowChartRecord(Jdex));
                                return 0;
                            }
                        }
                        else
                            Abug(461, "Invalid index number " + ShortHighLight(Net_TableLinks(IndexNet)), Idex, Jdex);
                    }
                }
                else
                    Abug(462, "Invalid index1 ", Idex, "");
            }
            else
            {
            }
        }


        // Is there a path from A to B?
        bool FindingMyBugsCheckNet_TableLinks(long IndexFlowChart1, long IndexFlowChart2)
        {
            long IndexNetLinks1, IndexNetLinks2;
            MyLineStructure xy1, xy2;

            // First make sure they are both paths being passed.
            if (FlowChart_TableCode(IndexFlowChart1) == "/error")
                return false;
            if (FlowChart_TableCode(IndexFlowChart2) == "/error")
                return false;

            if (FlowChart_TableCode(IndexFlowChart1) == "/unknown")
                return false;
            if (FlowChart_TableCode(IndexFlowChart2) == "/unknonw")
                return false;


            IndexNetLinks1 = FindIndex_In_TableNetLinks(IndexFlowChart1);
            IndexNetLinks2 = FindIndex_In_TableNetLinks(IndexFlowChart2);
            // Find the distance between them.
            xy1 = FlowChart2Line(IndexFlowChart1);
            xy2 = FlowChart2Line(IndexFlowChart2);
            if (ROUTERPointsMatch(ROUTERCheckLinesEndAtEachOther(xy1, xy2), ZeroZero) == true)
                return false;
            else
                return true;
        }


        MyPointStructure ROUTERCheckLinesEndAtEachOther(MyLineStructure XY1, MyLineStructure XY2)
        {
            if (XY1.a.Xx == XY2.a.Xx)
            {
                if (XY1.a.Yy == XY2.a.Yy)
                    return MyPoint1XY(XY1.a.Xx, XY1.a.Yy);
            }
            if (XY1.a.Xx == XY2.b.Xx)
            {
                if (XY1.a.Yy == XY2.b.Yy)
                    return MyPoint1XY(XY1.a.Xx, XY1.a.Yy);
            }
            if (XY1.b.Xx == XY2.a.Xx)
            {
                if (XY1.b.Yy == XY2.a.Yy)
                    return MyPoint1XY(XY1.b.Xx, XY1.b.Yy);
            }
            if (XY1.b.Xx == XY2.b.Xx)
            {
                if (XY1.b.Yy == XY2.b.Yy)
                    return MyPoint1XY(XY1.b.Xx, XY1.b.Yy);
            }
            return ZeroZero;
        }


        // search backwards until you are below ?
        long FindLowerXY(long Idex, long[] MyISam, long[] MyArray, string ErrorMessage, long ValueTofindBelow)
        {
            if (Idex >= 1)
                FindLowerXY = MyISam[Idex - 1]; // We are searching for one lower then the current selected index
            else
                FindLowerXY = Information.UBound(MyISam);

            do
            {
                while (InvalidIndex(FindLowerXY, FlowChart_FilePathSymbolName) == false & FlowChart_TableCode(FindLowerXY) != "/path")
                {
                    // make sure that the next on is not this one.
                    if (Idex != MyISam[FindLowerXY - 1])
                        FindLowerXY = MyISam[FindLowerXY - 1];
                    else
                    {
                        AInfo1(768, " Should we jump over this one and try again?", Idex.ToString(), MyISam[FindLowerXY - 1].ToString());
                        return FindIndex1(MyISam);
                    }
                }

                if (FindLowerXY < 1)
                    return FindIndex1(MyISam);
                FindLowerXY = MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                switch (MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex))
                {
                case -10:
                case -9:
                case -8:
                case -7:
                case -6:
                {
                    Abug(463, MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex) + ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    break;
                }

                case -5:
                {
                    if (FindLowerXY < 1)
                        return FindIndex1(MyISam);
                    return FindLowerXY;
                }

                case -4:
                {
                    Abug(464, MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex) + ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case -3:
                {
                    Abug(465, MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex) + ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case -2:
                {
                    Abug(466, ErrorMessage, MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex) + MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case -1:
                {
                    return FindLowerXY;
                }

                case 0:
                {
                    // the two are equal
                    if (InvalidIndex(FindLowerXY, FlowChart_FilePathSymbolName) == true)
                        return FindIndex1(MyISam);
                    else if (InvalidIndex(MyISam[FindLowerXY - 1], FlowChart_FilePathSymbolName) == true)
                        return FindLowerXY;
                    else
                        FindLowerXY = MyISam[FindLowerXY - 1];
                    break;
                }

                case 1:
                {
                    if (InvalidIndex(FindLowerXY, FlowChart_FilePathSymbolName))
                        return FindIndex1(MyISam);
                    if (InvalidIndex(MyISam[FindLowerXY], FlowChart_FilePathSymbolName) == true)
                        return FindLowerXY;
                    // So lets try farther back down the list
                    if (InvalidIndex(MyISam[FindLowerXY - 1], FlowChart_FilePathSymbolName) == true)
                        return FindLowerXY;
                    FindLowerXY = MyISam[FindLowerXY - 1];
                    break;
                }

                case 2:
                {
                    Abug(467, ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case 3:
                {
                    Abug(468, ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case 4:
                {
                    Abug(469, ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case 5:
                {
                    Abug(471, ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    MyCompared2(ref MyArray, ref MyISam, FindLowerXY, Idex);
                    break;
                }

                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                {
                    Abug(472, ErrorMessage, MyShowFlowChartRecord(FindLowerXY), MyShowFlowChartRecord(Idex));
                    break;
                }
                }
            } while (1 == 1)// back up to the path before this on.// hack this is never turned// usually an invalid index, but coube many things. (Or invalid pointer)// hack this is never turned// hack this is never turned// FindLowerXY.x1 is less than index.x1// hack (who knows where the lowest /path is?// fail safe hack// If we can go no farther back then this is it.// Greater so back up more (OK, This should never happend because the index for the flow chart should have been pointing to something that is aleast equal// hack this is never turned// hack this is never turned// hack this is never turned// hack this is never turned
                ; // forever loop
        }



        void MyAddErrorMessages()
        {
            string TS, TE;

            TS = MyUniverse.SysGen.Constants.RMStart;
            TE = MyUniverse.SysGen.Constants.RMEnd;


            OptionScreen.ComboBoxDebug.Items.Clear();
            // This routine just loads the error Test for the messages, 
            // {On or off to display msgbox()}
            // {The number of the message must be between 1,000-9,998}
            // {an option of 
            // "wrong"
            // "information"
            // "warning"
            // "error"
            // "display"
            // }
            // Then a  string of the error message where " & ts & "string1" & te & " ... will be replaced with what the routine passes.
            // also a few other special's such as " & ts & "routine" & te & " and " & ts & "tracer" & te & "
            MyErrorMessages("on", 1000, "Error", TS + "string1" + TE + Constants.vbCrLf + TS + "string2" + TE + Constants.vbCrLf + TS + "string3" + TE + Constants.vbCrLf + TS + "string4" + TE + Constants.vbCrLf + TS + "string5" + TE + Constants.vbCrLf + TS + "string6" + TE + Constants.vbCrLf + TS + "string7" + TE + Constants.vbCrLf + TS + "string8" + TE + Constants.vbCrLf + TS + "string9" + TE);
            MyErrorMessages("on", 1001, "Error", "Opening file requires write Or read. " + Constants.vbCrLf + "Programing error Not reading Or writing file " + Constants.vbCrLf + "File name >" + TS + "string2" + TE + "<  " + Constants.vbCrLf + "trying to >" + TS + "string1" + TE + "< which Is Not read Or write");
            // MyErrorMessages("on", 1002, "Warning", "Checked if the two strings in the list are in iSAM order low >" & ts & "string2" & te & "<  high >" & ts & "string1" & te & "<")
            MyErrorMessages("on", 1003, "display", "Step " + TS + "string9" + TE + ": At Indexs " + TS + "string1" + TE + " and " + TS + "string2" + TE + " shows a code " + TS + "string3" + TE + ". The iSAMs out of order >" + TS + "string4" + TE + "<  high >" + TS + "string5" + TE + "<");
            // MyErrorMessages("on", 1004, "Warning", "Checked if the two strings in the list are in iSAM order low >" & ts & "string2" & te & "<  high >" & ts & "string1" & te & "<")
            // MyErrorMessages("on", 1005, "Error", "Sorting did Not work! And the array Is wrong!")
            MyErrorMessages("on", 1006, "Error", "Sorting did Not work! And the array Is wrong!");
            // MyErrorMessages("on", 1007, "Error", "Array length Is " & TS & "string1" & TE & " " & vbCrLf & "iSAM array length Is " & TS & "string2" & TE & vbCrLf & " The array And the iSAM array are differant sizes!")
            // MyErrorMessages("on", 1008, "Display", "Checked if the two strings in the list:" & vbCrLf & " are in iSAM order >" & TS & "string2" & TE & "<< >" & TS & "string1" & TE & "<")
            // MyErrorMessages("on", 1009, "Information", "Compile Finished to file>" & TS & "string1" & TE & "< ")
            // MyErrorMessages("on", 1010, "Information", "Syntax made for symbol " & ts & "string3" & te & vbCrLf & "syntax = " & ts & "string2" & te & " " & vbCrLf & "  code = " & ts & "string1" & te & vbCrLf & "  path = " & ts & "string4" & te & vbCrLf & " Symbol Index " & ts & "string5" & te & " " & vbCrLf & " Named index " & ts & "string6" & te)
            MyErrorMessages("on", 1011, "Error", "The Isam is zero, and there is data in the number array Index=" + TS + "string1" + TE + " Isam(index) =" + TS + "string2" + TE + "  Array(index) = " + TS + "string3" + TE);
            MyErrorMessages("on", 1012, "Error", "The found (+0) " + TS + "string1" + TE + " with the iSAM Indexes " + TS + "string2" + TE + " should match" + Constants.vbCrLf + "The two strings are:" + Constants.vbCrLf + ">" + TS + "string3" + TE + "<" + Constants.vbCrLf + ">" + TS + "string4" + TE + "<");
            MyErrorMessages("on", 1013, "Error", "A value Is added to the list with a null before And after " + Constants.vbCrLf + "(-1)" + TS + "string1" + TE + " >" + TS + "string2" + TE + "<" + Constants.vbCrLf + "(+0)" + TS + "string3" + TE + " >" + TS + "string4" + TE + "<" + Constants.vbCrLf + "(+1)" + TS + "string5" + TE + " >" + TS + "string6" + TE + "<" + Constants.vbCrLf + "." + Constants.vbCrLf + "Checking in routine " + TS + "string8" + TE + " called from " + TS + "routine" + TE + " tracer " + TS + "tracer" + TE);
            // MyErrorMessages("on", 1014, "information", "Trying to find >" & TS & "string1" & TE & "<  At index " & TS & "string2" & TE)
            // MyErrorMessages("on", 1015, "Status", "Checking paths at " & TS & "string1" & TE & "  >" & TS & "string6" & TE & "< (" & TS & "string2" & TE & FD & TS & "string3" & TE & ")_(" & TS & "string4" & TE & FD & TS & "string5" & TE & ")")
            // MyErrorMessages("on", 1016, "Information", "Resorting with  Bubble Sorting " & vbCrLf & " at " & TS & "string1" & TE & "  (+0) " & TS & "string2" & TE & " swapped higher >" & TS & "string3" & TE & "< " & vbCrLf & " at " & TS & "string4" & TE & " with (+0) " & TS & "string5" & TE & " " & vbCrLf & "lower >" & TS & "string6" & TE & "<")
            // MyErrorMessages("on", 1017, "Warning", TS & "string1" & TS & "string2" & TE & " " & TS & "string3" & TS & "string4" & TE & " " & TS & "string5")
            // MyErrorMessages("on", 1018, "Error", "We are adding iSAM to a record that has a Differant iSAM causing an Error " & TS & "string1" & TE)
            MyErrorMessages("on", 1019, "Error", "The array Is wrong!  " + Constants.vbCrLf + "So we are bubble sorting the array instead of quick sorting it.");
            // MyErrorMessages("on", 1020, "Warning", "Swapping >" & TS & "string3" & TE & "< with >" & TS & "string2" & TE & "< " & vbCrLf & "at (+0)s " & TS & "string5" & TE & ", " & TS & "string4" & TE & "  " & vbCrLf & "iSAMs " & TS & "string7" & TE & ", " & TS & "string6" & TE & "  ")
            // MyErrorMessages("on", 1021, "Error", "Symbol Name Not Found " & TS & "string1" & TE)
            MyErrorMessages("on", 1022, "Error", "pathlinks Array Boundries has been exceded  low=" + TS + "string1" + TE + " < at=" + TS + "string2" + TE + " < top=" + TS + "string3" + TE + " in list of numbers  ?=" + TS + "string4" + TE + "");
            MyErrorMessages("on", 1023, "Warning", "two flowchart items are on top of each other" + TS + "string1" + TE + TS + "string2" + TE);
            // MyErrorMessages("on", 1024, "Warning", "Can Not add to enum list in " & vbCrLf & "List Name >" & TS & "string1" & TE & "< " & vbCrLf & "Number = " & TS & "string2" & TE & "  " & vbCrLf & "ItemNumber offset " & TS & "string3" & TE)
            // Not Used 1025
            // not used 1026
            MyErrorMessages("on", 1027, "Information", "At Index's = " + TS + "string1" + TE + " & " + TS + "string2" + TE + Constants.vbCrLf + "Swapping iSAM's " + TS + "string3" + TE + " & " + TS + "string4" + TE + Constants.vbCrLf + "With Strings >" + TS + "string5" + TE + "< & >" + TS + "string6" + TE + "<" + Constants.vbCrLf + "Same values being swapped");
            // MyErrorMessages("on", 1028, "Information", "Get (+0) " & TS & "string2" & TE & vbCrLf & "Macro Code Text = >" & TS & "string1" & TE & "<")
            MyErrorMessages("on", 1029, "Information", "Testing distances betweeen points " + Constants.vbCrLf + "(" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")" + Constants.vbCrLf + "(" + TS + "string3" + TE + ", " + TS + "string4" + TE + ")" + Constants.vbCrLf + "(" + TS + "string5" + TE + ", " + TS + "string6" + TE + ")" + Constants.vbCrLf + "Index=" + TS + "string7" + TE + Constants.vbCrLf + "distance 1 =" + TS + "string8" + TE + Constants.vbCrLf + "distance 2 =" + TS + "string9" + TE);
            MyErrorMessages("on", 1030, "Display", "NOT Compiling code " + TS + "string1" + TE + " : " + TS + "string2" + TE + " : " + TS + "string3" + TE);
            MyErrorMessages("on", 1031, "Display", "NOT Compiling code " + TS + "string1" + TE + " : " + TS + "string2" + TE + " : " + TS + "string3" + TE);
            MyErrorMessages("on", 1032, "Display", "Starting to re-paint at " + TS + "string1" + TE + " " + Constants.vbCrLf + "ending at " + TS + "string2" + TE + " " + Constants.vbCrLf + "Number to draw " + TS + "string3" + TE);
            // Not Used 1033
            // 1034
            MyErrorMessages("on", 1035, "Error", "Because there is no / " + Constants.vbCrLf + "Testing for change of link " + TS + "string1" + TE + " " + Constants.vbCrLf + ">" + TS + "string2" + TE + "<  " + Constants.vbCrLf + ">" + TS + "string3" + TE + "< ");
            MyErrorMessages("on", 1036, "Error", "Because there is no / " + Constants.vbCrLf + "Testing for change of link " + TS + "string1" + TE + " " + Constants.vbCrLf + ">" + TS + "string2" + TE + "<  " + Constants.vbCrLf + ">" + TS + "string3" + TE + "< ");
            // MyErrorMessages("on", 1037, "Information", " Making up Named " & ts & "string1" & te & " symbol at " & ts & "string3" & te & " code " & ts & "string2" & te & " with first path " & ts & "string9" & te)
            // MyErrorMessages("on", 1038, "Information", "Finding Point at symbol table code >" & TS & "string1" & TE & "< " & vbCrLf & "Index " & TS & "string2" & TE & " " & vbCrLf & "searching for closest points to (" & TS & "string3" & TE & FD & TS & "string4" & TE & ").")
            // MyErrorMessages("on", 1039, "Information", "Binary find point at symbol table code >" & TS & "string1" & TE & "< " & vbCrLf & " XY (" & TS & "string3" & TE & FD & TS & "string4" & TE & ")   " & vbCrLf & "(+0)=" & TS & "string5" & TE & "  " & vbCrLf & "CurrentIndexOffset " & TS & "string6" & TE)
            // Not Used 1040
            // Not Used 1041
            // Not Used 1042
            // Not Used 1043
            // Not Used 1044
            // Not Used 1045
            // Not Used 1046
            // Not Used 1047
            // MyErrorMessages("on", 1048, "Error", "Color Not Defined >" & TS & "string1" & TE & "< with datatype >" & TS & "string2" & TE & "< at index " & TS & "string3" & TE & " at line number " & TS & "string4" & TE & "  changed to " & TS & "string5" & TE)
            // Not Used 1049
            // Not Used 1050
            // Not Used 1051
            // Not Used 1052
            MyErrorMessages("on", 1053, "Warning", "Swapping >" + TS + "string1" + TE + "< " + Constants.vbCrLf + "with     >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "at (-1) " + TS + "string3" + TE + ", " + TS + "string4" + TE + "  " + Constants.vbCrLf + "iSAM " + TS + "string5" + TE + ", " + TS + "string6" + TE + Constants.vbCrLf + "Number of swaps made = " + TS + "string9" + TE);
            MyErrorMessages("on", 1054, "Error", "Added at (2) before (1) in table ?? added " + TS + "string2" + TE);
            // Not Used 1055
            // Not Used 1056
            // Not Used 1057
            // Not Used 1058
            MyErrorMessages("on", 1059, "Information", "Inserting = >" + TS + "string9" + TE + "<  into Symbols Table " + Constants.vbCrLf + "Macro Code Text = = >" + TS + "string1" + TE + "< " + Constants.vbCrLf + "named = >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "Point Name =>" + TS + "string3" + TE + "< " + Constants.vbCrLf + "X1=" + TS + "string4" + TE + ", " + Constants.vbCrLf + "Y1=" + TS + "string5" + TE + ", " + Constants.vbCrLf + "X2=" + TS + "string6" + TE + ", " + Constants.vbCrLf + "Y2=" + TS + "string7" + TE);
            MyErrorMessages("on", 1060, "Error", " not able to return from list >" + TS + "string1" + TE + "<" + Constants.vbCrLf + "inside the " + TS + "string2" + TE + " list");
            MyErrorMessages("on", 1061, "Information", "swap  >" + TS + "string1" + TE + "< with >" + TS + "string2" + TE + "<");
            // Not Used 1062
            // Not Used 1063
            // Not Used 1064
            // Not Used 1065
            // Not Used 1066
            // Not Used 1067
            // Not Used 1068
            // Not Used 1069
            // Not Used 1070
            // Not Used 1071
            // Not Used 1072
            // Not Used 1073
            // Not Used 1074
            // Not Used 1075
            // Not Used 1076
            // Not Used 1077
            // Not Used 1078
            // Not Used 1079
            // Not Used 1080
            // Not Used 1081
            // Not Used 1082
            // Not Used 1083
            // Not Used 1084
            // Not Used 1085
            // Not Used 1086
            // Not Used 1087
            // Not Used 1088
            MyErrorMessages("on", 1089, "Information", "Find the closest (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ") to start at (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")");
            MyErrorMessages("on", 1090, "Information", "Find the one and only START symbol");
            // Not Used 1091
            MyErrorMessages("on", 1092, "Information", "get the " + TS + "string3" + TE + " point at (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")");
            MyErrorMessages("on", 1093, "Information", "get the " + TS + "string3" + TE + " point from a symbol point at (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ") ");
            MyErrorMessages("on", 1094, "Information", "get a symbol at (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ") with a direction of " + TS + "string3" + TE);
            MyErrorMessages("on", 1095, "Information", " testing if this point is outside the screen area (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")_(" + TS + "string3" + TE + ", " + TS + "string4" + TE + ")");
            // MyErrorMessages("on", 1096, "warning", "Drawing nothing is ignored at (+0) " & TS & "string1" & TE)
            // Not Used 1097
            MyErrorMessages("on", 1098, "Information", " Snap point (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ") to be on a " + TS + "string3" + TE + " grid");
            // Not Used 1099
            MyErrorMessages("on", 1100, "Error", "Added this symbol >" + TS + "string1" + TE + "< and then could not find it again Line Number =" + TS + "string2" + TE + " >" + TS + "string3" + TE);
            MyErrorMessages("on", 1101, "Information", "Exporting to file: >" + TS + "string1" + TE + "< ");
            // Not Used 1102
            MyErrorMessages("on", 1103, "Information", "Move the symbol and all of the paths at index " + TS + "string3" + TE + " " + Constants.vbCrLf + "a distance of :(" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")");
            // MyErrorMessages("on", 1104, "Information", ts & "string1" & te & FD & ts & "string2" & te & FD & ts & "string3" & te)
            // MyErrorMessages("on", 1105, "Information", "at Index =" & TS & "string1" & TE & " ,(" & TS & "string2" & TE & FD & TS & "string3" & TE & ")   and (" & TS & "string4" & TE & FD & TS & "string5" & TE & ")")
            // MyErrorMessages("on", 1106, "Information", "at Index =" & TS & "string1" & TE & " ,(" & TS & "string2" & TE & FD & TS & "string3" & TE & ")   and (" & TS & "string4" & TE & FD & TS & "string5" & TE & ")")
            // MyErrorMessages("on", 1107, "Information", "at Index =" & TS & "string1" & TE & " ,(" & TS & "string2" & TE & FD & TS & "string3" & TE & ")   and (" & TS & "string4" & TE & FD & TS & "string5" & TE & ")")
            // MyErrorMessages("on", 1108, "Information", "Finding point test for closest now " & TS & "string1" & TE)
            // MyErrorMessages("on", 1109, "Information", "found closer point " & vbCrLf & "new Distance" & TS & "string1" & TE & " " & vbCrLf & "Old Distance " & TS & "string2" & TE & " " & vbCrLf & "(+0)" & TS & "string3" & TE & " " & vbCrLf & "    (" & TS & "string4" & TE & FD & TS & "string5" & TE & ") " & vbCrLf & "and (" & TS & "string7" & TE & FD & TS & "string6" & TE & ")")
            // MyErrorMessages("on", 1110, "Information", "found closer point distances " & vbCrLf & "Distance " & TS & "string1" & TE & " to distance " & TS & "string2" & TE & " " & vbCrLf & "from old index " & TS & "string3" & TE & " to new index " & TS & "string4" & TE)
            // MyErrorMessages("on", 1111, "Information", "atXY= (" & TS & "string1" & TE & ", " & TS & "string2" & TE & ") , " & vbCrLf & "in XY1=(" & TS & "string3" & TE & ", " & TS & "string4" & TE & "), " & vbCrLf & "XY2=(" & TS & "string5" & TE & ", " & TS & "string6" & TE & ")  " & vbCrLf & "Index=" & TS & "string7" & TE)
            // MyErrorMessages("on", 1112, "Information", "Searching for Start or Main at Code= >" & TS & "string1" & TE & "< " & vbCrLf & "Name= >" & TS & "string2" & TE & "<" & vbCrLf & "index=" & TS & "string3" & TE)
            // MyErrorMessages("on", 1113, "Information", "Got symbol index=" & TS & "string1" & TE & " distance " & TS & "string2" & TE & "  " & vbCrLf & "xy=(" & TS & "string3" & TE & ", " & TS & "string4" & TE & ") " & vbCrLf & "List at=(" & TS & "string5" & TE & FD & TS & "string6" & TE & ") " & vbCrLf & "name=>" & TS & "string7" & TE & "<")
            // MyErrorMessages("on", 1114, "Error", ">" & TS & "string1" & TE & "< is an unknown command mode")
            // Not Used 1115
            // MyErrorMessages("on", 1116, "Information", "Not done Yet")
            MyErrorMessages("on", 1117, "Error", "I do not have anything in the case statement for a code type >" + TS + "string1" + TE + "< " + Constants.vbCrLf + "looking for /Path, /Use, /constant, /error");
            // MyErrorMessages("on", 1118, "Error", "Did not find a color or datatype =>" & TS & "string1" & TE & "<  ERROR CODE = " & TS & "string2" & TE)
            // MyErrorMessages("on", 1119, "Information", "Match to datatype >" & TS & "string1" & TE & "<")
            // MyErrorMessages("on", 1120, "Error", "Not matched to color name or dattype names =>" & TS & "string1" & TE & "<")
            // Not Used 1121
            // Not Used 1122
            // MyErrorMessages("on", 1123, "Error", "The index " & TS & "string1" & TE & " has index outside the range " & TS & "string2" & TE & " and " & TS & "string3" & TE & " in the iSAM Table. " & vbCrLf & TS & "string2" & TE & " < " & TS & "string1" & TE & " < " & TS & "string3" & TE)
            // Not Used 1124
            // Not Used 1125
            // Not Used 1126
            // Not Used 1127
            // Not Used 1128
            MyErrorMessages("on", 1129, "Error", "Invalid Index for iSAM Indexes   1 <= " + TS + "string1" + TE + "  <= " + TS + "string2" + TE);
            // MyErrorMessages("on", 1132, "Information", "at " & TS & "string1" & TE & " checking name >" & TS & "string2" & TE & "< " & "against " & TS & "string3" & TE & "     name >" & TS & "string4" & TE & "<")
            // Not Used 1133
            // Not Used 1134
            // Not Used 1135
            // MyErrorMessages("on", 1136, "Display", " Exporting Colors to file >" & TS & "string1" & TE & "<")
            // Not Used 1137
            // Not Used 1138
            // Not Used 1139
            // Not Used 1140
            // Not Used 1141
            // Not Used 1142
            // Not Used 1143
            // Not Used 1144
            // Not Used 1145
            // Not Used 1146
            // Not Used 1147
            // Not Used 1148
            // MyErrorMessages("on", 1149, "Display", "De-Compiling Source From file >" & TS & "string1" & TE & "<")
            // Not Used 1150
            // Not Used 1151
            // Not Used 1152
            // Not Used 1153
            // Not Used 1154
            // Not Used 1155
            // Not Used 1156
            // Not Used 1157
            // MyErrorMessages("on", 1158, "Error", "Invalid (+0) into Record List, (+0) less than One > " & TS & "string1" & TE & ".")
            // MyErrorMessages("on", 1159, "Error", "Expecting a /Use record And got a " & TS & "string1" & TE & " Instead.")
            // Not Used 1160
            // Not Used 1161
            // Not Used 1162
            MyErrorMessages("on", 1163, "Error", "Invalid Rotation =" + TS + "string1" + TE + "  named = >" + TS + "string2" + TE + "<.");
            MyErrorMessages("on", 1164, "Error", "There Is no name For this use record " + TS + "string1" + TE + ".  Record " + TS + "string2" + TE + " Has no name.");
            // Not Used 1165
            // Not Used 1166
            MyErrorMessages("on", 1167, "Error", "This should never happen  " + TS + "string1" + TE + " <> 0 And (1)" + TS + "string1" + TE + " = (2)" + TS + "string3" + TE + " ");
            MyErrorMessages("on", 1168, "Error", "The (+0) should never be zero " + TS + "string1" + TE);
            MyErrorMessages("on", 1169, "Error", "This should never happen (1)" + TS + "string1" + TE + " <> 0 And (1)" + TS + "string2" + TE + " = (2)" + TS + "string3" + TE + " ");
            // MyErrorMessages("on", 1170, "Wrong", "The index " & TS & "string1" & TE & " Of a number array should not bet zero " & TS & "string2" & TE & vbCrLf & ">" & TS & "string3" & TE & "<")
            // Not Used 1171
            // Not Used 1172
            // Not Used 1173
            // Not Used 1174
            // Not Used 1175
            // Not Used 1176
            // Not Used 1177
            // Not Used 1178
            // Not Used 1179
            // Not Used 1180
            // Not Used 1181
            // Not Used 1182
            MyErrorMessages("on", 1183, "Display", "Swapping >" + TS + "string1" + TE + "< " + Constants.vbCrLf + "with     >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "at (+0)s " + TS + "string3" + TE + ", " + TS + "string4" + TE + "  " + Constants.vbCrLf + "iSAMs " + TS + "string5" + TE + ", " + TS + "string6" + TE + "  " + Constants.vbCrLf + "Counter " + TS + "string9" + TE);
            // Not Used 1184
            // Not Used 1185
            // Not Used 1186
            // Not Used 1187
            // Not Used 1188
            MyErrorMessages("on", 1189, "Information", "The List has nothing at (+0) " + TS + "string1" + TE + " iSAM set to " + TS + "string2" + TE + Constants.vbCrLf + "FromRoutine=" + TS + "string2" + TE + " " + Constants.vbCrLf + "Tracer=" + TS + "string2" + TE + " ");
            // Not Used 1190
            // Not Used 1191
            // Not Used 1192
            // Not Used 1193
            // Not Used 1194
            // Not Used 1195
            // Not Used 1196
            // Not Used 1197
            // Not Used 1198
            // Not Used 1199
            // Not Used 1200
            // Not Used 1201
            // Not Used 1202
            // Not Used 1203
            // Not Used 1204
            // Not Used 1205
            // Not Used 1206
            // Not Used 1207
            // Not Used 1208
            // Not Used 1209
            // Not Used 1210
            MyErrorMessages("on", 1211, "ERROR", Constants.vbCrLf + "Line Number " + TS + "string1" + TE + Constants.vbCrLf + "Key word   = >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "input line =>" + TS + "string3" + TE + "< " + Constants.vbCrLf + "Unknown Information at line >" + TS + "string4" + TE + "<" + Constants.vbCrLf + "Line of unknown >" + TS + "string5" + TE + "<");
            MyErrorMessages("on", 1212, "Error", TS + "string1" + TE + " Do you want to add this color?" + Constants.vbCrLf + "Unknown Color :" + TS + "string2" + TE + " : " + TS + "string3" + TE);
            // Not Used 1213
            // MyErrorMessages("on", 1214, "Error", "Unable to run because there Is no symbol with the name START Or MAIN.  You need a symbol named 'start' or a symbol named 'main' in this program")
            MyErrorMessages("on", 1215, "Error", "Found a match when binary search failed to find it between >" + TS + "string1" + TE + "< AND >" + TS + "string2" + TE + "<");
            // Not Used 1216
            // Not Used 1217
            // Not Used 1218
            // Not Used 1219
            // Not Used 1220
            // Not Used 1221
            // Not Used 1222
            // Not Used 1223
            // Not Used 1224
            // Not Used 1225
            // Not Used 1226
            // Not Used 1227
            // Not Used 1228
            // Not Used 1229
            // Not Used 1230
            // Not Used 1231
            // Not Used 1232
            // Not Used 1233
            // MyErrorMessages("on", 1234, 
            // Not Used 1235
            // Not Used 1236
            // 1237
            // Not Used 1238
            // Not Used 1239
            // Not Used 1240
            // 1241
            // 1242
            // Not Used 1243
            // Not Used 1244
            // Not Used 1245
            // MyErrorMessages("on", 1246, "Information",  TS & "string1" & TE ) 'displays flowchart record
            MyErrorMessages("on", 1247, "Information", "status for index " + TS + "string1" + TE + " Index >" + TS + "string2" + TE + "< links >" + TS + "string3" + TE + "<");
            // used more than once!
            // MyErrorMessages("on", 1248, "Information", "Finding all paths connected together index  = " & TS & "string1" & TE & " links >" & TS & "string2" & TE & "<")
            // MyErrorMessages("on", 1249, "Information", "Finding all paths connected " & TS & "string1" & TE & " links >" & TS & "string2" & TE & "<" & TS & "string3" & TE)
            // MyErrorMessages("on", 1250, "Error", "The FlowChart index is greater than the maxiumn number of the records.  The FlowChart index of " & TS & "string1" & TE & ".  Is greater than the maximum number in the FlowChart array " & TS & "string2" & TE)
            // MyErrorMessages("on", 1251, "Error", "String exceeded " & ConstantCharterLength & " characters " & TS & "string1" & TE)
            // MyErrorMessages("on", 1252, "Warning", "Duplications in the list" & vbCrLf & "(-1)=" & TS & "string1" & TE & " iSAM points to =" & TS & "string2" & TE & "  Array()= >" & TS & "string3" & TE & "<" & vbCrLf & "(+0)=" & TS & "string4" & TE & " iSAM points to =" & TS & "string5" & TE & "  Array()= >" & TS & "string6" & TE & "<" & vbCrLf & "(+1)=" & TS & "string7" & TE & " iSAM points to =" & TS & "string8" & TE & "  Array()= >" & TS & "string9" & TE & "<")
            // MyErrorMessages("on", 1253, "Error", " at index " & TS & "string1" & TE & " Step" & TS & "string9" & TE & ": The iSAM Table is outside the {Min 1< " & TS & "string2" & TE & "  <" & TS & "string3" & TE & " Max}  Value >" & TS & "string4" & TE & "<")
            // MyErrorMessages("on", 1254, "Error", "Indexes out of bounds.  An index Indexes is out of bounds index -1 = " & TS & "string1" & TE & " :  at iSAM(-1) " & TS & "string2" & TE & " and (+0)" & TS & "string3" & TE & " at isam(+0) " & TS & "string4" & TE)
            // Not Used 1255
            // MyErrorMessages("on", 1256, "Error", "Invalid (+0) into Record List.  (+0) " & TS & "string1" & TE & " greater than maxinum Of array size " & TS & "string2" & TE & ".")
            MyErrorMessages("on", 1257, "Display", TS + "string1" + TE + " Swapping >" + TS + "string2" + TE + "< with >" + TS + "string3" + TE + "< at (+0)s " + TS + "string4" + TE + ", " + TS + "string5" + TE + "  iSAMs " + TS + "string6" + TE + ", " + TS + "string7" + TE);
            MyErrorMessages("on", 1258, "Display", TS + "string1" + TE + " Swapping >" + TS + "string2" + TE + "< with >" + TS + "string3" + TE + "< at (+0)s " + TS + "string4" + TE + ", " + TS + "string5" + TE + "  iSAMs " + TS + "string6" + TE + ", " + TS + "string7" + TE + "  at " + TS + "string1" + TE);
            // Not Used 1259
            MyErrorMessages("on", 1260, "ERROR", "Routine not written yet ! (Just returns True inside box )  (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")_(" + TS + "string3" + TE + ", " + TS + "string4" + TE + ")");
            // Not Used 1261
            // Not Used 1262
            // Not Used 1263
            MyErrorMessages("on", 1264, "Display", "no match found and nothing else >" + TS + "string1" + TE + "<, It was added, Function = " + TS + "string2" + TE);
            MyErrorMessages("on", 1265, "Warning", TS + "string1" + TE + "() Swapping >" + TS + "string3" + TE + "< with >" + TS + "string2" + TE + "< at (+0)s " + TS + "string5" + TE + ", " + TS + "string4" + TE + "  iSAMs " + TS + "string7" + TE + ", " + TS + "string6" + TE + "  at " + TS + "string1" + TE);
            MyErrorMessages("on", 1266, "Display", TS + "string1" + TE + "() Swapping >" + TS + "string2" + TE + "< with >" + TS + "string3" + TE + "< at (+0)s " + TS + "string4" + TE + ", " + TS + "string5" + TE + "  iSAMs " + TS + "string6" + TE + ", " + TS + "string7" + TE + "  at " + TS + "string1" + TE);
            // Not Used 1267
            // MyErrorMessages("on", 1268, "Error", "Unable to add the symbol name to the symbol name list >" & TS & "string1" & TE & "<")
            // MyErrorMessages("on", 1269, "Error", "Passed color name to get >" & TS & "string1" & TE & "< datatype color >" & TS & "string2" & TE & "< color using >" & TS & "string2" & TE & "<")
            MyErrorMessages("on", 1270, "Error", "Found a match when none found in binary search  >" + TS + "string1" + TE + "< looking for >" + TS + "string2" + TE + "<");
            // Not Used 1271
            // Not Used 1272
            MyErrorMessages("on", 1273, "Information", "Invalid Rotation Number " + TS + "string1" + TE + " Name >" + TS + "string2" + TE + "<");
            // Not Used MyErrorMessages("on", 1274, "Information", "(" & ts & "string1" & te & ", " & ts & "string2" & te & ") >" & ts & "string3" & te & "<")
            MyErrorMessages("on", 1275, "Information", "Sitting on top of each other at (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")");
            MyErrorMessages("on", 1276, "Error", "YouHaveAnErrorMessage() " + TS + "string1" + TE + " >" + TS + "string1" + TE + "<");
            // MyErrorMessages("on", 1278', "Error", "Trying to draw >" & TS & "string1" & TE & "<")
            // MyErrorMessages("on", 1279, "Error", "Error drawing p0int invalid code= >" & TS & "string1" & TE & "< name= >" & TS & "string2" & TE & "< Name of Point = >" & TS & "string3" & TE & "< ")
            MyErrorMessages("on", 1280, "Error", "Duplication in the list" + Constants.vbCrLf + "(-1)=" + TS + "string1" + TE + " iSAM points to =" + TS + "string2" + TE + "  Array()= >" + TS + "string3" + TE + "< " + Constants.vbCrLf + "(+0)=" + TS + "string4" + TE + " iSAM points to =" + TS + "string5" + TE + "  Array()= >" + TS + "string6" + TE + "< " + Constants.vbCrLf + "(+1)=" + TS + "string7" + TE + " iSAM points to =" + TS + "string8" + TE + "  Array()= >" + TS + "string9" + TE + "< ");
            // 1281
            // 1282
            MyErrorMessages("on", 1283, "Error", "Unknown command mode >" + TS + "string1" + TE + "<");
            // MyErrorMessages("on", 1284, "Warning", TS & "string1" & TE & "() Swapping >" & TS & "string2" & TE & "< with >" & TS & "string3" & TE & "< at (+0)s " & TS & "string4" & TE & ", " & TS & "string5" & TE & "  iSAMs " & TS & "string6" & TE & ", " & TS & "string7" & TE & "  at " & TS & "string1" & TE)
            // MyErrorMessages("on", 1285, "Information", "Distance = " & TS & "string1" & TE & " x1=" & TS & "string2" & TE & " y1=" & TS & "string3" & TE & " x2=" & TS & "string4" & TE & " y2=" & TS & "string5" & TE & " dist1=" & TS & "string6" & TE & " dist2=" & TS & "string7" & TE & " dist3=" & TS & "string8" & TE & " dist4=" & TS & "string9" & TE)
            // Not Used 1286
            // Not Used 1287
            // Not Used 1288
            // Not Used 1289
            // Not Used 1290
            // MyErrorMessages("on", 1291, "Information", "Didn't Find DataType >" & TS & "string1" & TE & "<")
            // Not Used 1292
            // MyErrorMessages("on", 1293, "Information", ">" & TS & "string1" & TE & "<.")
            // MyErrorMessages("on", 1294, "Information", ">" & TS & "string1" & TE & "< (" & TS & "string2" & TE & ", " & TS & "string3" & TE & ").")
            // MyErrorMessages("on", 1295, "Information", "(" & ts & "string1" & te & ", " & ts & "string2" & te & ")")
            // Not Used 1296
            // Not Used 1297
            MyErrorMessages("on", 1298, "Information", "at (+0) " + TS + "string1" + TE);
            MyErrorMessages("on", 1299, "Display", "Number of Symbol Names = " + TS + "string1" + TE + " ");
            // Not Used 1300
            // Not Used 1301
            // Not Used 1302
            // Not Used 1303
            // Not Used 1304
            // Not Used 1305
            // Not Used 1306
            // Not Used 1307
            // Not Used 1308
            // Not Used 1309
            // Not Used 1310
            // Not Used 1311
            // Not Used 1312
            // Not Used 1313
            // Not Used 1314
            // Not Used 1315
            // Not Used 1316
            // Not Used 1317
            // Not Used 1318
            // Not Used 1319
            // Not Used 1320
            MyErrorMessages("on", 1321, "Information", "XY (" + TS + "string1" + TE + ", " + TS + "string2" + TE + ")");
            MyErrorMessages("on", 1322, "Display", "Displaying symbol @ symbols= >" + TS + "string1" + TE + "<  >" + TS + "string2" + TE + "<  >" + TS + "string3" + TE + "<");
            // Not Used 1323
            MyErrorMessages("on", 1324, "Information", "Drawing Point at (+0) " + TS + "string1" + TE + " named >" + TS + "string2" + TE + "< symbol named >" + TS + "string3" + TE + "< Point Name = " + TS + "string4" + TE + ".");
            // Not Used 1325
            MyErrorMessages("on", 1326, "Warning", " number of flag " + TS + "string1" + TE + Constants.vbCrLf + "Swapping >" + TS + "string3" + TE + "< with >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "at Index's " + TS + "string5" + TE + ", " + TS + "string4" + TE + "  " + Constants.vbCrLf + "iSAMs " + TS + "string7" + TE + ", " + TS + "string6" + TE + "  ");
            MyErrorMessages("on", 1327, "Display", TS + "string1" + TE + "() Swapping >" + TS + "string2" + TE + "< with >" + TS + "string3" + TE + "< at (+0)s " + TS + "string4" + TE + ", " + TS + "string5" + TE + "  iSAMs " + TS + "string6" + TE + ", " + TS + "string7" + TE + "  at " + TS + "string1" + TE);
            // Not Used 1328
            // Not Used 1329
            // Not Used 1330
            // Not Used 1331
            MyErrorMessages("on", 1332, "Error", "return of adding this symbol failed and returnd an error code " + TS + "string1" + TE + " " + Constants.vbCrLf + " Symbol name : >" + TS + "string1" + TE + "<");
            MyErrorMessages("on", 1333, "Information", "Ready");
            // Not Used 1334
            // Not Used 1335
            // Not Used 1336
            MyErrorMessages("on", 1337, "Information", "Checking (+0) find " + Constants.vbCrLf + TS + "string2" + TE + " = Searching for " + Constants.vbCrLf + Constants.vbCrLf + "Before: " + TS + "string3" + TE + Constants.vbCrLf + "At    :" + TS + "string4" + TE + Constants.vbCrLf + "After :" + TS + "string5" + TE + Constants.vbCrLf + TS + "string6" + TE + Constants.vbCrLf + TS + "string7" + TE + Constants.vbCrLf + "Tracer = " + TS + "string1" + TE);
            // Not Used 1338
            // Not Used 1339
            // MyErrorMessages("on", 1340, "Information", "Checking (+0) find " & vbCrLf & "Searching for  = >" & TS & "string2" & TE & "<" & vbCrLf & "Before:>" & TS & "string3" & TE & "<" & vbCrLf & "At    :>" & TS & "string4" & TE & "<" & vbCrLf & "After :>" & TS & "string5" & TE & "<" & vbCrLf & vbCrLf & "FlowChart Index:" & TS & "string6" & TE & vbCrLf & "Named Index" & TS & "string7" & TE & vbCrLf & "Tracer = " & TS & "string1" & TE)
            // MyErrorMessages("on", 1341, "Information", "Checking (+0) find " & vbCrLf & "From FlowChart Searching for >" & TS & "string2" & TE & "<" & vbCrLf & vbCrLf & "Named Before: " & TS & "string3" & TE & vbCrLf & "Named At    :" & TS & "string4" & TE & vbCrLf & "Named After :" & TS & "string5" & TE & vbCrLf & "FlowChart Index=" & TS & "string6" & TE & vbCrLf & "Named Index =" & TS & "string7" & TE & vbCrLf & vbCrLf & "Tracer = " & TS & "string1" & TE)
            // Not Used 1342
            MyErrorMessages("on", 1343, "Information", "Checking (+0) find " + Constants.vbCrLf + "Searching for = >" + TS + "string2" + TE + "<" + Constants.vbCrLf + Constants.vbCrLf + "Before: " + TS + "string3" + TE + Constants.vbCrLf + "At    :" + TS + "string4" + TE + Constants.vbCrLf + "After :" + TS + "string5" + TE + Constants.vbCrLf + "FlowChart Index=" + TS + "string6" + TE + Constants.vbCrLf + "Named Index=" + TS + "string7" + TE + Constants.vbCrLf + "Tracer = " + TS + "string1" + TE);
            // Not Used 1344
            // Not Used 1345
            // Not Used 1346
            // Not Used 1347
            // Not Used 1348
            // Not Used 1349
            // Not Used 1350
            // Not Used 1351
            // Not Used 1352
            // Not Used 1353
            // Not Used 1354
            // Not Used 1355
            // Not Used 1356
            // Not Used 1357
            // Not Used 1358
            // Not Used 1359
            // Not Used 1360
            // Not Used 1361
            // Not Used 1362
            // Not Used 1363
            // Not Used 1364
            // Not Used 1365
            MyErrorMessages("on", 1366, "Information", "Checking Index find " + Constants.vbCrLf + "Searching for =" + TS + "string2" + TE + Constants.vbCrLf + Constants.vbCrLf + "Before: " + TS + "string3" + TE + Constants.vbCrLf + "At    :" + TS + "string4" + TE + Constants.vbCrLf + "After :" + TS + "string5" + TE + Constants.vbCrLf + TS + "string6" + TE + Constants.vbCrLf + TS + "string7" + TE + Constants.vbCrLf + "Tracer = " + TS + "string1" + TE);
            MyErrorMessages("on", 1367, "Information", "Checking Index find " + Constants.vbCrLf + "Searching for =" + TS + "string2" + TE + Constants.vbCrLf + "Before: " + TS + "string3" + TE + Constants.vbCrLf + "At    :" + TS + "string4" + TE + Constants.vbCrLf + "After :" + TS + "string5" + TE + Constants.vbCrLf + TS + "string6" + TE + Constants.vbCrLf + TS + "string7" + TE + Constants.vbCrLf + "Tracer = " + TS + "string1" + TE);
            // Not Used 1368
            // Not Used 1369
            // Not Used 1370
            // Not Used 1371
            // Not Used 1372
            MyErrorMessages("on", 1373, "Information", "Array iSAM is not in the correct order" + Constants.vbCrLf + "Searching for  >" + TS + "string1" + TE + "< " + Constants.vbCrLf + Constants.vbCrLf + "(+0) -1 = >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "(+0)    = >" + TS + "string3" + TE + "< " + Constants.vbCrLf + "(+0) +1 = >" + TS + "string4" + TE + "< ");
            // Not Used 1374
            MyErrorMessages("on", 1375, "Information", "Unknow Code " + Constants.vbCrLf + "> " + TS + "string1" + TE + "<" + Constants.vbCrLf + "Macro Code Text =>" + TS + "string2" + TE + "<" + Constants.vbCrLf + "(" + TS + "string3" + TE + ")_(" + TS + "string4" + TE + ")" + Constants.vbCrLf + "Links = " + TS + "string5" + TE + Constants.vbCrLf + "Named = " + TS + "string6" + TE + Constants.vbCrLf + "Other = " + TS + "string7" + TE + Constants.vbCrLf + "(+0) = " + TS + "string8" + TE);
            // Not Used 1376
            // 1377
            // Not Used 1378
            // Not Used 1379
            MyErrorMessages("on", 1380, "Warning", "The iSAM() points To an invalid index " + Constants.vbCrLf + "iSAM=" + TS + "string2" + TE + " " + Constants.vbCrLf + "(+0)=" + TS + "string3" + TE + Constants.vbCrLf + "Checking in routine " + TS + "string8" + TE + " called from " + TS + "routine" + TE + " tracer " + TS + "tracer" + TE);
            // Not Used 1381
            // Not Used 1382
            // Not Used 1383
            // Not Used 1384
            MyErrorMessages("on", 1385, "Error", "The array at index " + TS + "string1" + TE + " is empty  iSAM(+0) =" + TS + "string2" + TE + "  >" + TS + "string3" + TE + "<");
            // Not Used 1386
            // MyErrorMessages("on", 1387, "Error", "The iSAM() points To an invalid index In the array" & vbCrLf & "iSAM=" & TS & "string2" & TE & " " & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            // MyErrorMessages("on", 1388, "Warning", "The iSAM() points To an invalid index" & vbCrLf & "iSAM=" & TS & "string2" & TE & " " & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "routine=" & TS & "string2" & TE & " " & vbCrLf & "FromRoutine=" & TS & "string2" & TE & " " & vbCrLf & "Tracer=" & TS & "string2" & TE & " ")
            // MyErrorMessages("on", 1389, "Warning", "The iSAM() points To an invalid index In the array" & vbCrLf & "iSAM=" & TS & "string2" & TE & " " & vbCrLf & "(+0)=" & TS & "string3" & TE & vbCrLf & "routine=" & TS & "string2" & TE & " " & vbCrLf & "FromRoutine=" & TS & "string2" & TE & " " & vbCrLf & "Tracer=" & TS & "string2" & TE & " ")
            // MyErrorMessages("on", 1390, "Warning", "Index is below One " & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            // MyErrorMessages("on", 1391, "Error", "Index is greater than the max size of ARRAY()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            // MyErrorMessages("on", 1392, "Error", "Index is greater than the max size of iSAM()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            // MyErrorMessages("on", 1393, "Error", "Index is greater than the max size of ARRAY()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            // MyErrorMessages("on", 1394, "Error", "Index is greater than the max size of iSAM()" & vbCrLf & "Checking in routine " & TS & "string8" & TE & " called from " & TS & "routine" & TE & " tracer " & TS & "tracer" & TE)
            // MyErrorMessages("on", 1395, "Error", "The iSAM is out of order before index (Text1 & Text2)" & vbCrLf & "Text1 = " & TS & "string1" & TE & vbCrLf & "1st to 2nd = " & TS & "string4" & TE & vbCrLf & "Text2 = " & TS & "string2" & TE & vbCrLf & "Compare test used to determine this message = " & TS & "string6" & TE & vbCrLf & "called from " & TS & "string9" & TE)
            // MyErrorMessages("on", 1396, "Error", "The iSAM is out of order after index (Text2 & Text 3)" & vbCrLf & "Text2 = " & TS & "string2" & TE & vbCrLf & "2nd to 3rd = " & TS & "string5" & TE & vbCrLf & "text3 = " & TS & "string3" & TE & vbCrLf & "Compare test used to determine this message = " & TS & "string6" & TE & vbCrLf & "called from " & TS & "string9" & TE)
            // Not Used 1397
            // 1398
            // MyErrorMessages("on", 1399, "Error", "Invalid Index of >" & TS & "string1" & TE & "< called from " & TS & "string9" & TE)
            // MyErrorMessages("on", 1400, "Information", "Invalid (+0) of >" & TS & "string1" & TE & "< called from " & TS & "string9" & TE)
            // MyErrorMessages("on", 1401, "Information", "Invalid (+0) of >" & TS & "string1" & TE & "< called from " & TS & "string9" & TE)
            MyErrorMessages("on", 1402, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1403, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1404, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1405, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1406, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1407, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1408, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1409, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1410, "Error", "Line " + TS + "string3" + TE + ", Lost the >" + TS + "string1" + TE + "< " + Constants.vbCrLf + " >" + TS + "string2" + TE + "< " + Constants.vbCrLf + "for symbol name >" + TS + "string3" + TE + "<");
            MyErrorMessages("on", 1411, "Error", "Not Able to return a valid index for " + TS + "string1" + TE + " " + Constants.vbCrLf + " for keyword >" + TS + "string3" + TE + "<" + Constants.vbCrLf + " Inputline = >" + TS + "string4" + TE + "<" + Constants.vbCrLf + "Input Line Number = " + TS + "string5" + TE);
            // MyErrorMessages("on", 1413, "Error", "At step " & TS & "string2" & TE & ".  Adding blank information to the list >" & TS & "string1" & TE & "<   >" & TS & "string3" & TE & "<")
            MyErrorMessages("on", 1414, "Error", " at " + TS + "string2" + TE + ".  blank information changed to ? in the list from line " + TS + "string5" + TE + " " + Constants.vbCrLf + ">" + TS + "string3" + TE + "<" + Constants.vbCrLf + " the format should be :" + TS + "string4" + TE + Constants.vbCrLf + " inputLine is : " + TS + "string3" + TE);
            MyErrorMessages("on", 1433, "Information", "#" + TS + "string9" + TE + " - FlowChart Index = " + TS + "string1" + TE + " Symbol Index = " + TS + "string2" + TE + " named index " + TS + "string3" + TE);
            MyErrorMessages("on", 1436, "Error", "Invalid Message Error Number " + TS + "string1" + TE + " ERROR *******");
        }


        string MyCompareSinTax_S(string String1, string String2)
        {
            // Returns "Equal", "not equal", and future other stuff
            if (Strings.LCase(String1) == Strings.LCase(String2))
                return "equal";
            return "notequal";
        }



        void WhatKey(KeyPressEventArgs e)
        {
            string MyText;
            MyText = FlowChartScreen.ToolStripTextBoxMyInputText.Text + e.KeyChar.ToString;
            // characters I might have to take care of
            // vbHiragana, vbKatakana, vbLinguisticCasing, vbNarrowvbNewLine, vbSimplifiedChinese, vbTraditionalChinese, vbWide
            switch (e.KeyChar.ToString)
            {
            case "(":
            case ")":
            case "{":
            case "}":
            case "[":
            case "]":
            {
                ShowSinTax(MyText);
                return;
            }

            case "=":
            case "+":
            case "-":
            case "/":
            case "*":
            case "'":
            {
                ShowSinTax(MyText);
                return;
            }

            case "!":
            case "@":
            case "#":
            case "$":
            case "%":
            case "^":
            case "&":
            case "_":
            case "~":
            {
                ShowSinTax(MyText);
                return;
            }

            case "|":
                case & "\\":
                case ",":
                case ".":
                case "?":
                {
                    ShowSinTax(MyText);
                    return;
                }

                case " ":
                {
                    ShowSinTax(MyText);
                    return;
                }

                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                    case "9" // digits
                        :
                    {
                        ShowSinTax(MyText);
                        return;
                    }

                    case object _ when Keys.NumPad0.ToString:
                    case object _ when Keys.NumPad1.ToString:
                    case object _ when Keys.NumPad2.ToString:
                    case object _ when Keys.NumPad3.ToString:
                    case object _ when Keys.NumPad4.ToString:
                    case object _ when Keys.NumPad5.ToString:
                    case object _ when Keys.NumPad6.ToString:
                    case object _ when Keys.NumPad7.ToString:
                    case object _ when Keys.NumPad8.ToString:
                    case object _ when Keys.NumPad9.ToString:
                    {
                        ShowSinTax(MyText);
                        return;
                    }

                    case "a":
                    case "b":
                    case "c":
                    case "d":
                    case "e":
                    case "f":
                    case "g":
                    case "g":
                    case "i":
                    case "j":
                    case "k":
                    case "l":
                    case "m":
                    case "n":
                    case "o":
                    case "p":
                    case "q":
                    case "r":
                    case "s":
                    case "t":
                    case "u":
                    case "v":
                    case "w":
                    case "x":
                    case "y":
                    case "z":
                    {
                        ShowSinTax(MyText);
                        return;
                    }

                    case "A":
                    case "B":
                    case "C":
                    case "D":
                    case "E":
                    case "F":
                    case "G":
                    case "H":
                    case "I":
                    case "J":
                    case "K":
                    case "L":
                    case "M":
                    case "N":
                    case "O":
                    case "P":
                    case "Q":
                    case "R":
                    case "S":
                    case "T":
                    case "U":
                    case "V":
                    case "W":
                    case "X":
                    case "Y":
                    case "Z":
                    {
                        return;
                    }

                    case Constants.vbCr:
                    case Constants.vbCrLf:
                    case Constants.vbLf:
                    case Constants.vbTab:
                    case Constants.vbFormFeed:
                    case Strings.Chr(34):
                    {
                        return;
                    }

                    case Constants.vbBack:
                        case object _ when Strings.ChrW(1).ToString() // DELETE CHARACTER
                            :
                        {
                            return;
                        }

                        case object _ when Keys.Add.ToString     // =  107
                            :
                        {
                            return;
                        }

                        case object _ when Keys.MButton.ToString     // =  4
                            :
                        {
                            break;
                        }

                        case object _ when Keys.XButton1.ToString     // =  5
                            :
                        {
                            break;
                        }

                        case object _ when Keys.XButton2.ToString     // =  6
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Back.ToString     // =  8
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Tab.ToString     // =  9
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LineFeed.ToString     // =  10
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Clear.ToString     // =  12
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Return.ToString     // =  13
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Enter.ToString     // =  13
                            :
                        {
                            break;
                        }

                        case object _ when Keys.ShiftKey.ToString     // =  16
                            :
                        {
                            break;
                        }

                        case object _ when Keys.ControlKey.ToString     // =  17
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Menu.ToString     // =  18
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Pause.ToString     // =  19
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Capital.ToString     // =  20
                            :
                        {
                            break;
                        }

                        case object _ when Keys.CapsLock.ToString     // =  20
                            :
                        {
                            break;
                        }

                        case object _ when Keys.KanaMode.ToString     // =  21
                            :
                        {
                            break;
                        }

                        case object _ when Keys.HanguelMode.ToString     // =  22  
                            :
                        {
                            break;
                        }

                        case object _ when Keys.JunjaMode.ToString     // =  23
                            :
                        {
                            break;
                        }

                        case object _ when Keys.FinalMode.ToString     // =  24
                            :
                        {
                            break;
                        }

                        case object _ when Keys.HanjaMode.ToString     // =  25
                            :
                        {
                            break;
                        }

                        case object _ when Keys.KanjiMode.ToString     // =  25
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Escape.ToString     // =  27
                            :
                        {
                            break;
                        }

                        case object _ when Keys.IMEConvert.ToString     // =  28
                            :
                        {
                            break;
                        }

                        case object _ when Keys.IMENonconvert.ToString     // =  29
                            :
                        {
                            break;
                        }

                        case object _ when Keys.IMEAccept.ToString     // =  30
                            :
                        {
                            break;
                        }

                        case object _ when Keys.IMEModeChange.ToString     // =  31
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Prior.ToString     // =  33
                            :
                        {
                            break;
                        }

                        case object _ when Keys.PageUp.ToString     // =  33
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Next.ToString     // =  34
                            :
                        {
                            break;
                        }

                        case object _ when Keys.PageDown.ToString     // =  34
                            :
                        {
                            break;
                        }

                        case object _ when Keys.End.ToString     // =  35
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Home.ToString     // =  36
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Left.ToString     // =  37
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Up.ToString     // =  38
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Right.ToString     // =  39
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Down.ToString     // =  40
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Select.ToString     // =  41
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Print.ToString     // =  42
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Execute.ToString     // =  43
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Snapshot.ToString     // =  44
                            :
                        {
                            break;
                        }

                        case object _ when Keys.PrintScreen.ToString     // =  44
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Insert.ToString     // =  45
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Delete.ToString     // =  46
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Help.ToString     // =  47
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LWin.ToString     // =  91' Left Windows Key
                            :
                        {
                            break;
                        }

                        case object _ when Keys.RWin.ToString     // =  92'Right Windows key (Which doesn't exist)
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Apps.ToString     // =  93'This is the right mouse help button   ?
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Sleep.ToString     // =  95
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Multiply.ToString     // =  106
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Separator.ToString     // =  108
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Subtract.ToString     // =  109
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Decimal.ToString     // =  110
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Divide.ToString     // =  111
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F1.ToString     // =  112
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F2.ToString     // =  113
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F3.ToString     // =  114
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F4.ToString     // =  115
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F5.ToString     // =  116
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F6.ToString     // =  117
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F7.ToString     // =  118
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F8.ToString     // =  119
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F9.ToString     // =  120
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F10.ToString     // =  121
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F11.ToString     // =  122
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F12.ToString     // =  123
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F13.ToString     // =  124
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F14.ToString     // =  125
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F15.ToString     // =  126
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F16.ToString     // =  127
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F17.ToString     // =  128
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F18.ToString     // =  129
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F19.ToString     // =  130
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F20.ToString     // =  131
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F21.ToString     // =  132
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F22.ToString     // =  133
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F23.ToString     // =  134
                            :
                        {
                            break;
                        }

                        case object _ when Keys.F24.ToString     // =  135
                            :
                        {
                            break;
                        }

                        case object _ when Keys.NumLock.ToString     // =  144
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Scroll.ToString     // =  145
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LShiftKey.ToString     // =  160
                            :
                        {
                            break;
                        }

                        case object _ when Keys.RShiftKey.ToString     // =  161
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LControlKey.ToString     // =  162
                            :
                        {
                            break;
                        }

                        case object _ when Keys.RControlKey.ToString     // =  163
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LMenu.ToString     // =  164
                            :
                        {
                            break;
                        }

                        case object _ when Keys.RMenu.ToString     // =  165
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserBack.ToString     // =  166
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserForward.ToString     // =  167
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserRefresh.ToString     // =  168
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserStop.ToString     // =  169
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserSearch.ToString     // =  170
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserFavorites.ToString     // =  171
                            :
                        {
                            break;
                        }

                        case object _ when Keys.BrowserHome.ToString     // =  172
                            :
                        {
                            break;
                        }

                        case object _ when Keys.VolumeMute.ToString     // =  173
                            :
                        {
                            break;
                        }

                        case object _ when Keys.VolumeDown.ToString     // =  174
                            :
                        {
                            break;
                        }

                        case object _ when Keys.VolumeUp.ToString     // =  175
                            :
                        {
                            break;
                        }

                        case object _ when Keys.MediaNextTrack.ToString     // =  176
                            :
                        {
                            break;
                        }

                        case object _ when Keys.MediaPreviousTrack.ToString     // =  177
                            :
                        {
                            break;
                        }

                        case object _ when Keys.MediaStop.ToString     // =  178
                            :
                        {
                            break;
                        }

                        case object _ when Keys.MediaPlayPause.ToString     // =  179
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LaunchMail.ToString     // =  180
                            :
                        {
                            break;
                        }

                        case object _ when Keys.SelectMedia.ToString     // =  181
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LaunchApplication1.ToString     // =  182
                            :
                        {
                            break;
                        }

                        case object _ when Keys.LaunchApplication2.ToString     // =  183
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemSemicolon.ToString     // =  186
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem1.ToString     // =  186
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oemplus.ToString     // =  187
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oemcomma.ToString     // =  188
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemMinus.ToString     // =  189
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemPeriod.ToString     // =  190
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemQuestion.ToString     // =  191
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem2.ToString     // =  191
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oemtilde.ToString     // =  192
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem3.ToString     // =  192
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemOpenBrackets.ToString     // =  219
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem4.ToString     // =  219
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemPipe.ToString     // =  220
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem5.ToString     // =  220
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemCloseBrackets.ToString     // =  221
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem6.ToString     // =  221
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemQuotes.ToString     // =  222
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem7.ToString     // =  222
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem8.ToString     // =  223
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemBackslash.ToString     // =  226
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Oem102.ToString     // =  226
                            :
                        {
                            break;
                        }

                        case object _ when Keys.ProcessKey.ToString     // =  229
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Packet.ToString     // =  231
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Attn.ToString     // =  246
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Crsel.ToString     // =  247
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Exsel.ToString     // =  248
                            :
                        {
                            break;
                        }

                        case object _ when Keys.EraseEof.ToString     // =  249
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Play.ToString     // =  250
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Zoom.ToString     // =  251
                            :
                        {
                            break;
                        }

                        case object _ when Keys.NoName.ToString     // =  252
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Pa1.ToString     // =  253
                            :
                        {
                            break;
                        }

                        case object _ when Keys.OemClear.ToString     // =  254
                            :
                        {
                            break;
                        }

                        case object _ when Keys.KeyCode.ToString     // =  65535
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Shift.ToString     // =  65536
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Control.ToString     // =  131072
                            :
                        {
                            break;
                        }

                        case object _ when Keys.Alt.ToString     // =  262144
                            :
                        {
                            break;
                        }

                        default:
                        {
                            Abug(473, "unknown key pressed" + HighLight(e.GetType.FullName) + HighLight(e.GetType.Attributes.ToString), e.KeyChar, HighLight(e.KeyChar.ToString));
                            break;
                        }
            }
            AInfo(672, "A key pressed, but not used " + HighLight(e.GetType.FullName) + HighLight(e.GetType.Attributes.ToString), e.KeyChar, HighLight(e.KeyChar.ToString));
        }



        void ShowSinTax(string Temp) // Extra
        {
            // using the raw input here to show the syntax as you go.
            Temp = FlowChartScreen.ToolStripTextBoxMyInputText.Text; // Save the Code 
            pathnames = MyParse(ref My_Sintax_Line_Parsed, Temp);
            DisplayStatus(ref FlowChartScreen.LabelProgramStatus.Text, MakeStatementSintax(My_Sintax_Line_Parsed));
            MyDoEvents();
        }

        long MyShell(string Temp)
        {
            string DevicePathFileName;
            MyShell = 0;
            MyDoEvents();
            DevicePathFileName = Temp;
            if (FileSystem.Dir(DevicePathFileName) != "")
                return Interaction.Shell(DevicePathFileName, AppWinStyle.MaximizedFocus);

            switch (Interaction.MsgBox("Unable to find : " + Temp + Constants.vbCrLf + "Search for it?", MsgBoxStyle.YesNo | MsgBoxStyle.Information, "Unable to start the preprocessor for this language, Select another language"))
            {
            case MsgBoxResult.Abort:
            case MsgBoxResult.Cancel:
            case MsgBoxResult.Ignore:
            case MsgBoxResult.No:
            case MsgBoxResult.Retry:
            {
                break;
            }

            case MsgBoxResult.Yes:
            case MsgBoxResult.Ok:
            {
                // search for temp
                DevicePathFileName = FindFileName(Temp);
                if (DevicePathFileName != "")
                {
                    if (FileSystem.Dir(DevicePathFileName) != "")
                        return Interaction.Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, true, 1000);
                }
                Interaction.MsgBox("Search Failded to find program " + DevicePathFileName);
                break;
            }
            }
            // need to go find this 

            DevicePathFileName = &"\\" + Strings.Mid(Temp, 2, Strings.Len(Temp)) + Temp & "\\" + Temp; if (FileSystem.Dir(DevicePathFileName) != "")
                return Interaction.Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, true, 1000);
            DevicePathFileName = MyUniverse.MySystem.USER.MyCurrentDirectory & "\\" + Temp; if (FileSystem.Dir(DevicePathFileName) != "")
                return Interaction.Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, true, 1000);
        }

        bool FileIgnoreList(string PathName)
        {
            if (Strings.InStr(PathName, "$") != 0)
                return true;
            if (PathName == &"\\Recovery\\")
                return true;
                if (PathName == &"\\Support\\")
                    return true;
                    if (PathName == &"\\System Volume Information\\")
                        return true;
                        return false;
        }


        string FindFileName(string PathFileExt)
        {
            string DevicePathFile;
                string[] MyCurrentPath = new string[2];
                string MyPath, MyFileName, MyExtension;
                string WhereIsFile;
            long MyCurrent;
            MyDoEvents();
            DevicePathFile = PathFileExt;
            DisplayMyStatus("Searching " + PathFileExt + ". . . ");
            if (DevicePathFile == "")
                return "";
            if (Strings.Left(DevicePathFile, 2) == &"\\")
                DevicePathFile = Strings.Mid(DevicePathFile, 2, Strings.Len(DevicePathFile));

            if (FileSystem.Dir(DevicePathFile) != "")
                return FileSystem.Dir(DevicePathFile);

            MyPath = Path.GetDirectoryName(DevicePathFile);
            if (Strings.Right(MyPath, 1) != &"\\")
                MyPath += &"\\";
                MyFileName = Path.GetFileNameWithoutExtension(DevicePathFile);
                if (MyFileName == "")
                    return "";
                MyExtension = Path.GetExtension(DevicePathFile);



                MyCurrent = 1;
                MyCurrentPath[MyCurrent] = FileSystem.Dir(MyPath + "*", FileAttribute.Directory);
                if (MyCurrentPath[MyCurrent] != "")
                {
                    if (Strings.Right(MyCurrentPath[MyCurrent], 1) != &"\\")
                        MyCurrentPath[MyCurrent] = MyCurrentPath[MyCurrent] & "\\";
                        while (MyCurrentPath[MyCurrent] != "" & MyCurrentPath[MyCurrent] != MyPath)
                        {
                            if (FileIgnoreList(MyCurrentPath[MyCurrent]) == true)
                                MyCurrentPath[MyCurrent] = "";
                            else
                                MyCurrent += 1;
                                var oldMyCurrentPath = MyCurrentPath;
                                MyCurrentPath = new string[MyCurrent + 1];
                                if (oldMyCurrentPath != null)
                                    Array.Copy(oldMyCurrentPath, MyCurrentPath, Math.Min(MyCurrent + 1, oldMyCurrentPath.Length));
                            MyCurrentPath[MyCurrent] = MyPath + FileSystem.Dir(); // Get the next directory
                            if (MyCurrentPath[MyCurrent] != "")
                            {
                                if (Strings.Right(MyCurrentPath[MyCurrent], 1) != &"\\")
                                    MyCurrentPath[MyCurrent] = MyCurrentPath[MyCurrent] & "\\";
                            }
                        }
                }

            for (MyCurrent = Information.UBound(MyCurrentPath); MyCurrent >= Information.LBound(MyCurrentPath); MyCurrent += -1)
            {
                if (MyCurrentPath[MyCurrent] != "" & MyCurrentPath[MyCurrent] != MyPath)
                {
                    WhereIsFile = MyCurrentPath[MyCurrent] + MyFileName + MyExtension;
                        WhereIsFile = FindFileName(WhereIsFile);  // search all of the sub directories
                    if (WhereIsFile != "")
                        return WhereIsFile;
                }
            }

            return ""; // Not found anywhere (OK, anywhere I looked)
        }





        // ***********************************************************************
        // This starts the other program to init(When language is selected), preprocess(The entire file into the clipboard?), Post Process(From the clipboard? to file(s?))
        // breaking them up into files, will require a drilldown to be put back in.
        string C_L_Init()
        {
            string Temp;
            if (MyOptionTest(18) == true)
                return "";

            // TODO stop the old one if any 
            // todo set the fcprocessID to -1 in init() to flag that nothing is started
            // todo if fcprocessid is running then clipboard /FCfinish
            // todo then wait for it to finish
            // todo then start up the new process
            // fight now it just starts a new one
            // start the new language processor
            mydoevents();
            PutClipBoard("/FCInit");
            Temp = MyUniverse.MySystem.USER.MyCurrentDirectory & "\\" + MyUniverse.ProgramOptions.C_L_LanguageClassName + ".exe";
                MyUniverse.MySystem.FCProcessID = MyShell(Temp); // Nowait, 1000 wait if true
            if (MyUniverse.MySystem.FCProcessID < 0)
            {
                Temp = &"\\Program Files\\FC" + MyUniverse.ProgramOptions.C_L_LanguageClassName + ".exe";
                MyUniverse.MySystem.FCProcessID = MyShell(Temp); // Nowait, 1000 wait if true
                if (MyUniverse.MySystem.FCProcessID < 0)
                {
                    Temp = &"\\Program Files (x86)\\FC" + MyUniverse.ProgramOptions.C_L_LanguageClassName + ".exe";
                    MyUniverse.MySystem.FCProcessID = MyShell(Temp); // Nowait, 1000 wait if true
                }
            }

            if (MyUniverse.MySystem.FCProcessID < 0)
            {
                Interaction.MsgBox("Unable to start " + Temp, MsgBoxStyle.Critical, "Start the program " + Temp + "from the windows start menu." + Constants.vbCrLf + "Or move it where it will be looking for it.");
                return "";
                return;
            }
            return "";
        }


        // ***********************************************************************
        // This returns each line of code to decompile, converting into a generaic Syntax (keyWord, Operator, ...)
        // None of this is checked yet
        string C_L_PreProcessor(string KeyLine)
        {
            if (MyOptionTest(18) == true)
            {
                if (Strings.Len(MyTrim(KeyLine)) > 0)
                {
                    MyUniverse.MySystem.MyNOTaClipBoard = AddCameFromLine(AddGotoNextLine(KeyLine));
                    // " " & MyUniverse.ProgramOptions.C_L_MultiLine & MyUniverse.SysGen.Constants.ConstantCameFromLine & " Address" & (MyUniverse.MySS.Inputs.LineNumberIn - 1).ToString & " " &
                    // " " & MyUniverse.ProgramOptions.C_L_MultiLine & MyUniverse.SysGen.Constants.ConstantGotoNextLine & " Address" & MyUniverse.MySS.Inputs.LineNumberIn.ToString & " " &
                    return MyUniverse.MySystem.MyNOTaClipBoard;
                }
                else
                    return MyTrim(KeyLine);// returns nothing and no came from or goto 
            }
            PutClipBoard("/FCPre" + Constants.vbCrLf + KeyLine);
            return GetClipBoard();
        }

        // ***********************************************************************
        string C_L_PostProcessor(string KeyLine)
        {
            if (MyOptionTest(18) == true)
            {
                MyUniverse.MySystem.MyNOTaClipBoard = KeyLine;
                return MyUniverse.MySystem.MyNOTaClipBoard;
            }

            PutClipBoard("/FCPost" + Constants.vbCrLf + KeyLine);
            mydoevents();
            return GetClipBoard();
        }



        // lost
        string GetClipBoard() // Gets import/export file to process
        {
            long ErrorCount;
            mydoevents();
            // Wait until there is a /finish on the clipboard
            if (MyOptionTest(18) == true)
                return MyUniverse.MySystem.MyNOTaClipBoard;

            GetClipBoard = "";
            ErrorCount = 0;
            // it fails on everything, so I am delaying it 1/2 second each time. 
            System.Threading.Thread.Sleep(500);
            ;/* Cannot convert OnErrorGoToStatementSyntax, CONVERSION ERROR: Conversion for OnErrorGoToLabelStatement not implemented, please report this issue in 'On Error GoTo ClipBoardError' at character 1221304
   at ICSharpCode.CodeConverter.CSharp.VisualBasicConverter.MethodBodyVisitor.DefaultVisit(SyntaxNode node)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.VisitOnErrorGoToStatement(OnErrorGoToStatementSyntax node)
   at Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax.Accept[TResult](VisualBasicSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1.Visit(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.ConvertWithTrivia(SyntaxNode node)
   at ICSharpCode.CodeConverter.CSharp.CommentConvertingMethodBodyVisitor.DefaultVisit(SyntaxNode node)

Input:

            On Error GoTo ClipBoardError

 */
            if (Clipboard.GetDataObject.GetDataPresent(DataFormats.Text))
            {
                GetClipBoard = My.Computer.Clipboard.GetText();
                while (Strings.InStr(Strings.LCase(GetClipBoard), "/finish") == 0)
                {
                    mydoevents();
                    GetClipBoard = My.Computer.Clipboard.GetText();
                    mydoevents();
                    // hack fixed at half a second, needs to do this correctly in the future, and all of the error checking to make sure that the other program runs, or else it could hang forever. (Need at least a limit loop)
                    System.Threading.Thread.Sleep(500);
                    mydoevents();
                    // if not done in 30 seconds then exit with nothing from the clipboard

                    ErrorCount += 1; if (ErrorCount > 60)
                    {
                        // -MyTrace(4, "No responce from the language preprocessor program.  " & HighLight(My.Computer.Clipboard.GetText().ToString), 0)
                        // todo make the answer to include retry
                        switch (MsgBox("No response from the language preprocessor program." + Constants.vbCrLf + "Keep trying, or ignore alltogether?", MsgBoxStyle.RetryCancel | MsgBoxStyle.Exclamation, HighLight(My.Computer.Clipboard.GetText())))
                        {
                        case Constants.vbOK:
                        {
                            return My.Computer.Clipboard.GetText() + Constants.vbCrLf + "/Error not able to get the clip board " + "/finish";
                        }

                        case Constants.vbNo:
                        {
                            return My.Computer.Clipboard.GetText() + Constants.vbCrLf + "/Error not able to get the clip board " + "/finish";
                        }

                        case Constants.vbIgnore:
                        {
                            OptionScreen.CheckedListBoxOptionSelection.SetItemCheckState(18, CheckState.Unchecked);
                            break;
                        }
                        }
                        return;
                    }
                }
                My.Computer.Clipboard.Clear(); // clear it because we have the information
                mydoevents();
            }
            return;
        ClipBoardError:
            ;
            DisplayMyStatus("ClipBoard has error reading it.");
            mydoevents();
            return "/error=Error 2" + Constants.vbCrLf + "/Finish";
        }

        void Tracing(long IndexFlowChart, long value)
        {
            if (InvalidIndex(IndexFlowChart, FlowChart_FilePathSymbolName))
                Abug(999, "Invalid index ", IndexFlowChart, "");
            if (value == 0)
                AInfo(999, "Tracing", value, MyShowFlowChartRecordX(IndexFlowChart));
            if (value == 2000)
                AInfo1(999, "Tracing", value, MyShowFlowChartRecordX(IndexFlowChart));
            if (value == 3500)
                AInfo1(999, "Tracing", value, MyShowFlowChartRecordX(IndexFlowChart));
            if (value == 3750)
                AInfo1(999, "Tracing", value, MyShowFlowChartRecordX(IndexFlowChart));
        }



        void FindMyBugsROUTER_OnTop()
        {
            long IndexFlowChart;
            if (MyOptionTest(31) == false)
                return;

            for (IndexFlowChart = 1; IndexFlowChart <= TopOfFile("FlowChart"); IndexFlowChart++)
            {
                switch (FlowChart_TableCode(IndexFlowChart))
                {
                case "/path":
                {
                    FindMyBugsROUTER_FindDupPath(IndexFlowChart);
                    break;
                }

                case "/use" // Ignore, bacause it test paths against symbols later.
                    :
                {
                    break;
                }

                case "/error":
                {
                    break;
                }

                default:
                {
                    Abug(474, "code not taken care of ", MyShowFlowChartRecord(IndexFlowChart), "");
                    break;
                }
                }
            }
        }



        void FindMyBugsROUTER_FindDupPath(long IndexFlowChart)
        {
            long idex, Kdex;
            MyLineStructure A = default(MyLineStructure);
            MyLineStructure B = default(MyLineStructure);
            long C;
            if (MyOptionTest(31) == false)
                return;

            Kdex = TopOfFile("FlowChart");
            C = MyUniverse.SysGen.Constants.constantSymbolCenter;

            A = FlowChart2Line(IndexFlowChart);

            idex = ROUTER_Find_Lowest_Index(A.a.Xx - C - 1, FlowChart_FileX1, FlowChart_iSAM_X1); // -1 to get before the first path/symbol
            if (idex != 0)
            {
                idex = MyABS(idex);
                while (FlowChart_TableX1(FlowChart_iSAM_X1[idex]) < (A.a.Xx + C) & idex <= Kdex)
                {
                    if (FlowChart_iSAM_X1[idex] != IndexFlowChart)
                    {
                        switch (FlowChart_TableCode(idex))
                        {
                        case "/error":
                        {
                            AInfo(673, "Error ", "", MyShowFlowChartRecord(idex));
                            break;
                        }

                        case "/path":
                        {
                            B = FlowChart2Line(idex);
                            break;
                        }

                        case "/use":
                        {
                            B.a.Xx = FlowChart_TableX1(idex) - MyUniverse.SysGen.Constants.constantSymbolCenter;
                            B.a.Yy = FlowChart_TableY1(idex) - MyUniverse.SysGen.Constants.constantSymbolCenter;
                            B.b.Xx = FlowChart_TableX1(idex) + MyUniverse.SysGen.Constants.constantSymbolCenter;
                            B.b.Yy = FlowChart_TableY1(idex) + MyUniverse.SysGen.Constants.constantSymbolCenter;
                            if (FindingMyBugs_ROUTER_IsLineOnLine(A, B) == true)
                                Abug(475, "Path touches a symbol", MyShowFlowChartRecord(idex), MyShowFlowChartRecord(IndexFlowChart));
                            break;
                        }

                        case "":
                            case null // invalid index
                                :
                            {
                                break;
                            }

                            default:
                            {
                                Abug(476, "Code not taken care of ", MyShowFlowChartRecord(idex), "");
                                break;
                            }
                        }
                    }
                    idex += 1;
                }
            }
        }


        bool FindingMyBugs_ROUTER_IsLineOnLine(MyLineStructure a, MyLineStructure b)
        {
            MyLineStructure X = default(MyLineStructure);
            MyLineStructure Y = default(MyLineStructure);
            string DebugTemp1, dEBUGtEMP2;

            if (MyOptionTest(31) == false)
                return true;
            // order them 
            X.a.Xx = MyMin(a.a.Xx, a.b.Xx);
            X.b.Xx = MyMax(a.a.Xx, a.b.Xx);
            X.a.Yy = MyMin(a.a.Yy, a.b.Yy);
            X.b.Yy = MyMax(a.a.Yy, a.b.Yy);


            Y.a.Xx = MyMin(b.a.Xx, b.b.Xx);
            Y.b.Xx = MyMax(b.a.Xx, b.b.Xx);
            Y.a.Yy = MyMin(b.a.Yy, b.b.Yy);
            Y.b.Yy = MyMax(b.a.Yy, b.b.Yy);
            // does box/path a on box b
            DebugTemp1 = MyShow3Lines(X, Y, X);
            dEBUGtEMP2 = MyShow3Lines(a, b, a);
            // is A all leftof B
            if (X.b.Xx < Y.a.Xx & X.b.Xx < Y.a.Xx)
                return false; // A is all left B
            // Is A all right of B
            if (X.a.Xx > Y.b.Xx & X.a.Xx > Y.b.Xx)
                return false; // A is rightr of B

            // is A all above B
            if (X.b.Yy < Y.b.Yy & X.b.Yy < Y.a.Yy)
                return false; // A is all left B
            // Is A all below B
            if (X.a.Yy > Y.b.Yy & X.a.Yy > Y.b.Yy)
                return false; // A is rightr of B
            return true;
        }


        long ROUTER_Find_Lowest_Index(long XY, long[] MyArrayLong, long[] ISAM)
        {
            long Idex;
            // need to make sure this returns that index, not the x
            Idex = FindIndexIniSAMTable("FlowChart", ref "DoNotAdd", ref MyArrayLong, ref ISAM, ref XY); // 

            // gobackwards untill you are before it.
            while (Idex > 1)
            {
                if (XY == MyArrayLong[ISAM[Idex]])
                    Idex = ISAM[Idex - 1]; // one before this one.
                else
                    break;
            }
            return Idex;
        }

        static void PutClipBoard(string MyClipBoard) // Puts import/export file to process
        {
            // Dim x As Boolean
            // x = MyOptionTest(18)

            if (MyOptionTest(18) == true)
            {
                MyUniverse.MySystem.MyNOTaClipBoard = MyClipBoard;
                return;
            }
            My.Computer.Clipboard.Clear();
            My.Computer.Clipboard.SetText(MyClipBoard);
        }

        void SetUpHelpForm(Form CTL)
        {
            CTL.HelpButton = true;
        }


        void SetUpHelpComboBox(Form MyForm, ComboBox CTL, string HelpString)
        {
            switch (LCase(MyForm.Name))
            {
            case "symbolscreen":
            {
                SymbolScreen.HelpProviderSymbolScreen.SetShowHelp(CTL, true);
                SymbolScreen.HelpProviderSymbolScreen.SetHelpString(CTL, HelpString);
                SymbolScreen.HelpProviderSymbolScreen.HelpNamespace = MyUniverse.MySystem.USER.MyCurrentDirectory & "\\FlowChartHelpFiles\\FlowChartHelp011.html";
                SymbolScreen.HelpButton = true;
                break;
            }

            case "flowchartscreen":
            {
                break;
            }
            }
        }



        void SetUpHelpTextBox(Form MyForm, TextBox CTL, string HelpString)
        {
            switch (LCase(MyForm.Name))
            {
            case "symbolscreen":
            {
                SymbolScreen.HelpProviderSymbolScreen.SetShowHelp(CTL, true);
                SymbolScreen.HelpProviderSymbolScreen.SetHelpString(CTL, HelpString);
                SymbolScreen.HelpProviderSymbolScreen.HelpNamespace = MyUniverse.MySystem.USER.MyCurrentDirectory & "\\FlowChartHelpFiles\\FlowChartHelp011.html";
                SymbolScreen.HelpButton = true;
                break;
            }

            case "flowchartscreen":
            {
                break;
            }
            }
        }


        bool IsThisTheLanguageFileName(string X)
        {
            if (Strings.InStr(X, &"\\" + MyUniverse.ProgramOptions.C_L_LanguageClassName & "\\" + MyUniverse.ProgramOptions.C_L_DialectName) != 0)
                return true;
            else
                return false;
        }

        string FindLanguageClassName(string RootDirectory)
        {
            string A, X;
            long Kounter;
            var[] SubDirectories = new var[1];
            // This happens with there is a nothing for the directory name 
            if (Strings.InStr(RootDirectory, &"\\") != 0)
                return null;
            // first find the directory
            A = MyUniverse.ProgramOptions.C_L_LanguageClassName;
            X = FileSystem.Dir(RootDirectory + "*.", FileAttribute.Directory);
            while (X != "" & Strings.InStr(X, FD + A) == 0)
            {
                SubDirectories[Information.UBound(SubDirectories)] = X;
                if (FileNameOnly(X) == MyUniverse.ProgramOptions.C_L_LanguageClassName)
                    return RootDirectory + X;
                var oldSubDirectories = SubDirectories;
                SubDirectories = new object[Information.UBound(SubDirectories) + 1 + 1];
                if (oldSubDirectories != null)
                    Array.Copy(oldSubDirectories, SubDirectories, Math.Min(Information.UBound(SubDirectories) + 1 + 1, oldSubDirectories.Length));
                X = FileSystem.Dir();
            }
            for (Kounter = Information.LBound(SubDirectories); Kounter <= Information.UBound(SubDirectories); Kounter++)
            {
                X = FindLanguageClassName(RootDirectory + SubDirectories[Kounter] & "\\");
                    if (Strings.Len(X) > 0)
                        return X;
            }
            // second find the file

            return null;
        }





        // fill the dialect list box with this class of symbols.
        void ListBoxLanguageDialect()
        {
            MyUniverse.ProgramOptions.C_L_LanguageClassName = OptionScreen.ListBoxLanguage.SelectedItem;
            MyUniverse.ProgramOptions.C_L_DialectName = OptionScreen.ListBoxDialect.SelectedItem;

            if (Strings.Len(MyUniverse.ProgramOptions.C_L_LanguageClassName) == 0)
                return;

            // get the directory that this is at.
            MyUniverse.ProgramOptions.C_L_Directory = FindLanguageClassName(MyUniverse.MySystem.USER.DirectoryPath1 & "\\Languages\\");


                // Get the computer language now
                DisplayStatus(ref OptionScreen.LabelProgramStatus.Text, MyUniverse.ProgramOptions.C_L_Directory);
            C_L_Init();
            ImportLineOrFile(GetClipBoard());

            // Fails because it is not finding sub directory catagorys of classes of languages.
            Import(MyUniverse.ProgramOptions.C_L_Directory & "\\" + MyUniverse.ProgramOptions.C_L_DialectName + " definition.symbol");
                MyButtonsEnableRules();
            MyDoEvents();
        }



        string CPUID()
        {
            // GetInfo("Win32_Processor")
            return "Didnotwork";
        }
    };// end class FlowChartComputerLanguage
};//end name space MyFlowChartNameSpace